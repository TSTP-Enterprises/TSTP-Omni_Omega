### IMPORTS START ###
import csv
import email
import ftplib
import imaplib
import os
import re
import tempfile
import traceback
from PyQt5 import QtGui
from PyQt5 import QtWidgets
from PyQt5 import QtCore
import paramiko
from PyQt5.QtWebChannel import QWebChannel
import cv2
import sys
import wmi
import mss
import json
import math
import pytz
import time
import ctypes
import openai
import psutil
import pygame
import random
import shutil
import socket
import aiohttp
import asyncio
import hashlib
import imageio
import logging
import smtplib
import sqlite3
import zipfile
import datetime
import humanize
import platform
import requests
import schedule
import tiktoken
import anthropic
import importlib
import pyautogui
import pythoncom
import subprocess
import webbrowser
import numpy as np
from ast import Str
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from requests_oauthlib import OAuth2Session
from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent
from PyQt5.QtMultimediaWidgets import QVideoWidget
from _pytest.junitxml import ET
import winreg as reg
from time import sleep
import pygetwindow as gw
from datetime import datetime
from plyer import notification
from screeninfo import get_monitors
from email.message import EmailMessage
from watchdog.observers import Observer
from datetime import datetime, timedelta
from collections import Counter, defaultdict, deque
from PyQt5.QtGui import QIcon, QDesktopServices, QKeyEvent, QLinearGradient
from watchdog.events import FileSystemEventHandler
from PyQt5.QtWebEngineWidgets import QWebEngineView
from mysql.connector.fabric.connection import urllib2
from PyQt5.QtNetwork import QLocalServer, QLocalSocket
from PyQt5.QtCore import QProcess, Qt, pyqtSlot, QThread, QTimer, QSize, QDateTime, QObject, pyqtSignal, QUrl, QSortFilterProxyModel
from peewee import IntegerField, SqliteDatabase, Model, CharField, BooleanField, TextField, DateTimeField
from PyQt5.QtWidgets import (QApplication, QMainWindow, QAction, QStackedWidget, QStatusBar, qApp, QVBoxLayout, QPushButton, QDialog, QLabel,
                             QTableWidget, QHeaderView, QTableWidgetItem, QCheckBox, QMessageBox, QTabWidget, QTextEdit,
                             QLineEdit, QListWidget, QFileDialog, QComboBox, QHBoxLayout, QSystemTrayIcon, QMenu, QStyle,
                             QScrollArea, QWidget, QInputDialog, QGroupBox, QProgressDialog, QAbstractItemView, QDesktopWidget)
from PyQt5.QtGui import QBrush, QColor, QDesktopServices, QFontMetrics, QGuiApplication, QIcon, QImage, QKeySequence, QPainter, QPen, QPixmap, QPolygonF, QSyntaxHighlighter, QTextCharFormat, QFont, QTextCursor, QTextFormat, QTextOption
from PyQt5.QtCore import QCoreApplication, QDate, QDateTime, QDir, QEasingCurve, QEvent, QLineF, QObject, QPoint, QPointF, QPropertyAnimation, QRectF, QRect, QRegularExpression, QRunnable, QSettings, QSize, QStandardPaths, QThread, QThreadPool, QTime, QUrl, pyqtSignal, pyqtSlot, Qt, QTimer
from PyQt5.QtWidgets import QAbstractItemView, QApplication, QCalendarWidget, QColorDialog, QCompleter, QDateEdit, QDateTimeEdit, QDesktopWidget, QDialogButtonBox, QFileSystemModel, QFormLayout, QFrame, QGridLayout, QGroupBox, QHeaderView, QInputDialog, QLCDNumber, QListWidget, QListWidgetItem, QMainWindow, QMenuBar, QMessageBox, QPlainTextEdit, QProgressBar, QScrollArea, QSizePolicy, QSplitter, QStyleFactory, QSystemTrayIcon, QMenu, QAction, QTabWidget, QTableView, QTableWidget, QTableWidgetItem, QTextEdit, QComboBox, QPushButton, QFileDialog, QDialog, QTimeEdit, QToolBar, QToolButton, QTreeView, QVBoxLayout, QLabel, QLineEdit, QHBoxLayout, QFontComboBox, QSpinBox, QCheckBox, QShortcut, QWidget, qApp
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from fpdf import FPDF
import matplotlib.pyplot as plt
from bs4 import BeautifulSoup
from matplotlib.figure import Figure
### IMPORTS END ###

### SETTINGS START ###

logging.basicConfig(level=logging.INFO, filename='app.log', filemode='a',
                    format='%(asctime)s - %(levelname)s - %(message)s')

debug_mode = False
super_debug_mode = False
debug_mode_internal = False
show_debug = False
show_messagebox_toggle = False
toggleModeChange = 0
local_db_path = "C:\\TSTP\\OmniOmega\\DB\\network_tools.db"

#PATHS:
FileSorterDB_PATH = "C:\\TSTP\\OmniOmega\\DB\\FileSorter.db"
### SETTINGS END ###

ACTIVE_MODELS = {
    "OpenAI": [
        "gpt-4o", "gpt-4-turbo", "gpt-4", "gpt-4-0613", "gpt-3.5-turbo", "gpt-3.5-turbo-0613","dall-e",
    ],
    "Claude": [
        "claude-3-5-sonnet-20240620", "claude-3-opus-20240229", "claude-3-sonnet-20240229", "claude-3-haiku-20240307", "claude-2.0",
        "claude-v1.3", "claude-instant-v1", "claude-v1"
    ],
    "Google Gemini": [
        "gemini-1", "gemini-1.5", "gemini-2", "gemini-3"
    ],
    "Inflection Pi": [
        "inflection-2", "inflection-2.5"
    ]
}

async def main():
    system_info = await SystemInfo.get_system_info()
    network_info = await SystemInfo.get_network_info()
    os_info = await SystemInfo.get_os_info()
    hardware_info = await SystemInfo.get_hardware_info()

    print("System Information:")
    print("\n".join(system_info))
    print("\nNetwork Information:")
    print("\n".join(network_info))
    print("\nOperating System Information:")
    print("\n".join(os_info))
    print("\nHardware Information:")
    print("\n".join(hardware_info))

def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    base_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
    return os.path.join(base_path, relative_path)

### MAIN WINDOW START ###
class OmniOmega(QMainWindow):
    themeChanged = pyqtSignal(str)
    
    def __init__(self, notification_manager):
        super().__init__()
        self.toggleMode = False
        self.debug_mode = False
        self.dragging = False
        self.current_theme = 'Default UI'
        self.initThemes()
        self.trayIcon = QSystemTrayIcon(QIcon(resource_path("app_icon.ico")), self)
        self.fileSorterWindow = FileSorterMainForm(parent=self)
        self.setupTrayIcon()
        self.initUI()
        self.ScreenTool()
        self.loadThemeSettings()
        self.applyTheme()
        self.current_theme_index = 0
        self.notesDirectory = None
        self.defaultNotesDirectory = None
        self.autoSaveNoteFolder = None
        self.setupDatabaseAndSettings()
        self.timer_running = False
        self.start_time = None
        self.pop_out_windows = []
        QApplication.instance().processEvents()
        self.notification_manager = notification_manager
        self.db_manager = SchedulerDatabaseManager(notification_manager)
        self.wasMinimized = False
        self.btnNotifications = None
        self.loadWindowSettings()
        self.loadWidgetStates()
        self.loadActionStates()
        self.DuplicateRemoverMainWindow = None
        self.ParsingToolMainWindow = None
        self.ParseReverseApp = None
        self.auto_continue_app = None
        self.FTPManagerFTPApp = None

        QApplication.instance().setApplicationName("Omni Omega")

    def initThemes(self):
        self.themes = themes
        self.theme_keys = list(self.themes.keys())
        self.current_theme_index = 0
        self.theme_keys = list(self.themes.keys())
            
    def applyTheme(self, theme_name=None):
        try:
            # Check if a specific theme name is provided and valid
            if theme_name and theme_name in self.themes:
                # Set the current theme index based on the provided name
                self.current_theme_index = self.theme_keys.index(theme_name)
            else:
                # If no valid theme name is provided, use the current index to get the theme name
                theme_name = self.theme_keys[self.current_theme_index]

            # Apply the theme
            if theme_name in self.themes:
                self.setStyleSheet(self.themes[theme_name])
                self.current_theme = theme_name
                self.refreshUI()  # Refresh UI elements

                # Emit the themeChanged signal
                self.themeChanged.emit(self.themes[theme_name])

            # Save the current theme index to settings
            self.settings.setValue("currentThemeIndex", self.current_theme_index)

        except Exception as e:
            print(f"Error applying theme: {e}")
            # Fallback to default theme
            default_theme_name = "Default UI"
            self.current_theme_index = self.theme_keys.index(default_theme_name)
            self.setStyleSheet(self.themes[default_theme_name])
            self.current_theme = default_theme_name
            current_title = self.windowTitle().split(" - Current Theme:")[0]  # Ensure only the base title is used
            self.setWindowTitle(f"{current_title} - Current Theme: {default_theme_name}")
            self.refreshUI()  # Refresh UI elements

            # Emit the themeChanged signal
            self.themeChanged.emit(self.themes[default_theme_name])

            # Save the default theme index to settings
            self.settings.setValue("currentThemeIndex", self.current_theme_index)

    def applyThemeToWindow(self, window):
        try:
            # Apply the current theme to the provided window
            theme_name = self.theme_keys[self.current_theme_index]
            if theme_name in self.themes:
                window.setStyleSheet(self.themes[theme_name])
                self.refreshUIForWindow(window)
        except Exception as e:
            print(f"Error applying theme to window: {e}")

    def showAutoContinue(self):
        if not AutoContinueApp.tray_icon_created:
            self.auto_continue_app = AutoContinueApp(self)
            self.auto_continue_app.show()

            # Apply the current theme to the new AutoContinueApp
            self.applyThemeToWindow(self.auto_continue_app)

            # Connect the themeChanged signal to update the theme dynamically
            self.themeChanged.connect(lambda theme: self.applyThemeToWindow(self.auto_continue_app.menu))
        else:
            # If the AutoContinueApp instance already exists and is hidden, show it
            if self.auto_continue_app and self.auto_continue_app.isVisible() == False:
                self.auto_continue_app.show()

    def showChatWidget(self):
        self.loadThemeSettings()
        chat_window = QMainWindow(None)  # Create an independent window
        chat_widget = ChatWidget(chat_window)
        chat_window.setCentralWidget(chat_widget)
        chat_window.setWindowTitle("AI Chat Widget")
        chat_window.resize(800, 600)

        # Apply the current theme to the new window
        self.applyThemeToWindow(chat_window)
    
        # Connect the themeChanged signal to update the theme dynamically
        self.themeChanged.connect(lambda theme: self.applyThemeToWindow(chat_window))
    
        chat_window.show()
        self.pop_out_windows.append(chat_window)  # Keep a reference to prevent it from being garbage collected

    def showTerminalWidget(self):
        self.loadThemeSettings()
        terminal_window = QMainWindow(None)  # Create an independent window
        terminal_widget = CommandPromptWidget(terminal_window)
        terminal_window.setCentralWidget(terminal_widget)
        terminal_window.setWindowTitle("Terminal Widget")
        terminal_window.resize(800, 600)

        # Apply the current theme to the new window
        self.applyThemeToWindow(terminal_window)
    
        # Connect the themeChanged signal to update the theme dynamically
        self.themeChanged.connect(lambda theme: self.applyThemeToWindow(terminal_window))
    
        terminal_window.show()
        self.pop_out_windows.append(terminal_window)  # Keep a reference to prevent it from being garbage collected

    def showAdditionalNotesWidget(self):
        self.loadThemeSettings()
        terminal_window = QMainWindow(self)  # Create an independent window
        terminal_widget = AdditionalNotesWidget(terminal_window)
        terminal_window.setCentralWidget(terminal_widget)
        terminal_window.setWindowTitle("Additional Notes Widget")
        terminal_window.resize(800, 600)

        # Apply the current theme to the new window
        self.applyThemeToWindow(terminal_window)
    
        # Connect the themeChanged signal to update the theme dynamically
        self.themeChanged.connect(lambda theme: self.applyThemeToWindow(terminal_window))
    
        terminal_window.show()
        self.pop_out_windows.append(terminal_window)  # Keep a reference to prevent it from being garbage collected

    def showSSHWidget(self):
        self.loadThemeSettings()
        ssh_window = QMainWindow(None)  # Create an independent window
        ssh_widget = SSHToolMainWidget(ssh_window)
        ssh_window.setCentralWidget(ssh_widget)
        ssh_window.setWindowTitle("SSH Widget")
        ssh_window.resize(800, 600)

        # Apply the current theme to the new window
        self.applyThemeToWindow(ssh_window)
    
        # Connect the themeChanged signal to update the theme dynamically
        self.themeChanged.connect(lambda theme: self.applyThemeToWindow(ssh_window))
    
        ssh_window.show()
        self.pop_out_windows.append(ssh_window)  # Keep a reference to prevent it from being garbage collected

    def showDBWidget(self):
        self.loadThemeSettings()
        db_window = QMainWindow(None)  # Create an independent window
        db_widget = DatabaseViewerWidget(db_window)
        db_window.setCentralWidget(db_widget)
        db_window.setWindowTitle("Database Widget")
        db_window.resize(800, 600)

        # Apply the current theme to the new window
        self.applyThemeToWindow(db_window)
    
        # Connect the themeChanged signal to update the theme dynamically
        self.themeChanged.connect(lambda theme: self.applyThemeToWindow(db_window))
    
        db_window.show()
        self.pop_out_windows.append(db_window)  # Keep a reference to prevent it from being garbage collected

    def setupTrayIcon(self):
        trayMenu = QMenu(self)

        # Always On Top and Close to Tray actions
        self.alwaysOnTopTrayAction = QAction('Always On Top', self, checkable=True)
        self.alwaysOnTopTrayAction.triggered.connect(self.toggleAlwaysOnTop)
        trayMenu.addAction(self.alwaysOnTopTrayAction)

        self.closeToTrayAction = QAction('Close to Tray', self, checkable=True)
        self.closeToTrayAction.triggered.connect(self.toggleCloseToTray)
        trayMenu.addAction(self.closeToTrayAction)

        openAction = QAction("Open", self)
        openAction.triggered.connect(self.show)
        trayMenu.addAction(openAction)

        widgetsMenu = QMenu("Widgets", self)
    
        chatWidgetAction = QAction('AI Chat', self)
        chatWidgetAction.triggered.connect(self.showChatWidget)
        widgetsMenu.addAction(chatWidgetAction)

        terminalWidgetAction = QAction('Terminal', self)
        terminalWidgetAction.triggered.connect(self.showTerminalWidget)
        widgetsMenu.addAction(terminalWidgetAction)

        sshWidgetAction = QAction('SSH', self)
        sshWidgetAction.triggered.connect(self.showSSHWidget)
        widgetsMenu.addAction(sshWidgetAction)

        dbWidgetAction = QAction('DB Viewer', self)
        dbWidgetAction.triggered.connect(self.showDBWidget)
        widgetsMenu.addAction(dbWidgetAction)

        additionalNotesWidgetAction = QAction('Additional Notes', self)
        additionalNotesWidgetAction.triggered.connect(self.showAdditionalNotesWidget)
        widgetsMenu.addAction(additionalNotesWidgetAction)

        trayMenu.addMenu(widgetsMenu)

        # Omni Omega submenu
        omniOmegaMenu = QMenu("Omni Omega", self)

        teamsAction = QAction('Clock In/Out', self)
        teamsAction.triggered.connect(self.sendClockedInMessage)
        #omniOmegaMenu.addAction(teamsAction)

        reportAction = QAction('Reports', self)
        reportAction.triggered.connect(self.openReportWindow)
        omniOmegaMenu.addAction(reportAction)

        settingsAction = QAction('Settings', self)
        settingsAction.triggered.connect(self.openSettings)
        omniOmegaMenu.addAction(settingsAction)

        aboutAction = QAction('About', self)
        aboutAction.triggered.connect(self.showAboutDialog)
        omniOmegaMenu.addAction(aboutAction)

        donateAction = QAction('Donate', self)
        donateAction.triggered.connect(self.openDonateLink)
        omniOmegaMenu.addAction(donateAction)

        trayMenu.addMenu(omniOmegaMenu)

        # Theme submenu
        themesMenu = self.createThemeMenu()
        trayMenu.addMenu(themesMenu)

        # Screen Tool submenu
        screenToolMenu = QMenu("Screen Tool", self)
        screenToolAction = QAction("Open ScreenTool", self)
        screenToolAction.triggered.connect(self.showScreenToolWindow)
        screenToolMenu.addAction(screenToolAction)

        actionCaptureScreenshot = QAction("Capture Screenshot", self)
        actionCaptureScreenshot.triggered.connect(self.ScreenToolcaptureScreenshotNow)
        screenToolMenu.addAction(actionCaptureScreenshot)

        actionCaptureDelayScreenshot = QAction("Delayed Capture Screenshot", self)
        actionCaptureDelayScreenshot.triggered.connect(self.ScreenToolquickCaptureScreenshotWithDelay)
        screenToolMenu.addAction(actionCaptureDelayScreenshot)

        snipButton = QAction("Snip", self)
        snipButton.triggered.connect(self.ScreenToollaunchSnippingTool)
        screenToolMenu.addAction(snipButton)

        actionCaptureSection = QAction("Capture Section", self)
        actionCaptureSection.triggered.connect(self.ScreenToolcaptureScreenshot)
        screenToolMenu.addAction(actionCaptureSection)

        toggleNotificationsAction = QAction("Toggle Notifications", self)
        toggleNotificationsAction.setCheckable(True)
        toggleNotificationsAction.setChecked(False)
        toggleNotificationsAction.triggered.connect(self.ScreenTooltoggleNotifications)
        screenToolMenu.addAction(toggleNotificationsAction)

        screenToolMenu.addAction("Record Screen", self.ScreenToolshowRecordingControl)
        screenToolMenu.addAction("Create GIF", self.ScreenToolcreateGifFromScreenshots)
        screenToolMenu.addAction("Select Window", self.ScreenToolselectWindow)
        screenToolMenu.addAction("Settings", self.ScreenToolshowSettings)
        screenToolMenu.addAction("About", self.ScreenToolshowAboutDialog)
        screenToolMenu.addAction("Donate", lambda: webbrowser.open("https://www.tstp.xyz/donate"))

        trayMenu.addMenu(screenToolMenu)  # Add Screen Tool as a submenu

        # File Sorter submenu
        fileSorterMenu = QMenu("File Sorter", self)
        fileSorterSubMenu = self.fileSorterWindow.createTrayMenu()
        for action in fileSorterSubMenu.actions():
            fileSorterMenu.addAction(action)

        trayMenu.addMenu(fileSorterMenu)  # Add File Sorter as a submenu

        # Utility Tools submenu
        utilityMenu = QMenu("Utility Tools", self)
        duplicateRemoverAction = QAction("Duplicate Remover", self)
        duplicateRemoverAction.triggered.connect(self.showDuplicateRemoverWindow)
        utilityMenu.addAction(duplicateRemoverAction)

        userScannerAction = QAction("User Scanner", self)
        userScannerAction.triggered.connect(self.showUserScannerWindow)
        utilityMenu.addAction(userScannerAction)

        ftpManagerAction = QAction("FTP Manager", self)
        ftpManagerAction.triggered.connect(self.showFTPManager)
        utilityMenu.addAction(ftpManagerAction)

        parsingToolAction = QAction("Parsing Tool", self)
        parsingToolAction.triggered.connect(self.showParsingTool)
        utilityMenu.addAction(parsingToolAction)

        parseReverseAction = QAction("Parse Reverse", self)
        parseReverseAction.triggered.connect(self.showParseReverse)
        utilityMenu.addAction(parseReverseAction)

        autoContinueAction = QAction("Auto Continue", self)
        autoContinueAction.triggered.connect(self.showAutoContinue)
        utilityMenu.addAction(autoContinueAction)

        trayMenu.addMenu(utilityMenu)

        # Network Tools submenu
        networkToolsMenu = QMenu("Network Tools", self)

        networkPassToolAction = QAction("Network Password Tool", self)
        networkPassToolAction.triggered.connect(self.showNetworkPassTool)
        networkToolsMenu.addAction(networkPassToolAction)

        networkMonitorAction = QAction("Network Monitor", self)
        networkMonitorAction.triggered.connect(self.showNetworkMonitor)
        networkToolsMenu.addAction(networkMonitorAction)

        speedTestAction = QAction("Speed Test", self)
        speedTestAction.triggered.connect(self.showSpeedTest)
        networkToolsMenu.addAction(speedTestAction)

        apiTesterAction = QAction("API Tester", self)
        apiTesterAction.triggered.connect(self.showAPITest)
        networkToolsMenu.addAction(apiTesterAction)

        trayMenu.addMenu(networkToolsMenu)

        # Exit action
        exitAction = QAction("Exit", self)
        exitAction.triggered.connect(QCoreApplication.instance().quit)
        trayMenu.addAction(exitAction)

        self.trayIcon.setContextMenu(trayMenu)
        self.trayIcon.activated.connect(self.onTrayIconActivated)
        self.trayIcon.setToolTip("TSTP:Omni Omega")
        self.trayIcon.show()

    def initUI(self):
        self.setWindowFlags(Qt.FramelessWindowHint)
        self.settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
        self.original_geometry = (300, 300, 600, 500)
        self.setGeometry(*self.original_geometry)
        #self.setFixedSize(self.size())
        self.setWindowTitle('TSTP:Omni Omega')
        self.setWindowIcon(QIcon(resource_path("app_icon.ico")))

        self.createDropdowns()
        self.createTextArea()
        self.createMenus()
        self.createProductivityWidget()
        self.createSpecialFeaturesWidget()
        self.createLauncherWidget()
        self.createButtons()
        self.createSearchBar()
        self.createFormattingOptions()
        self.createTagsOption()
        self.createNotebooksDropdown()
        self.createTimestampButton()

        # Add the password section below the last row of controls
        self.createPasswordSection()

        self.autosaveTimer = QTimer()
        self.autosaveTimer.timeout.connect(self.autosaveNote)
        self.autosaveTimer.start(5000)  # Autosave every 5 seconds

        self.createKeyboardShortcuts()
        self.show()
        self.adjustWidgetPositions()

    def showScreenToolWindow(self):
        self.screenToolWindow = QMainWindow(self)
        self.screenToolWindow.setWindowTitle("TSTP: Screen Tool")
        self.screenToolWindow.setWindowIcon(QIcon(resource_path('app_icon.ico')))
        self.screenToolWindow.setGeometry(100, 100, 300, 370)
        
        layout = QVBoxLayout()
        centralWidget = QWidget()
        self.screenToolWindow.setCentralWidget(centralWidget)
        centralWidget.setLayout(layout)

        self.ScreenToolsetupMainUI(layout)
        
        self.screenToolWindow.show()

    def ScreenToolsetupMainUI(self, layout):
        self.collapseButton = QPushButton("Collapse")
        self.collapseButton.clicked.connect(self.ScreenTooltoggleCollapseExpand)
        layout.addWidget(self.collapseButton)

        btnCaptureScreenshot = QPushButton("Quick Capture Screenshot")
        btnCaptureScreenshot.clicked.connect(self.ScreenToolcaptureScreenshotNow)
        layout.addWidget(btnCaptureScreenshot)

        btnCaptureScreenshotDelay = QPushButton("Delayed Capture Screenshot")
        btnCaptureScreenshotDelay.clicked.connect(self.ScreenToolquickCaptureScreenshotWithDelay)
        layout.addWidget(btnCaptureScreenshotDelay)
        
        snipButton = QPushButton("Snip")
        snipButton.clicked.connect(self.ScreenToollaunchSnippingTool)
        layout.addWidget(snipButton)

        btnCaptureSection = QPushButton("Capture Section")
        btnCaptureSection.clicked.connect(self.ScreenToolcaptureScreenshot)
        layout.addWidget(btnCaptureSection)

        btnRecordScreen = QPushButton("Record Screen")
        btnRecordScreen.clicked.connect(self.ScreenToolshowRecordingControl)
        layout.addWidget(btnRecordScreen)

        btnCreateGif = QPushButton("Create GIF from Screenshots")
        btnCreateGif.clicked.connect(self.ScreenToolcreateGifFromScreenshots)
        layout.addWidget(btnCreateGif)

        btnSelectWindow = QPushButton("Select Window")
        btnSelectWindow.clicked.connect(self.ScreenToolselectWindow)
        layout.addWidget(btnSelectWindow)

        btnSettings = QPushButton("Settings")
        btnSettings.clicked.connect(self.ScreenToolshowSettings)
        layout.addWidget(btnSettings)

        btnAbout = QPushButton("About")
        btnAbout.clicked.connect(self.ScreenToolshowAboutDialog)
        layout.addWidget(btnAbout)

        self.btnNotifications = QPushButton("Notifications ON", self.screenToolWindow)
        self.btnNotifications.clicked.connect(self.ScreenTooltoggleNotifications)
        layout.addWidget(self.btnNotifications)

        btnDonate = QPushButton("Donate")
        btnDonate.clicked.connect(lambda: webbrowser.open("https://www.tstp.xyz/donate"))
        layout.addWidget(btnDonate)

        self.toggleWidgets = [btnCaptureScreenshot, btnCaptureScreenshotDelay, snipButton, 
                              btnCaptureSection, btnRecordScreen, btnCreateGif, btnSelectWindow,
                              btnSettings, btnAbout, self.btnNotifications, btnDonate]
        
    def ScreenTool(self):
        self.notifications_toggle = notifications_toggle
        self.selectedWindow = None
        self.selectedMonitor = None
        self.selectedMonitorIndex = None
        self.minimizeOnClose = config.get("minimizeOnClose", False)
        self.recordingTimer = None
        self.videoWriter = None
        self.isRecording = False
        self.collapsed = False
        self.recordingStatusIndicator = None
        self.debug_mode = debug_mode
        self.gifResolution = tuple(map(int, config.get("gifResolution", "640x480").split('x')))
        self.version = "1"
        self.ScreenToolsetDefaultSavePathAndMonitor()
        self.localServer = QLocalServer(self)
        self.drawing = False
        self.last_point = QPoint()
        self.annotation_color = Qt.red
        self.annotation_thickness = 2
        self.pixmap = QPixmap(self.size())
        self.pixmap.fill(Qt.white)
        self.annotateBeforeSaving = True
        self.snippingAnnotateBeforeSaving = True
        self.recordingControlDialog = None
        #if not self.localServer.listen("ScreenToolIdentifier"):
        #    # If the server is already running, quit it and start a new one
        #    self.localServer.close()
        #    self.localServer.listen("ScreenToolIdentifier")
            
        self.server = QLocalServer(self)
        self.server.listen("ScreenToolIdentifier")
        #self.server.newConnection.connect(self.handleNewConnection)
        
    def showDuplicateRemoverWindow(self):
        if not self.DuplicateRemoverMainWindow or not self.DuplicateRemoverMainWindow.isVisible():
            self.DuplicateRemoverMainWindow = DuplicateRemoverMainWindow(self)
            self.DuplicateRemoverMainWindow.show()

    def showSpeedTest(self):
        self.loadThemeSettings()
        if not hasattr(self, 'speed_test_window') or not self.speed_test_window.isVisible():
            self.speed_test_window = SpeedTestGUI()
            self.speed_test_window.setWindowFlags(Qt.Window | Qt.CustomizeWindowHint | Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint | Qt.WindowCloseButtonHint)
            self.speed_test_window.setWindowTitle("Speed Test Tool - TSTP:Omni Omega")
            self.applyThemeToWindow(self.speed_test_window)
            self.themeChanged.connect(lambda theme: self.applyThemeToWindow(self.speed_test_window))
        self.speed_test_window.show()

    def showNetworkMonitor(self):
        self.loadThemeSettings()
        if not hasattr(self, 'network_monitor_window') or not self.network_monitor_window.isVisible():
            self.network_monitor_window = NetworkTrafficMonitor()
            self.network_monitor_window.setWindowFlags(Qt.Window | Qt.CustomizeWindowHint | Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint | Qt.WindowCloseButtonHint)
            self.network_monitor_window.setWindowTitle("Network Traffic Monitor - TSTP:Omni Omega")
            self.applyThemeToWindow(self.network_monitor_window)
            self.themeChanged.connect(lambda theme: self.applyThemeToWindow(self.network_monitor_window))
        self.network_monitor_window.show()

    def showAPITest(self):
        # Placeholder for the API Tester window
        print("API Tester tool will be launched.")

    def showNetworkPassTool(self):
        self.loadThemeSettings()
        if not hasattr(self, 'network_pass_tool_window') or not self.network_pass_tool_window.isVisible():
            self.network_pass_tool_window = NetworkPassTool()
            self.network_pass_tool_window.setWindowFlags(Qt.Window | Qt.CustomizeWindowHint | Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint | Qt.WindowCloseButtonHint)
            self.network_pass_tool_window.setWindowTitle("Network Password Tool - TSTP:Omni Omega")
            self.applyThemeToWindow(self.network_pass_tool_window)
            self.themeChanged.connect(lambda theme: self.applyThemeToWindow(self.network_pass_tool_window))
        self.network_pass_tool_window.show()

    def showParsingTool(self):
        self.loadThemeSettings()
        if not hasattr(self, 'parsing_tool_window') or not self.parsing_tool_window.isVisible():
            self.parsing_tool_window = ParsingToolMainWindow(None)  # Create an independent window
            self.parsing_tool_window.setWindowFlags(Qt.Window | Qt.CustomizeWindowHint | Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint | Qt.WindowCloseButtonHint)
            self.parsing_tool_window.setWindowTitle("Parsing Tool - TSTP:Omni Omega")
            self.applyThemeToWindow(self.parsing_tool_window)
            self.themeChanged.connect(lambda theme: self.applyThemeToWindow(self.parsing_tool_window))
        self.parsing_tool_window.show()

    def showParseReverse(self):
        self.loadThemeSettings()
        if not hasattr(self, 'parse_reverse_window') or not self.parse_reverse_window.isVisible():
            self.parse_reverse_window = ParseReverseApp(None)  # Create an independent window
            self.parse_reverse_window.setWindowFlags(Qt.Window | Qt.CustomizeWindowHint | Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint | Qt.WindowCloseButtonHint)
            self.parse_reverse_window.setWindowTitle("Parse Reverse - TSTP:Omni Omega")
            self.applyThemeToWindow(self.parse_reverse_window)
            self.themeChanged.connect(lambda theme: self.applyThemeToWindow(self.parse_reverse_window))
        self.parse_reverse_window.show()

    def showFTPManager(self):
        if not FTPManagerFTPApp._instance_visible:
            self.FTPManagerFTPApp = FTPManagerFTPApp(self)
            self.FTPManagerFTPApp.show()
        else:
            self.FTPManagerFTPApp.raise_()
            self.FTPManagerFTPApp.activateWindow()

    def showUserScannerWindow(self):
        self.user_scanner_window = UserScanner(self)
        self.user_scanner_window.show()

    def handle_message_sent(self, api_type, message, response_info):
        for window in self.pop_out_windows:
            if window != self.sender().parent():
                window.chat_widget.send_message(api_type, message, response_info)

    def get_toggle_mode(self):
        return self.toggleMode

    def get_debug_mode(self):
        return self.debug_mode

    def loadThemeSettings(self):
        # Load the current theme from settings
        self.current_theme_index = self.settings.value("currentThemeIndex", 0, type=int)
        
    def setupDatabaseAndSettings(self):
        self.dbConnection = sqlite3.connect('omni_omega.db')
        self.checkDatabase()
        self.loadSettings()
        
    def toggleAlwaysOnTop(self):
        self.setWindowFlags(self.windowFlags() ^ Qt.WindowStaysOnTopHint)
        self.show()
        self.saveActionStates()  # Save the state immediately

    def toggleCloseToTray(self, checked):
        self.closeToTray = checked
        self.saveActionStates()

    def saveActionStates(self):
        self.settings.setValue("alwaysOnTop", self.alwaysOnTopTrayAction.isChecked())
        self.settings.setValue("closeToTray", self.closeToTrayAction.isChecked())

    def loadActionStates(self):
        always_on_top = self.settings.value("alwaysOnTop", False, type=bool)
        close_to_tray = self.settings.value("closeToTray", False, type=bool)

        self.alwaysOnTopTrayAction.setChecked(always_on_top)
        self.closeToTrayAction.setChecked(close_to_tray)

        # Apply the states to the window
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint if always_on_top else self.windowFlags() & ~Qt.WindowStaysOnTopHint)
        self.closeToTray = close_to_tray
        self.show()

    def openBrowserSelector(self):
        # Ensure the parent is of type MainWidget or similar
        parent_widget = self
        if parent_widget and hasattr(parent_widget, 'themes') and hasattr(parent_widget, 'current_theme'):
            self.browser_selector = BrowserSelector(theme=parent_widget.themes[parent_widget.current_theme])
            self.browser_selector.show()
        else:
            print("Parent widget does not have 'themes' or 'current_theme' attributes")

    def open_scheduler_dialog(self):
        item_name = ""
        item_type = ""
        item_path = ""
        scheduler_dialog = SchedulerDialog(item_name, item_type, item_path, self.db_manager, self.themes[self.current_theme])
        scheduler_dialog.exec_()

    def open_main_tutorial(self):
        tutorial_window = TutorialWindow(self)
        tutorial_window.exec_() 

    def open_schedule_window(self):
        self.schedule_window = ScheduleWindow(self.db_manager, self.themes[self.current_theme])
        self.schedule_window.show()

    def createProductivityWidget(self):
        self.productivityWidget = ProductivityWidgets(self)
        self.productivityWidget.setGeometry(0, 30, 500, self.height() - 60)  # Increase width by 25%
        #self.additionalNotesWidget.setStyleSheet("background-color: orange;")
        self.productivityWidget.hide()

    def createSpecialFeaturesWidget(self):
        self.specialFeaturesWidget = SpecialFeaturesWidget(self, note_maker_instance=self)
        self.specialFeaturesWidget.setGeometry(500, 30, self.width() - 1000, 300)  # Dynamic width
        #self.specialFeaturesWidget.setStyleSheet("background-color: lightgreen;")
        self.specialFeaturesWidget.hide()

    def createLauncherWidget(self):
        self.launcherWidget = LauncherWidget(self, note_maker_instance=self, settings=self.settings)
        self.launcherWidget.setGeometry(self.width() - 500, 30, 500, self.height() - 60)
        self.launcherWidget.hide()
        
    def createMenus(self):
        self.setMenuBar(DraggableMenuBar(self))

        # File Menu
        fileMenu = self.menuBar().addMenu('&File')
    
        if show_debug:
            debugAction = QAction('Debug', self)
            debugAction.setCheckable(True)
            debugAction.triggered.connect(self.debugToggle)
            fileMenu.addAction(debugAction)

        # Omni Omega submenu
        omniOmegaMenu = fileMenu.addMenu("Omni Omega")

        reportAction = QAction('Reports', self)
        reportAction.triggered.connect(self.openReportWindow)
        omniOmegaMenu.addAction(reportAction)

        settingsAction = QAction('Settings', self)
        settingsAction.triggered.connect(self.openSettings)
        omniOmegaMenu.addAction(settingsAction)

        aboutAction = QAction('About', self)
        aboutAction.triggered.connect(self.showAboutDialog)
        omniOmegaMenu.addAction(aboutAction)

        donateAction = QAction('Donate', self)
        donateAction.triggered.connect(self.openDonateLink)
        omniOmegaMenu.addAction(donateAction)

        # Screen Tool submenu
        screenToolMenu = fileMenu.addMenu("Screen Tool")

        screenToolAction = QAction("Open ScreenTool", self)
        screenToolAction.triggered.connect(self.showScreenToolWindow)
        screenToolMenu.addAction(screenToolAction)

        actionCaptureScreenshot = QAction("Capture Screenshot", self)
        actionCaptureScreenshot.triggered.connect(self.ScreenToolcaptureScreenshotNow)
        screenToolMenu.addAction(actionCaptureScreenshot)

        actionCaptureDelayScreenshot = QAction("Delayed Capture Screenshot", self)
        actionCaptureDelayScreenshot.triggered.connect(self.ScreenToolquickCaptureScreenshotWithDelay)
        screenToolMenu.addAction(actionCaptureDelayScreenshot)

        snipButton = QAction("Snip", self)
        snipButton.triggered.connect(self.ScreenToollaunchSnippingTool)
        screenToolMenu.addAction(snipButton)

        actionCaptureSection = QAction("Capture Section", self)
        actionCaptureSection.triggered.connect(self.ScreenToolcaptureScreenshot)
        screenToolMenu.addAction(actionCaptureSection)

        toggleNotificationsAction = QAction("Toggle Notifications", self)
        toggleNotificationsAction.setCheckable(True)
        toggleNotificationsAction.setChecked(False)
        toggleNotificationsAction.triggered.connect(self.ScreenTooltoggleNotifications)
        screenToolMenu.addAction(toggleNotificationsAction)

        recordScreenAction = QAction("Record Screen", self)
        recordScreenAction.triggered.connect(self.ScreenToolshowRecordingControl)
        screenToolMenu.addAction(recordScreenAction)

        createGIFAction = QAction("Create GIF", self)
        createGIFAction.triggered.connect(self.ScreenToolcreateGifFromScreenshots)
        screenToolMenu.addAction(createGIFAction)

        selectWindowAction = QAction("Select Window", self)
        selectWindowAction.triggered.connect(self.ScreenToolselectWindow)
        screenToolMenu.addAction(selectWindowAction)

        screenToolSettingsAction = QAction("Settings", self)
        screenToolSettingsAction.triggered.connect(self.ScreenToolshowSettings)
        screenToolMenu.addAction(screenToolSettingsAction)

        screenToolAboutAction = QAction("About", self)
        screenToolAboutAction.triggered.connect(self.ScreenToolshowAboutDialog)
        screenToolMenu.addAction(screenToolAboutAction)

        screenToolDonateAction = QAction("Donate", self)
        screenToolDonateAction.triggered.connect(lambda: webbrowser.open("https://www.tstp.xyz/donate"))
        screenToolMenu.addAction(screenToolDonateAction)

        # File Sorter submenu
        fileSorterMenu = fileMenu.addMenu("File Sorter")
        fileSorterSubMenu = self.fileSorterWindow.createTrayMenu()
        for action in fileSorterSubMenu.actions():
            fileSorterMenu.addAction(action)

        # Utility Tools submenu
        utilityMenu = fileMenu.addMenu("Utility Tools")

        duplicateRemoverAction = QAction("Duplicate Remover", self)
        duplicateRemoverAction.triggered.connect(self.showDuplicateRemoverWindow)
        utilityMenu.addAction(duplicateRemoverAction)

        userScannerAction = QAction("User Scanner", self)
        userScannerAction.triggered.connect(self.showUserScannerWindow)
        utilityMenu.addAction(userScannerAction)

        ftpManagerAction = QAction("FTP Manager", self)
        ftpManagerAction.triggered.connect(self.showFTPManager)
        utilityMenu.addAction(ftpManagerAction)

        parsingToolAction = QAction("Parsing Tool", self)
        parsingToolAction.triggered.connect(self.showParsingTool)
        utilityMenu.addAction(parsingToolAction)

        parseReverseAction = QAction("Parse Reverse", self)
        parseReverseAction.triggered.connect(self.showParseReverse)
        utilityMenu.addAction(parseReverseAction)

        autoContinueAction = QAction("Auto Continue", self)
        autoContinueAction.triggered.connect(self.showAutoContinue)
        utilityMenu.addAction(autoContinueAction)

        # Network Tools submenu
        networkToolsMenu = fileMenu.addMenu("Network Tools")

        networkPassToolAction = QAction("Network Password Tool", self)
        networkPassToolAction.triggered.connect(self.showNetworkPassTool)
        networkToolsMenu.addAction(networkPassToolAction)

        networkMonitorAction = QAction("Network Monitor", self)
        networkMonitorAction.triggered.connect(self.showNetworkMonitor)
        networkToolsMenu.addAction(networkMonitorAction)

        speedTestAction = QAction("Speed Test", self)
        speedTestAction.triggered.connect(self.showSpeedTest)
        networkToolsMenu.addAction(speedTestAction)

        apiTesterAction = QAction("API Tester", self)
        apiTesterAction.triggered.connect(self.showAPITest)
        networkToolsMenu.addAction(apiTesterAction)

        # Widgets submenu
        widgetsMenu = fileMenu.addMenu("Widgets")

        chatWidgetAction = QAction('AI Chat', self)
        chatWidgetAction.triggered.connect(self.showChatWidget)
        widgetsMenu.addAction(chatWidgetAction)

        terminalWidgetAction = QAction('Terminal', self)
        terminalWidgetAction.triggered.connect(self.showTerminalWidget)
        widgetsMenu.addAction(terminalWidgetAction)

        sshWidgetAction = QAction('SSH', self)
        sshWidgetAction.triggered.connect(self.showSSHWidget)
        widgetsMenu.addAction(sshWidgetAction)

        dbWidgetAction = QAction('DB Viewer', self)
        dbWidgetAction.triggered.connect(self.showDBWidget)
        widgetsMenu.addAction(dbWidgetAction)

        additionalNotesWidgetAction = QAction('Additional Notes', self)
        additionalNotesWidgetAction.triggered.connect(self.showAdditionalNotesWidget)
        widgetsMenu.addAction(additionalNotesWidgetAction)

        exitAction = QAction('Exit', self)
        exitAction.triggered.connect(self.forceClose)  # Connect to method to forcefully close the application
        fileMenu.addAction(exitAction)

        # Tools Menu
        toolsMenu = self.menuBar().addMenu('&Tools')
        reportAction = QAction('Reports (CTRL + R)', self)
        reportAction.triggered.connect(self.openReportWindow)
        toolsMenu.addAction(reportAction)

        toggleLeftAction = QAction('Toggle Productivity Widgets (ALT + 1)', self, checkable=True)
        toggleLeftAction.triggered.connect(self.toggleProductivity)
        toolsMenu.addAction(toggleLeftAction)

        toggleRightAction = QAction('Toggle Launcher Widget (ALT + 2)', self, checkable=True)
        toggleRightAction.triggered.connect(self.toggleLauncher)
        toolsMenu.addAction(toggleRightAction)

        toggleBottomAction = QAction('Toggle Special Features (ALT + 3)', self, checkable=True)
        toggleBottomAction.triggered.connect(self.toggleSpecialFeatures)
        toolsMenu.addAction(toggleBottomAction)

        notificationsAction = QAction('Notifications (CTRL+N)', self)
        notificationsAction.triggered.connect(self.openNotificationsManager)
        toolsMenu.addAction(notificationsAction)

        browserSelectorAction = QAction('Select Browser (ALT+B)', self)
        browserSelectorAction.triggered.connect(self.openBrowserSelector)
        toolsMenu.addAction(browserSelectorAction)

        schedulerAction = QAction('Task Scheduler (ALT+B)', self)
        schedulerAction.triggered.connect(self.open_scheduler_dialog)
        toolsMenu.addAction(schedulerAction)

        settingsAction = QAction('Settings (CTRL+P)', self)
        settingsAction.triggered.connect(self.openSettings)
        toolsMenu.addAction(settingsAction)

        self.scheduleAction = QAction("Schedule Manager", self)
        self.scheduleAction.triggered.connect(self.open_schedule_window)
        toolsMenu.addAction(self.scheduleAction)

        # Help Menu
        helpMenu = self.menuBar().addMenu('&Help')

        tutorialAction = QAction('Tutorial', self)
        tutorialAction.triggered.connect(self.open_main_tutorial)
        helpMenu.addAction(tutorialAction)

        aboutAction = QAction('About', self)
        aboutAction.triggered.connect(self.showAboutDialog)
        helpMenu.addAction(aboutAction)

        donateAction = QAction('Donate', self)
        donateAction.triggered.connect(self.openDonateLink)
        helpMenu.addAction(donateAction)

        # Themes Menu
        self.initThemeMenu()

        # Window Menu
        windowMenu = self.menuBar().addMenu('&Window')
        self.alwaysOnTopAction = QAction('Always on Top (CTRL + BACKSPACE)', self, checkable=True)
        self.alwaysOnTopAction.triggered.connect(self.toggleAlwaysOnTop)
        windowMenu.addAction(self.alwaysOnTopAction)

        #closeToTrayAction = QAction('Close to System Tray', self, checkable=True)
        #closeToTrayAction.triggered.connect(self.toggleCloseToTray)
        #windowMenu.addAction(closeToTrayAction)

        # Window Control Functions
        self.fillerAction = QAction(' ' * 90, self)  # Action for dragging
        self.menuBar().addAction(self.fillerAction)
        self.minimizeAction = QAction('  -  ', self)
        self.minimizeAction.triggered.connect(self.showMinimized)
        self.menuBar().addAction(self.minimizeAction)

        self.closeAction = QAction('  X  ', self)
        self.closeAction.triggered.connect(self.close)
        self.menuBar().addAction(self.closeAction)

        # Adding a spacer and right-aligned actions for Minimize and Close
        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.menuBar().setCornerWidget(spacer, Qt.TopRightCorner)  # Push actions to the right

    def openNotificationsManager(self):
        if not hasattr(self, 'notificationManager') or self.notificationManager is None:
            self.notificationManager = NotificationManager()
        self.notificationManager.open_notification_settings_dialog(self)

    def adjustLayout(self):
        width = self.original_geometry[2]  # Base width from your predefined geometry
        height = self.original_geometry[3]  # Base height from your predefined geometry
        additional_notes_width = 500 if self.productivityWidget.isVisible() else 0
        launcher_width = 500 if self.launcherWidget.isVisible() else 0

        width += additional_notes_width + launcher_width
        height += 500 if self.specialFeaturesWidget.isVisible() else 0

        self.resize(width, height)
        self.adjustWidgetPositions()
        self.updateFillerAction()
        
    def adjustWidgetPositions(self):
        total_width = self.width()
        total_height = self.height()
        top_margin = 30  # Ensure consistent top margin for alignment

        # Adjust additional notes widget position and size
        if self.productivityWidget.isVisible():
            self.productivityWidget.setGeometry(0, top_margin, 500, total_height - top_margin)

        # Adjust launcher widget position and size
        if self.launcherWidget.isVisible():
            self.launcherWidget.setGeometry(total_width - 500, top_margin, 500, total_height - top_margin)

        # Adjust special features widget position and size
        special_features_width = total_width - (500 if self.productivityWidget.isVisible() else 0) - (500 if self.launcherWidget.isVisible() else 0)
        special_features_top = total_height - 500  # Positioned at the bottom of the screen
        self.specialFeaturesWidget.setGeometry(500 if self.productivityWidget.isVisible() else 0, special_features_top, special_features_width, 500)

        # Adjust other controls dynamically based on visibility and sizes of the side widgets
        offset = 500 if self.productivityWidget.isVisible() else 0
        control_area_width = special_features_width  # Controls should align with the width of the special features widget

        # Row 1
        self.noteTypeDropdown.setGeometry(offset + 10, 40, 200, 30)
        self.categoryDropdown.setGeometry(offset + 220, 40, 170, 30)
        self.timestampButton.setGeometry(offset + 400, 40, 80, 30)
        self.refreshButton.setGeometry(offset + 490, 40, 50, 30)
        self.clearButton.setGeometry(offset + 550, 40, 40, 30)
    
        # Row 2
        self.notesDropdown.setGeometry(offset + 10, 80, 200, 30)
        self.addButton.setGeometry(offset + 220, 80, 50, 30)
        self.saveButton.setGeometry(offset + 280, 80, 50, 30)
        self.tagsEdit.setGeometry(offset + 340, 80, 130, 30)
        self.notebooksDropdown.setGeometry(offset + 480, 80, 110, 30)
    
        # Row 3
        self.searchBar.setGeometry(offset + 10, 120, 200, 30)
        self.toggleButton.setGeometry(offset + 220, 120, 50, 30)
        self.fontBox.setGeometry(offset + 280, 120, 160, 30)
        self.fontSizeBox.setGeometry(offset + 450, 120, 60, 30)
        self.boldButton.setGeometry(offset + 520, 120, 30, 30)
        self.italicButton.setGeometry(offset + 560, 120, 30, 30)
    
        # Row 4
        self.textArea.setGeometry(offset + 10, 160, control_area_width - 20, 290)  # Adjusted width to fill the space
    
        # Row 5
        self.passwordLengthDropdown.setGeometry(offset + 10, 460, 40, 30)
        self.passwordTextEdit.setGeometry(offset + 60, 460, 150, 30)
        self.generatePasswordButton.setGeometry(offset + 220, 460, 110, 30)
        self.generatePasswordLinkButton.setGeometry(offset + 340, 460, 110, 30)
        self.futureOneButton.setGeometry(offset + 460, 460, 60, 30)
        self.futureTwoButton.setGeometry(offset + 530, 460, 60, 30)
    
        # Row 6
        self.additionalNotesButton.setGeometry(offset + 10, 450, 160, 30)
        self.specialFeaturesButton.setGeometry(offset + 180, 450, 160, 30)
        self.launcherButton.setGeometry(offset + 430, 450, 160, 30)

    def toggleProductivity(self, state):
        self.productivityWidget.setVisible(state)
        self.adjustLayout()
        self.updateFillerAction()
        if self.debug_mode:
            self.productivityWidget.setStyleSheet("background-color: orange;")
        else:
            self.productivityWidget.setStyleSheet("")
        self.settings.setValue("productivityWidgetVisible", state)  # Save state

    def toggleSpecialFeatures(self, state):
        self.specialFeaturesWidget.setVisible(state)
        self.adjustLayout()
        if self.debug_mode:
            self.specialFeaturesWidget.setStyleSheet("background-color: lightgreen;")
        else:
            self.specialFeaturesWidget.setStyleSheet("")
        self.settings.setValue("specialFeaturesWidgetVisible", state)  # Save state

    def toggleLauncher(self, state):
        self.launcherWidget.setVisible(state)
        self.adjustLayout()
        self.updateFillerAction()
        if self.debug_mode:
            self.launcherWidget.setStyleSheet("background-color: lightblue;")
        else:
            self.launcherWidget.setStyleSheet("")
        self.settings.setValue("launcherWidgetVisible", state)  # Save state

    def saveWidgetStates(self):
        self.settings.setValue("productivityWidgetVisible", self.productivityWidget.isVisible())
        self.settings.setValue("specialFeaturesWidgetVisible", self.specialFeaturesWidget.isVisible())
        self.settings.setValue("launcherWidgetVisible", self.launcherWidget.isVisible())

    def loadWidgetStates(self):
        productivity_visible = self.settings.value("productivityWidgetVisible", True, type=bool)
        special_features_visible = self.settings.value("specialFeaturesWidgetVisible", True, type=bool)
        launcher_visible = self.settings.value("launcherWidgetVisible", True, type=bool)

        self.productivityWidget.setVisible(productivity_visible)
        self.specialFeaturesWidget.setVisible(special_features_visible)
        self.launcherWidget.setVisible(launcher_visible)
        self.adjustLayout()  # Adjust layout based on loaded states

    def saveWindowSettings(self):
        self.settings.setValue("windowGeometry", self.saveGeometry())
        self.settings.setValue("windowState", self.saveState())
        self.settings.setValue("windowPosition", self.pos())
        self.settings.setValue("windowScreen", self.screen().name())

    def loadWindowSettings(self):
        if self.settings.contains("windowGeometry"):
            self.restoreGeometry(self.settings.value("windowGeometry"))
        if self.settings.contains("windowState"):
            self.restoreState(self.settings.value("windowState"))
        if self.settings.contains("windowPosition"):
            self.move(self.settings.value("windowPosition", type=QPoint))
        if self.settings.contains("windowScreen"):
            screen_name = self.settings.value("windowScreen")
            for screen in QApplication.screens():
                if screen.name() == screen_name:
                    self.windowHandle().setScreen(screen)
                    break
            
    def updateFillerAction(self):
        # Define a base number of spaces for alignment
        base_spaces = 88

        # Define individual space increments for each widget
        additional_spaces_notes = 165  # Adjust for productivityWidget
        additional_spaces_launcher = 165  # Adjust for launcherWidget
        additional_spaces_special = 0  # Adjust for specialFeaturesWidget

        # Calculate total additional spaces based on widget visibility
        total_additional_spaces = 0
        if self.productivityWidget.isVisible():
            total_additional_spaces += additional_spaces_notes
        if self.launcherWidget.isVisible():
            total_additional_spaces += additional_spaces_launcher
        if self.specialFeaturesWidget.isVisible():
            total_additional_spaces += additional_spaces_special

        # Calculate total spaces
        total_spaces = base_spaces + total_additional_spaces
    
        # Update the filler action text
        self.fillerAction.setText(' ' * total_spaces)

    def repositionWidgets(self):
        # Adjust the position of the launcher widget depending on the visibility of the additional notes
        if self.productivityWidget.isVisible():
            self.launcherWidget.setGeometry(self.width() - 400, 30, 400, 450)
        else:
            self.launcherWidget.setGeometry(self.width(), 30, 400, 450)

        # Position the special features widget based on the visibility of other widgets
        if self.productivityWidget.isVisible() and self.launcherWidget.isVisible():
            self.specialFeaturesWidget.setGeometry(400, 30, self.width() - 800, 300)
        elif self.productivityWidget.isVisible() or self.launcherWidget.isVisible():
            self.specialFeaturesWidget.setGeometry(400, 30, self.width() - 400, 300)
        else:
            self.specialFeaturesWidget.setGeometry(0, 30, self.width(), 300)

    def adjustWindowSize(self):
        # Expand or contract the main window based on the visible widgets
        width_change = 500 if self.launcherWidget.isVisible() else 0
        height_change = 300 if self.specialFeaturesWidget.isVisible() else 0
        self.resize(self.original_geometry[2] + width_change, self.original_geometry[3] + height_change)

    def adjustElementPositions(self, delta_x, delta_y):
        elements = [
            self.noteTypeDropdown, self.categoryDropdown, self.notesDropdown, self.toggleButton,
            self.clearButton, self.refreshButton, self.searchBar, self.textArea, self.fontBox,
            self.fontSizeBox, self.boldButton, self.italicButton, self.tagsEdit, self.notebooksDropdown,
            self.addButton, self.saveButton, self.generatePasswordButton, self.generatePasswordLinkButton,
            self.passwordTextEdit, self.passwordLengthDropdown, self.timestampButton,
            self.launcherWidget, self.specialFeaturesWidget, self.additionalNotesButton,
            self.specialFeaturesButton, self.launcherButton
        ]

        for element in elements:
            geo = element.geometry()
            element.setGeometry(geo.x() + delta_x, geo.y() + delta_y, geo.width(), geo.height())

    def refreshUI(self):
        # Refresh method that forces update on UI elements
        for widget in self.findChildren(QWidget):
            widget.style().unpolish(widget)
            widget.style().polish(widget)
            widget.update()

        # If you have other specific complex widgets, you can call their specific update or repaint methods
        if hasattr(self, 'customWidget'):
            self.customWidget.update()  # Example for custom widgets

        # Redraw any other specific elements that need explicit updating
        if hasattr(self, 'tableWidget'):
            self.tableWidget.viewport().update()

    def refreshUIForWindow(self, window):
        # Refresh method that forces update on UI elements for the given window
        for widget in window.findChildren(QWidget):
            widget.style().unpolish(widget)
            widget.style().polish(widget)
            widget.update()

        # If you have other specific complex widgets, you can call their specific update or repaint methods
        if hasattr(window, 'customWidget'):
            window.customWidget.update()  # Example for custom widgets

        # Redraw any other specific elements that need explicit updating
        if hasattr(window, 'tableWidget'):
            window.tableWidget.viewport().update()
        
    def createThemeMenu(self):
        themeMenu = QMenu('&Themes', self)
        theme_groups = {}

        # Dynamically categorize themes based on the prefix in the theme name
        for theme_name in self.themes.keys():
            parts = theme_name.split(" - ", 1)
            if len(parts) == 2:
                group_name, specific_theme_name = parts
                if group_name not in theme_groups:
                    theme_groups[group_name] = []
                theme_groups[group_name].append(theme_name)
            else:
                # Themes without a hyphenated prefix can go into a 'General' category
                if 'General' not in theme_groups:
                    theme_groups['General'] = []
                theme_groups['General'].append(theme_name)

        # Create submenus for each group and add corresponding themes
        for group_name, themes in theme_groups.items():
            group_menu = themeMenu.addMenu(group_name)
            for theme_name in themes:
                theme_action = QAction(theme_name, self)
                theme_action.triggered.connect(lambda _, name=theme_name: self.applyTheme(name))
                group_menu.addAction(theme_action)

        return themeMenu

    def initThemeMenu(self):
        themeMenu = self.menuBar().addMenu('&Themes')
        theme_groups = {}

        # Dynamically categorize themes based on the prefix in the theme name
        for theme_name in self.themes.keys():
            parts = theme_name.split(" - ", 1)
            if len(parts) == 2:
                group_name, specific_theme_name = parts
                if group_name not in theme_groups:
                    theme_groups[group_name] = []
                theme_groups[group_name].append(theme_name)
            else:
                # Themes without a hyphenated prefix can go into a 'General' category
                if 'General' not in theme_groups:
                    theme_groups['General'] = []
                theme_groups['General'].append(theme_name)

        # Create submenus for each group and add corresponding themes
        for group_name, themes in theme_groups.items():
            group_menu = themeMenu.addMenu(group_name)
            for theme_name in themes:
                theme_action = QAction(theme_name, self)
                theme_action.triggered.connect(lambda _, name=theme_name: self.applyTheme(name))
                group_menu.addAction(theme_action)

    def openDonateLink(self):
        import webbrowser
        webbrowser.open("https://www.tstp.xyz/donate")

    def closeEvent(self, event):
        try:
            self.saveWindowSettings()  # Save the window settings
            self.saveWidgetStates()  # Save the state of the widgets
            self.saveActionStates()  # Save the state of actions
            if hasattr(self, 'closeToTray') and self.closeToTray:
                event.ignore()
                self.hide()
                self.trayIcon.showMessage(
                    'TSTP:Omni Omega',
                    'Application was minimized to tray.',
                    QSystemTrayIcon.Information,
                    2000
                )
            else:
                self.forceClose()
        except Exception as e:
            logging.error(f"Error during close event: {e}")
            self.forceClose()

    def onTrayIconActivated(self, reason):
        try:
            if reason == QSystemTrayIcon.Trigger:
                if self.isMinimized() or not self.isVisible():
                    self.showNormal()
                    self.activateWindow()  # Bring the window to the front
                else:
                    self.showMinimized()
                    self.hide()  # Hide the window
        except Exception as e:
            logging.error(f"Error handling tray icon activation: {e}")

    def changeEvent(self, event):
        try:
            if event.type() == QEvent.WindowStateChange:
                if self.windowState() & Qt.WindowMinimized:
                    # When the window is minimized, hide it
                    event.ignore()
                    self.hide()
                elif event.oldState() & Qt.WindowMinimized:
                    # When the window is restored from a minimized state, show it normally
                    event.ignore()
                    self.showNormal()
                    self.activateWindow()
            super(DuplicateRemoverMainWindow, self).changeEvent(event)
        except Exception as e:
            logging.error(f"Error during window state change: {e}")

    def handleApplicationStateChange(self, state):
        try:
            if state == Qt.ApplicationActive:
                if self.isVisible() and not self.isMinimized():
                    self.wasMinimized = False
                    self.showMinimized()
                elif self.wasMinimized:
                    self.showNormal()
                    self.activateWindow()
            elif state == Qt.ApplicationInactive:
                if self.isMinimized():
                    self.wasMinimized = True
        except Exception as e:
            logging.error(f"Error handling application state change: {e}")
            
    def forceClose(self):
        self.trayIcon.hide()
        QApplication.quit()

    def checkDatabase(self):
        cursor = self.dbConnection.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS settings (
                id INTEGER PRIMARY KEY,
                note_folder TEXT,
                default_note_folder TEXT,
                save_behavior TEXT DEFAULT 'File',
                auto_save_note_folder TEXT,
                timestamp_filenames BOOLEAN DEFAULT 0
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS file_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT,
                time TEXT,
                filename TEXT,
                content TEXT,
                note_folder_used TEXT
            )
        ''')
        self.dbConnection.commit()
        cursor.execute('SELECT * FROM settings WHERE id = 1')
        if not cursor.fetchone():
            default_notes_directory = './default_notes/'
            notes_directory = './notes/'
            auto_save_note_folder = './autosaves/'
            save_behavior = 'File'
            timestamp_filenames = False
            cursor.execute('INSERT INTO settings (id, note_folder, default_note_folder, auto_save_note_folder, save_behavior, timestamp_filenames) VALUES (1, ?, ?, ?, ?, ?)',
                           (notes_directory, default_notes_directory, auto_save_note_folder, save_behavior, timestamp_filenames))
            self.dbConnection.commit()

    def loadSettings(self):
        cursor = self.dbConnection.cursor()
        cursor.execute('SELECT note_folder, default_note_folder, auto_save_note_folder FROM settings WHERE id = 1')
        data = cursor.fetchone()
        if data:
            self.notesDirectory = data[0] or './notes/'
            self.defaultNotesDirectory = data[1] or './default_notes/'
            self.autoSaveNoteFolder = data[2] or './autosaves/'
        else:
            self.notesDirectory = './notes/'
            self.defaultNotesDirectory = './default_notes/'
            self.autoSaveNoteFolder = './autosaves/'
        self.checkFolders()
        if debug_mode or self.debug_mode:
            QMessageBox.information(self,"",self.notesDirectory + "\n\n" + self.defaultNotesDirectory + "\n\n" + self.autoSaveNoteFolder)
    
    def checkFolders(self):
        os.makedirs(self.notesDirectory, exist_ok=True)
        os.makedirs(self.defaultNotesDirectory, exist_ok=True)
        os.makedirs(self.autoSaveNoteFolder, exist_ok=True)
        
    def createDropdowns(self):
        self.noteTypeDropdown = QComboBox(self)
        self.noteTypeDropdown.setGeometry(50, 30, 200, 30)
        self.noteTypeDropdown.addItem("")
        self.noteTypeDropdown.addItem("Simple Notes")
        self.noteTypeDropdown.addItem("Default Notes")
        self.noteTypeDropdown.addItem("Specific Notes")
        self.noteTypeDropdown.addItem("Default Client Notes")
        self.noteTypeDropdown.addItem("Placeholder 2")
        self.noteTypeDropdown.currentIndexChanged.connect(self.updateNotesType)
        self.noteTypeDropdown.setMaxVisibleItems(70) 

        self.categoryDropdown = QComboBox(self)
        self.categoryDropdown.setGeometry(260, 30, 200, 30)
        self.categoryDropdown.hide()
        self.categoryDropdown.setMaxVisibleItems(70)

        self.notesDropdown = EnterComboBox(self)  # Use EnterComboBox instead of QComboBox
        self.notesDropdown.setGeometry(50, 70, 200, 30)
        self.notesDropdown.currentIndexChanged.connect(self.loadSelectedNote)
        self.notesDropdown.setMaxVisibleItems(70)

    def createTextArea(self):
        self.textArea = CustomTextEdit(self)
        self.textArea.setGeometry(50, 150, 500, 200)
        
    def onToggle(self, checked):
        self.toggleMode = checked  # Update the toggleMode variable
        if checked:
            if debug_mode or self.debug_mode:
                QMessageBox.information(self,"DEBUG","toggleMode ON - ")
            self.toggleButton.setStyleSheet("QPushButton { background-color: green; }")
        else:
            if debug_mode:
                QMessageBox.information(self,"DEBUG","toggleMode OFF")
            self.toggleButton.setStyleSheet("QPushButton { background-color: yellow; color: black;}")

    def debugToggle(self, checked):
        self.debug_mode = checked  # Update the toggleMode variable
        if checked:
            QMessageBox.information(self,"DEBUG","debugMode ON - ")
        else:
            QMessageBox.information(self,"DEBUG","debugMode OFF")

    def createButtons(self):
        self.toggleButton = QPushButton('+ Mode', self)
        self.toggleButton.setCheckable(True)  # Make the button checkable
        self.toggleButton.setGeometry(260, 70, 50, 30)
        self.toggleButton.setStyleSheet("QPushButton { background-color: gray; }")  # Initial color

        # Connect the toggled signal to the slot
        self.toggleButton.toggled.connect(self.onToggle)

        self.addButton = QPushButton('+ Note', self)
        self.addButton.setGeometry(320, 70, 70, 30)
        self.addButton.clicked.connect(lambda: self.addNoteToTextArea(from_button=True))
        
        self.saveButton = QPushButton('Save', self)
        self.saveButton.setGeometry(400, 70, 70, 30)
        self.saveButton.clicked.connect(self.saveNote)
        
        self.clearButton = QPushButton('Clear', self)
        self.clearButton.setGeometry(480, 70, 70, 30)
        self.clearButton.clicked.connect(self.textArea.clear)

        self.refreshButton = QPushButton('Refresh', self)
        self.refreshButton.setGeometry(480, 30, 70, 30)
        self.refreshButton.clicked.connect(self.refreshNotes)

        self.additionalNotesButton = QPushButton("Toggle Additional Notes", self)
        self.additionalNotesButton.setCheckable(True)
        self.additionalNotesButton.setGeometry(50, 440, 160, 32)
        self.additionalNotesButton.toggled.connect(self.toggleProductivity)
        self.additionalNotesButton.hide()

        self.specialFeaturesButton = QPushButton("Toggle Special Features", self)
        self.specialFeaturesButton.setCheckable(True)
        self.specialFeaturesButton.setGeometry(220, 440, 160, 32)
        self.specialFeaturesButton.toggled.connect(self.toggleSpecialFeatures)
        self.specialFeaturesButton.hide()

        self.launcherButton = QPushButton("Toggle Launcher", self)
        self.launcherButton.setCheckable(True)
        self.launcherButton.setGeometry(390, 440, 160, 32)
        self.launcherButton.toggled.connect(self.toggleLauncher)
        self.launcherButton.hide()

    def refreshNotes(self):
        self.updateNotesType()
        
    def createSearchBar(self):
        self.searchBar = EnterLineEdit(self)
        self.searchBar.setGeometry(50, 110, 200, 30)
        self.searchBar.setPlaceholderText("Search...")
        self.searchBar.textChanged.connect(self.searchNotes)

    def createFormattingOptions(self):
        self.fontBox = QFontComboBox(self)
        self.fontBox.setGeometry(260, 110, 140, 30)
        self.fontBox.currentFontChanged.connect(self.changeTextFont)

        self.fontSizeBox = QSpinBox(self)
        self.fontSizeBox.setGeometry(410, 110, 60, 30)
        self.fontSizeBox.setValue(12)
        self.fontSizeBox.valueChanged.connect(self.changeTextSize)

        self.boldButton = QPushButton('B', self)
        self.boldButton.setGeometry(480, 110, 30, 30)
        self.boldButton.clicked.connect(self.toggleBold)

        self.italicButton = QPushButton('I', self)
        self.italicButton.setGeometry(520, 110, 30, 30)
        self.italicButton.clicked.connect(self.toggleItalic)

    def createTagsOption(self):
        self.tagsEdit = QLineEdit(self)
        self.tagsEdit.setGeometry(50, 360, 200, 30)  # Adjust geometry as needed
        self.tagsEdit.setPlaceholderText("Tags (comma-separated)")

    def createNotebooksDropdown(self):
        self.notebooksDropdown = QComboBox(self)
        self.notebooksDropdown.setGeometry(260, 360, 200, 30)
        self.notebooksDropdown.addItem("Default Notebook")
        self.notebooksDropdown.currentIndexChanged.connect(self.changeNotebook)
        
    def createTimestampButton(self):
        self.timestampButton = QPushButton('Timestamp', self)
        self.timestampButton.setGeometry(470, 360, 80, 32)
        self.timestampButton.clicked.connect(self.addTimestamp)
        pass
    
    def addTimestamp(self):
        timezone = pytz.timezone("America/Los_Angeles")  # Replace with your timezone
        if not self.timer_running:
            # Start the timer
            self.start_time = datetime.now(timezone)
            time_string = self.format_datetime(self.start_time)
            current_text = self.textArea.toPlainText()
            self.textArea.setPlainText(f"Start: {time_string}\n\n{current_text}")
            self.timer_running = True
        else:
            # Stop the timer
            end_time = datetime.now(timezone)
            time_string = self.format_datetime(end_time)
            current_text = self.textArea.toPlainText()
            self.textArea.setPlainText(f"{current_text}\n\nEnd: {time_string}")
            self.timer_running = False
            self.start_time = None
            
    def format_datetime(self, dt):
        # Function to add the correct suffix to day of the month
        def day_suffix(day):
            if 4 <= day <= 20 or 24 <= day <= 30:
                return "th"
            else:
                return ["st", "nd", "rd"][day % 10 - 1]

        # Format the datetime object to the specified format with the correct suffix for the day
        formatted_date = dt.strftime(f"(%A, %B {dt.day}{day_suffix(dt.day)}, %Y) - (%I:%M %p %Z)")
        return formatted_date
    
    def createPasswordSection(self):
        self.passwordLengthDropdown = QComboBox(self)
        self.passwordLengthDropdown.addItems([str(x) for x in range(8, 30)])
        self.passwordLengthDropdown.setCurrentIndex(0)  # Default to 12 characters

        self.passwordTextEdit = QLineEdit(self)
        self.passwordTextEdit.setPlaceholderText('Password will be displayed here')
        self.passwordTextEdit.setReadOnly(False)

        self.generatePasswordButton = QPushButton('Generate Password', self)
        self.generatePasswordButton.clicked.connect(self.generatePassword)

        self.generatePasswordLinkButton = QPushButton('Password Link', self)
        self.generatePasswordLinkButton.clicked.connect(self.generatePasswordLink)

        self.futureOneButton = QPushButton('F1', self)
        self.futureOneButton.clicked.connect(self.futureOneAction)

        self.futureTwoButton = QPushButton('F2', self)
        self.futureTwoButton.clicked.connect(self.futureTwoAction)

    def futureOneAction(self):
        QMessageBox.information(self,"Disabled","Feature is currently disabled.  Check again later.\n\n\nThe Solutions To Problems Development Team")
        print("Future One Action Triggered")

    def futureTwoAction(self):
        QMessageBox.information(self,"Disabled","Feature is currently disabled.  Check again later.\n\n\nThe Solutions To Problems Development Team")
        print("Future Two Action Triggered")

    def generatePassword(self):
        # Generate a random password and display it in the passwordTextEdit
        import string
        import random
        password_length = int(self.passwordLengthDropdown.currentText())
        password_chars = string.ascii_letters + string.digits + "@#$%&=?"
        password = ''.join(random.choices(password_chars, k=password_length))

        # Ensure the password contains at least 1 upper, 1 lower, 1 number, 1 special character
        while (not any(char.isupper() for char in password)
              or not any(char.islower() for char in password)
              or not any(char.isdigit() for char in password)
              or not any(char in "@#$%&=?" for char in password)):
            password = ''.join(random.choices(password_chars, k=password_length))

        self.passwordTextEdit.setText(password)

    def generatePasswordLink(self):
        password = self.passwordTextEdit.text()
    
        # If the passwordTextEdit is empty, generate a new password
        if not password:
            self.generatePassword()
            password = self.passwordTextEdit.text()

        # Check if the password length is within the acceptable range
        if not 1 <= len(password) <= 30:
            QMessageBox.critical(self, 'Error', 'Password length must be between 1 and 1,048,576 characters.')
            return

        # Check for the additional information tags in the text area
        text_content = self.textArea.toPlainText()
        tags_found = self.find_tags(text_content)

        if tags_found:
            # Create a new window to handle the additional information
            self.additional_info_window = AdditionalInfoWindow(tags_found, password, self)
            self.additional_info_window.show()
        else:
            # Check if the text area already contains a password and link
            existing_password_link = "Password:" in text_content and "Password Link:" in text_content
            if existing_password_link:
                reply = QMessageBox.question(self, 'Overwrite Confirmation', 
                                             'There is already a password and link in the text area. Do you want to overwrite it?', 
                                             QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                if reply == QMessageBox.No:
                    return

            # Use PWPush to obtain a password link
            url = 'https://pwpush.com/p.json'
            data = {
                'password': {
                    'payload': password,
                    'expire_after_days': 30,
                    'expire_after_views': 11,
                    'note': 'Reference Note. Encrypted & Visible Only to You.',
                    'retrieval_step': True,
                    'deletable_by_viewer': True
                }
            }

            try:
                response = requests.post(url, json=data)
                response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code

                # Get the 'url_token' from the response, if available
                password_link_token = response.json().get('url_token')
                if password_link_token:
                    password_link = f"https://pwpush.com/p/{password_link_token}"

                    # Prompt if tags found and confirmation for overwriting
                    if tags_found:
                        reply = QMessageBox.question(self, 'Overwrite Confirmation', 
                                                     'Tags found in the text area. Do you want to overwrite the password and link?', 
                                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                        if reply == QMessageBox.No:
                            return
                
                    # Update the text in the text edit, preserving other content
                    new_text_content = text_content
                    if existing_password_link:
                        import re
                        new_text_content = re.sub(r'Password:.*\nPassword Link:.*', f'Password: {password}\nPassword Link: {password_link}', new_text_content)
                    else:
                        new_text_content += f"\nPassword: {password}\nPassword Link: {password_link}"
                
                    self.textArea.setPlainText(new_text_content)
                else:
                    QMessageBox.critical(self, 'Error', 'Failed to obtain the password link from the response.')
            except requests.exceptions.HTTPError as http_err:
                QMessageBox.critical(self, 'Error', f'HTTP error occurred: {http_err}')
            except Exception as err:
                QMessageBox.critical(self, 'Error', f'An error occurred: {err}')

    def updateTextInTextEdit(self, new_password, new_link, user_info=None, checkbox_states=None):
        text_content = self.textArea.toPlainText()

        # Initialize flags for found lines
        password_line_found = False
        link_line_found = False
        first_name_found = False
        middle_name_found = False
        last_name_found = False
        user_found = False
        username_found = False
        email_found = False

        # Initialize a dictionary for new values
        new_values = {
            'First Name: ': user_info.get("first_name", "") if user_info and checkbox_states and checkbox_states['first_name_checked'] else None,
            'Middle Name: ': user_info.get("middle_name", "") if user_info and checkbox_states and checkbox_states['middle_name_checked'] else None,
            'Last Name: ': user_info.get("last_name", "") if user_info and checkbox_states and checkbox_states['last_name_checked'] else None,
            'User: ': " ".join([name for name in [user_info.get("first_name", ""), user_info.get("middle_name", ""), user_info.get("last_name", "")] if name]) if user_info and checkbox_states and checkbox_states['full_name_checked'] else None,
            'Username: ': user_info.get("username", "") if user_info and checkbox_states and checkbox_states['username_checked'] else None,
            'E-Mail: ': user_info.get("email", "") if user_info and checkbox_states and checkbox_states['email_checked'] else None,
            'Password: ': new_password if checkbox_states and checkbox_states['password_checked'] else None,
            'Password Link: ': new_link if checkbox_states and checkbox_states['password_link_checked'] else None
        }

        # Split the text content into lines
        lines = text_content.split('\n')
        updated_lines = []

        # Process each line and update placeholders if necessary
        for line in lines:
            replaced = False
            for key, value in new_values.items():
                if key in line and '#TEXT#' in line:
                    if value is not None:
                        updated_lines.append(f'{key} {value}')
                    else:
                        updated_lines.append(line)
                    replaced = True
                    # Mark the corresponding line as found
                    if key == 'First Name: ':
                        first_name_found = True
                    elif key == 'Middle Name: ':
                        middle_name_found = True
                    elif key == 'Last Name: ':
                        last_name_found = True
                    elif key == 'User: ':
                        user_found = True
                    elif key == 'Username: ':
                        username_found = True
                    elif key == 'E-Mail: ':
                        email_found = True
                    elif key == 'Password: ':
                        password_line_found = True
                    elif key == 'Password Link: ':
                        link_line_found = True
                    break
            if not replaced:
                updated_lines.append(line)

        # Append any missing placeholders at the correct positions
        missing_placeholders = []
        if checkbox_states:
            if not first_name_found and checkbox_states['first_name_checked']:
                missing_placeholders.append(f'First Name: {user_info.get("first_name", "")}')
            if not middle_name_found and checkbox_states['middle_name_checked']:
                missing_placeholders.append(f'Middle Name: {user_info.get("middle_name", "")}')
            if not last_name_found and checkbox_states['last_name_checked']:
                missing_placeholders.append(f'Last Name: {user_info.get("last_name", "")}')
            if not user_found and checkbox_states['full_name_checked']:
                full_name = " ".join([name for name in [user_info.get("first_name", ""), user_info.get("middle_name", ""), user_info.get("last_name", "")] if name])
                missing_placeholders.append(f'User: {full_name}')
            if not username_found and checkbox_states['username_checked']:
                missing_placeholders.append(f'Username: {user_info.get("username", "")}')
            if not email_found and checkbox_states['email_checked']:
                missing_placeholders.append(f'E-Mail: {user_info.get("email", "")}')
            if not password_line_found and checkbox_states['password_checked']:
                missing_placeholders.append(f'Password: {new_password}')
            if not link_line_found and checkbox_states['password_link_checked']:
                missing_placeholders.append(f'Password Link: {new_link}')

        # Ensure placeholders are in the correct order
        final_lines = []
        for line in updated_lines:
            if any(key in line for key in new_values.keys()):
                final_lines.append(line)
        final_lines.extend(missing_placeholders)
        final_lines = [line for line in updated_lines if not any(key in line for key in new_values.keys())]
        final_lines.extend(missing_placeholders)

        # Combine all parts together without extra new lines at the top
        final_content = "\n".join(final_lines)

        # Set the updated text content
        self.textArea.setPlainText(final_content)
                
    def find_tags(self, text):
        tags = {
            'user': '#TEXT#',
            'username': '#TEXT#',
            'password': '#TEXT#',
            'password_link': '#TEXT#',
            'email': '#TEXT#'
        }
        found_tags = {}
        for tag, pattern in tags.items():
            if pattern in text:
                found_tags[tag] = pattern
        return found_tags

    def createKeyboardShortcuts(self):
        alwaysOnTopShortcut = QShortcut(QKeySequence("CTRL+BACKSPACE"), self)
        alwaysOnTopShortcut.activated.connect(self.toggleAlwaysOnTop)

        saveShortcut = QShortcut(QKeySequence("CTRL+S"), self)
        saveShortcut.activated.connect(self.saveNote)

        reportShortcut = QShortcut(QKeySequence("CTRL+R"), self)
        reportShortcut.activated.connect(self.openReportWindow)

        newNoteShortcut = QShortcut(QKeySequence("Ctrl+N"), self)
        newNoteShortcut.activated.connect(self.newNote)

        settingsShortcut = QShortcut(QKeySequence("Ctrl+P"), self)
        settingsShortcut.activated.connect(self.openSettings)

        undoShortcut = QShortcut(QKeySequence("Ctrl+Z"), self)
        undoShortcut.activated.connect(self.textArea.undo)

        redoShortcut = QShortcut(QKeySequence("Ctrl+Y"), self)
        redoShortcut.activated.connect(self.textArea.redo)
        
        minimizeShortcut = QShortcut(QKeySequence("CTRL+/"), self)
        minimizeShortcut.activated.connect(self.showMinimized)

        notificationsManagerShortcut = QShortcut(QKeySequence("CTRL+N"), self)
        notificationsManagerShortcut.activated.connect(self.openNotificationsManager)
        
        # Theme Controls
        self.next_theme_shortcut = QShortcut(QKeySequence("Ctrl+="), self)
        self.next_theme_shortcut.activated.connect(self.nextTheme)

        self.prev_theme_shortcut = QShortcut(QKeySequence("Ctrl+-"), self)
        self.prev_theme_shortcut.activated.connect(self.prevTheme)

        # Widgets:
        self.additionalNotesShortcut = QShortcut(QKeySequence("ALT+1"), self)
        self.additionalNotesShortcut.activated.connect(lambda: self.toggleProductivity(not self.productivityWidget.isVisible()))

        self.launcherShortcut = QShortcut(QKeySequence("ALT+2"), self)
        self.launcherShortcut.activated.connect(lambda: self.toggleLauncher(not self.launcherWidget.isVisible()))

        self.specialFeaturesShortcut = QShortcut(QKeySequence("ALT+3"), self)
        self.specialFeaturesShortcut.activated.connect(lambda: self.toggleSpecialFeatures(not self.specialFeaturesWidget.isVisible()))

    def nextTheme(self):
        # Increment the theme index, wrap around if at the end
        self.current_theme_index = (self.current_theme_index + 1) % len(self.themes)
        self.applyTheme()

    def prevTheme(self):
        # Decrement the theme index, wrap around if at the start
        self.current_theme_index = (self.current_theme_index - 1) % len(self.themes)
        self.applyTheme()

    def openReportWindow(self):
        if not hasattr(self, 'reportWindow') or self.reportWindow is None:
            self.reportWindow = ReportWindow(self, 'omni_omega.db', self.themes[self.current_theme])
        self.reportWindow.show()
        
    def checkAddText(self, state):
        if state == Qt.Checked:
            selected_note = self.notesDropdown.currentText()
            if '#TEXT#' in selected_note:
                text, ok = QInputDialog.getText(self, 'Input Text', 'Enter your text:')
                if ok:
                    self.textArea.append(text)

    def updateNotesType(self):
        note_type = self.noteTypeDropdown.currentText()
        if note_type == "Simple Notes":
            self.loadSimpleNoteCategories()
            self.categoryDropdown.show()
        else:
            self.categoryDropdown.hide()
        self.updateNotesDropdown()
            
    def loadSimpleNoteCategories(self):
        self.categoryDropdown.clear()
        file_path = self.notesDirectory + "\\simple_notes.txt"
        self.simple_notes_data = {}  # Dictionary to store categories and their notes

        if os.path.exists(file_path):
            try:
                with open(file_path, 'r', encoding='utf-8') as file:
                    content = file.read().strip()
                    sections = content.split('\n\n')
                    for section in sections:
                        lines = section.split('\n')
                        if lines:
                            category = lines[0]
                            notes = lines[1:]
                            self.simple_notes_data[category] = notes
                            self.categoryDropdown.addItem(category)
                    logging.info(f"Loaded categories: {list(self.simple_notes_data.keys())}")
            except Exception as e:
                logging.error(f"Error reading file {file_path}: {e}")
        else:
            logging.warning(f"File not found: {file_path}")
            QMessageBox.warning(self, "File Not Found", f"Could not find the file at {file_path}")

        self.categoryDropdown.currentIndexChanged.connect(self.updateSimpleNotesDropdown)
        
    def updateSimpleNotesDropdown(self):
        self.notesDropdown.clear()
        selected_category = self.categoryDropdown.currentText()

        if selected_category in self.simple_notes_data:
            notes = self.simple_notes_data[selected_category]
            for note in notes:
                self.notesDropdown.addItem(note, note)  # Add both note text and data

    def updateNotesDropdown(self):
        self.notesDropdown.clear()
        note_type = self.noteTypeDropdown.currentText()
        
        if note_type == "Default Notes":
            directory = self.defaultNotesDirectory
            file_name = "default_notes.txt"
        elif note_type == "Simple Notes":
            directory = self.notesDirectory
            file_name = "simple_notes.txt"
        elif note_type == "Specific Notes":
            directory = self.defaultNotesDirectory
            file_name = "specific_notes.txt"
        elif note_type == "Default Client Notes":
            directory = self.defaultNotesDirectory
            file_name = "default_client_notes.txt"
        elif note_type == "Placeholder 2":
            directory = self.defaultNotesDirectory
            file_name = "placeholder2.txt"
        else:
            return  # If note_type is not recognized, exit the method

        file_path = os.path.join(directory, file_name)

        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read().strip()
            notes = [note.strip() for note in content.split('\n\n') if note.strip()]
    
            for note in notes:
                title = note.split('\n')[0]  # Assuming the first line is the title
                self.notesDropdown.addItem(title, note)

    def loadSelectedNote(self):
        # Fetch the selected note content using currentData which should return the data part of the currently selected item
        selected_content = self.notesDropdown.currentData()
        if debug_mode or self.debug_mode:
            print("DEBUG: loadSelectedNote Start")
            QMessageBox.information(self, "DEBUG", "loadSelectedNote Start")
        if selected_content:
            if self.toggleMode:
                if debug_mode or self.debug_mode:
                    print(f"DEBUG: loadSelectedNote Content Found: {selected_content}")
                    QMessageBox.information(self, "DEBUG", "loadSelectedNote Content Found")
                self.addNoteToTextArea(note_content=selected_content, from_button=True)
                if debug_mode or self.debug_mode:
                    print("DEBUG: loadSelectedNote addNoteToTextArea Completed")
                    QMessageBox.information(self, "DEBUG", "loadSelectedNote addNoteToTextArea Completed")

    def addNoteToTextArea(self, note_content=None, from_button=False):
        def debug_message(message):
            if debug_mode or self.debug_mode:
                print(f"DEBUG: {message}")
                QMessageBox.information(self, "DEBUG", message)

        debug_message("addNoteToTextArea entered")

        if not self.toggleMode and not from_button:
            debug_message("No toggleMode and not from_button")
            return

        # If note_content is not provided, use the current text from the dropdown
        if note_content is None:
            note_content = self.notesDropdown.currentText()

        if not note_content:
            QMessageBox.information(self, "Message", "No note content provided")
            return

        debug_message(f"Processing Note:\n\n{note_content}")

        # Check if the content is from loadSelectedNote (multi-line) or from the dropdown (single line)
        if from_button:
            debug_message("Content is from loadSelectedNote (multi-line)")
            processed_content = self.processNoteContent(note_content)
        else:
            debug_message("Content is from dropdown (single line)")
            processed_content = note_content

        cursor = self.textArea.textCursor()
        self.insertNoteInTextArea(cursor, processed_content)

        self.textArea.setTextCursor(cursor)
        self.searchBar.clear()
        debug_message("addNoteToTextArea completed")

    def processNoteContent(self, note_content):
        note_lines = note_content.split('\n')
        processed_lines = [line.lstrip('- ') for line in note_lines if line.strip().startswith('-')]
        return '\n'.join(processed_lines)

    def insertNoteInTextArea(self, cursor, note_content):
        if not self.textArea.toPlainText().strip():
            # If text area is empty, simply insert the note at the beginning.
            cursor.movePosition(QTextCursor.Start)
            cursor.insertText(note_content)
        else:
            # Determine where to insert based on the cursor's current position and text state
            is_cursor_at_end_of_line = cursor.atBlockEnd()
            is_next_line_empty = not cursor.block().next().text().strip()

            if is_cursor_at_end_of_line and not is_next_line_empty:
                self.promptForNoteInsertion(cursor, note_content)
            else:
                self.insertNote(cursor, note_content, is_cursor_at_end_of_line)

    def promptForNoteInsertion(self, cursor, note_content):
        reply = QMessageBox.question(self, "Add Note",
                                     "Where would you like to insert the note?",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel,
                                     QMessageBox.StandardButton.Yes)
        if reply == QMessageBox.StandardButton.Yes:
            self.insertNote(cursor, note_content, at_end=False)
        elif reply == QMessageBox.StandardButton.No:
            self.insertNote(cursor, note_content, at_end=True)

    def insertNote(self, cursor, note_content, at_end):
        if at_end:
            cursor.movePosition(QTextCursor.End)
        else:
            cursor.movePosition(QTextCursor.EndOfBlock)
        cursor.insertBlock()
        cursor.insertText(note_content)

    def formatSingleLine(self, line):
        # Use a regular expression to remove a dash followed by an optional space at the start of the line
        import re
        return re.sub(r'^\s*-\s*', '', line)

    def formatNoteContent(self, content):
        # Split the content into lines, format each line, and join them back together
        lines = content.split('\n')
        formatted_lines = [self.formatSingleLine(line) for line in lines]
        return '\n'.join(formatted_lines)

    def saveNote(self):
        note_html = self.textArea.toHtml()
        tags = self.tagsEdit.text().split(',')
        notebook = self.notebooksDropdown.currentText()
        notebook_path = os.path.join(self.notesDirectory, notebook)

        cursor = self.dbConnection.cursor()
        cursor.execute('SELECT save_behavior FROM settings WHERE id = 1')
        save_behavior_data = cursor.fetchone()
        save_behavior = save_behavior_data[0] if save_behavior_data else 'File'

        # Make sure self is passed as the parent
        dialog = ApprovalDialog(note_html, save_behavior, self.notesDirectory, notebook, self.autoSaveNoteFolder, self)
        if dialog.exec_() == QDialog.Accepted:
            self.textArea.clear()

    def autosaveNote(self):
        try:
            noteText = self.textArea.toHtml()

            # Fetch the auto-save behavior and folder from the database
            cursor = self.dbConnection.cursor()
            cursor.execute('SELECT auto_save_note_folder, timestamp_filenames FROM settings WHERE id = 1')
            row = cursor.fetchone()
            auto_save_note_folder = row[0] if row else self.notesDirectory
            timestamp_filenames = row[1] if row else False

            # Create a timestamp string if the timestamp option is enabled
            timestamp_str = datetime.now().strftime("%Y%m%d%H%M%S") if timestamp_filenames else "autosave"
            notebook = self.notebooksDropdown.currentText().replace(' ', '_')
            notebook_path = os.path.join(auto_save_note_folder, notebook)
            os.makedirs(notebook_path, exist_ok=True)

            fileName = os.path.join(notebook_path, f"{timestamp_str}.html")

            with open(fileName, 'w', encoding='utf-8') as file:
                file.write(noteText)
            logging.info(f"Autosaved note to {fileName}")
        except Exception as e:
            logging.error(f"Failed to autosave note: {e}")
            QMessageBox.critical(self, "Error", f"Failed to autosave note: {str(e)}")

    def searchNotes(self):
        searchText = self.searchBar.text().strip()
        note_type = self.noteTypeDropdown.currentText()
        no_notes_message = "No matching notes"

        if note_type == "Simple Notes":
            category = self.categoryDropdown.currentText()
            self.searchNotesInCategory(searchText, category)
        elif note_type == "Default Notes":
            self.searchDefaultNotes(searchText)
        elif note_type == "Specific Notes":
            self.searchNotesInFile(searchText, "specific_notes.txt")
        elif note_type == "Default Client Notes":
            self.searchNotesInFile(searchText, "default_client_notes.txt")
        elif note_type == "Placeholder 2":
            self.searchNotesInFile(searchText, "placeholder2.txt")
        else:
            self.notesDropdown.clear()
            self.notesDropdown.addItem(no_notes_message)

        # Handle no results scenario with toggle mode
        if self.toggleMode and self.notesDropdown.currentText() == no_notes_message:
            self.notesDropdown.clear()
            self.notesDropdown.addItem(searchText)

    def searchNotesInFile(self, searchText, file_name):
        directory = self.defaultNotesDirectory
        file_path = os.path.join(directory, file_name)
        
        self.notesDropdown.clear()
        
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read().strip()
            notes = [note.strip() for note in content.split('\n\n') if note.strip()]
            matching_notes = [note for note in notes if searchText.lower() in note.lower()]

            if matching_notes:
                for note in matching_notes:
                    title = note.split('\n')[0]  # Assuming the first line is the title
                    self.notesDropdown.addItem(title, note)
            else:
                self.notesDropdown.addItem("No matching notes")
        else:
            self.notesDropdown.addItem("No matching notes")

    def searchDefaultNotes(self, searchText):
        directory = self.defaultNotesDirectory  # Ensure this attribute is correctly set to point to the directory with default notes
        file_path = os.path.join(directory, "default_notes.txt")  # Assuming default notes are stored in this file

        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as file:
                sections = file.read().strip().split('\n\n')
            matching_notes = []
            for section in sections:
                if '\n' in section:  # Check if there is a newline character to split on
                    title, content = section.split('\n', 1)
                    if searchText.lower() in content.lower():
                        matching_notes.append(title)
                else:
                    # Handle sections that might only consist of a title or are malformed
                    if searchText.lower() in section.lower():
                        matching_notes.append(section)  # Assume the entire section is the title if no newline

            self.notesDropdown.clear()
            if matching_notes:
                for note in matching_notes:
                    self.notesDropdown.addItem(note)
            else:
                self.notesDropdown.addItem("No matching notes")
        else:
            self.notesDropdown.clear()
            self.notesDropdown.addItem("No notes found")

    def searchCategories(self, searchText):
        self.categoryDropdown.clear()
        directory = self.notesDirectory
        file_path = os.path.join(directory, "simple_notes.txt")
    
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read().strip()
            categories = [part.split('\n')[0] for part in content.split('\n\n') if part.strip()]
        
            if searchText:  # Only filter if there is search text
                categories = [c for c in categories if searchText in c.lower()]
        
            if not categories:  # If no categories match, ensure dropdown isn't empty
                self.categoryDropdown.addItem("No matching categories")
            else:
                for category in categories:
                    self.categoryDropdown.addItem(category)

    def searchNotesInCategory(self, searchText, category):
        directory = self.notesDirectory
        file_path = os.path.join(directory, "simple_notes.txt")

        if not os.path.exists(directory):
            os.makedirs(directory)

        note_found = False

        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as file:
                sections = file.read().strip().split('\n\n')
        
            for section in sections:
                if section.startswith(category):
                    lines = section.split('\n')[1:]  # Skip the category title
                    filtered_lines = [line for line in lines if searchText.lower() in line.lower()]

                    self.notesDropdown.clear()
                    if filtered_lines:
                        for line in filtered_lines:
                            self.notesDropdown.addItem(line)
                        note_found = True
                    else:
                        self.notesDropdown.addItem("No matching notes")
                    break  # Once the correct category is processed, stop the loop

            if not note_found:
                with open(file_path, 'a', encoding='utf-8') as file:
                    file.write(f'\n-{searchText}')
                self.notesDropdown.addItem(f'Note "{searchText}" added to the file.')
        else:
            with open(file_path, 'w', encoding='utf-8') as file:
                file.write(f'{category}\n-{searchText}')
            self.notesDropdown.clear()
            self.notesDropdown.addItem(f'Note "{searchText}" added to the new file.')

    def changeTextFont(self, font):
        self.textArea.setCurrentFont(font)

    def changeTextSize(self, size):
        self.textArea.setFontPointSize(size)

    def toggleBold(self):
        if self.textArea.fontWeight() == QFont.Bold:
            self.textArea.setFontWeight(QFont.Normal)
        else:
            self.textArea.setFontWeight(QFont.Bold)

    def toggleItalic(self):
        self.textArea.setFontItalic(not self.textArea.fontItalic())

    def changeNotebook(self):
        notebook = self.notebooksDropdown.currentText()
        notebook_path = os.path.join(self.notesDirectory, notebook)
        os.makedirs(notebook_path, exist_ok=True)
        self.updateNotesDropdown()

    def newNote(self):
        self.textArea.clear()

    def openSettings(self):
        self.settingsWindow = SettingsDialog(self)
        self.settingsWindow.show()
        
    def showAboutDialog(self):
        about_dialog = QMessageBox(self)
        about_dialog.setWindowTitle("About TSTP:Omni Omega")
        about_dialog.setIconPixmap(QPixmap(resource_path("app_icon.ico")))
        about_dialog.setText("TSTP:Omni Omega v1.0\nCreated by The Solutions To Problems, LLC")

        about_text = """
        <h2>Welcome to TSTP:Omni Omega v1.0</h2>
        <p>Welcome to <strong>TSTP:Omni Omega</strong>, the ultimate suite of productivity and utility tools. Developed by <em>The Solutions To Problems, LLC</em>, this comprehensive application is designed to enhance your efficiency and simplify complex tasks.</p>
    
        <p><strong>Key Features Include:</strong></p>
        <ul>
            <li><strong>Launcher Widget:</strong> Central hub for accessing various tools and utilities.</li>
            <li><strong>AI Chat:</strong> Integrates advanced AI models (e.g., GPT-3.5, GPT-4, Claude, Google Gemini, Inflection Pi) for intelligent and interactive responses.</li>
            <li><strong>Productivity Widgets:</strong> Additional Notes, Date/Time, Calculator, File/Folder View, Games, and To-Do List to streamline daily tasks.</li>
            <li><strong>Special Features:</strong> Webhook integration, Database Viewer, and placeholders for upcoming Cloud Integration and Email Sharing functionalities.</li>
            <li><strong>Utility Tools:</strong> Duplicate Remover for text, File Sorter, and Screen Tool for enhanced file and screen management.</li>
            <li><strong>System Info Widget:</strong> Provides detailed information about your system's hardware and software.</li>
            <li><strong>Advanced Categorization:</strong> Systematic organization of notes and data.</li>
            <li><strong>Search Functionality:</strong> Instant search to swiftly locate your entries and files.</li>
            <li><strong>Rich Text Formatting:</strong> Dynamic presentation of notes and documents.</li>
            <li><strong>Tagging and Notebooks:</strong> For meticulous arrangement and categorization.</li>
            <li><strong>Password Protection:</strong> Ensures confidentiality of sensitive information.</li>
            <li><strong>Timestamps and Autosave:</strong> Up-to-the-minute updates and automatic saving.</li>
            <li><strong>Reporting and Analytics:</strong> Insightful tracking of your activities and data usage.</li>
            <li><strong>Adaptable Settings:</strong> Customization options to tailor the application to your preferences.</li>
            <li><strong>Cross-Platform Capabilities:</strong> Ensures access to your data and tools wherever you are.</li>
            <li><strong>Export Options:</strong> Easy sharing and collaboration of notes and files.</li>
        </ul>
    
        <p>At <strong>The Solutions To Problems, LLC</strong>, we're committed to innovation and developing user-friendly software solutions that boost productivity. <strong>TSTP:Omni Omega</strong> is designed to be your go-to tool for a wide range of tasks, ensuring efficiency and ease.</p>
    
        <p>Discover more about our cutting-edge tools and join a community of productivity enthusiasts. Connect with us:</p>
        <ul>
            <li>Website: <a href="https://www.tstp.xyz">www.tstp.xyz</a></li>
            <li>Support: <a href="mailto:support@tstp.xyz">support@tstp.xyz</a></li>
            <li>LinkedIn: <a href="https://www.linkedin.com/company/thesolutions-toproblems">The Solutions To Problems</a></li>
            <li>YouTube: <a href="https://www.youtube.com/@yourpststudios">TSTP/YourPST Studios</a></li>
            <li>Facebook: <a href="https://www.facebook.com/profile.php?id=61557162643039">The Solutions To Problems</a></li>
        </ul>
    
        <p>We invite you to take part in this productivity revolution and elevate your potential. For inquiries and further information, reach out to us at <a href="mailto:info@tstp.xyz">info@tstp.xyz</a>.</p>
        """

        about_dialog.setInformativeText(about_text)
        about_dialog.setTextFormat(Qt.RichText)
        about_dialog.setStandardButtons(QMessageBox.Ok)
        about_dialog.exec_()
        
    def resizeEvent(self, event):
        self.repositionWidgets()
        super(OmniOmega, self).resizeEvent(event)
        
    def mousePressEvent(self, event):
        # Check if the click is on a child widget (i.e., a control element)
        clicked_widget = self.childAt(event.pos())

        # Enable dragging if the click is either on the menu bar, its children, or on no child widget
        if clicked_widget is None or clicked_widget == self.menuBar() or self.menuBar().isAncestorOf(clicked_widget):
            self.oldPos = event.globalPos()
            self.dragging = True
        else:
            self.dragging = False

    def mouseMoveEvent(self, event):
        if self.dragging:
            delta = QPoint(event.globalPos() - self.oldPos)
            self.move(self.x() + delta.x(), self.y() + delta.y())
            self.oldPos = event.globalPos()

    def mouseReleaseEvent(self, event):
        self.dragging = False

    def sendClockedInMessage(self):
        # Assuming `specialFeaturesWidget` is an instance of `SpecialFeaturesWidget` available in `OmniOmega`
        if hasattr(self, 'specialFeaturesWidget'):
            self.specialFeaturesWidget.send_teams_webhook(True, "Automatically clocked in", "UsernameHere")
        else:
            QMessageBox.warning(self, "Error", "Special Features Widget is not initialized.")
            
### SCREEN TOOL METHODS START ###
    def ScreenToolhandleNewConnection(self):
        clientConnection = self.server.nextPendingConnection()
        clientConnection.waitForReadyRead()
        command = clientConnection.readAll().data().decode()
        
        if '--snip' in command:
            self.ScreenToolstartSnippingTool()
        elif '--quick-capture' in command:
            self.ScreenToolcaptureScreenshotNow()

        clientConnection.disconnectFromServer()

    def ScreenTooltoggleCollapseExpand(self):
        self.collapsed = not self.collapsed  # Toggle the collapsed state
        if self.collapsed:
            self.ScreenToolcollapseWindow()
        else:
            self.ScreenToolexpandWindow()

    def ScreenToolcollapseWindow(self):
        logging.info('Application collapsed (' + timestamp + ")")
        self.setFixedSize(300, 258)  # Adjust the size dynamically based on the logo and button
        self.collapseButton.setText("Expand")
        for widget in self.toggleWidgets:
            widget.hide()  # Hide all the widgets
        self.logoLabel.show()  # Make sure to show the logo
        self.collapseButton.show()  # And the button

    def ScreenToolexpandWindow(self):
        logging.info('Application expanded (' + timestamp + ")")
        self.setFixedSize(QSize(300, 575))  # Use QSize for setting size
        self.collapseButton.setText("Collapse")
        for widget in self.toggleWidgets:
            widget.setVisible(True)

    def ScreenToolonTrayIconActivated(self, reason):
        if reason == QSystemTrayIcon.DoubleClick:
            logging.info('Application restored (' + timestamp + ")")
            self.ScreenToolrestoreWindow()
        
    def ScreenToolcloseEvent(self, event):
        if self.minimizeOnClose:
            event.ignore()  # Ignore the close event
            self.hide()  # Hide the window instead of closing
            app_icon = QIcon(resource_path('app_icon.ico'))
            self.trayIcon.setToolTip("TSTP:Screen Tool")
            self.trayIcon.showMessage("TSTP:Screen Tool Minimized", "Right click from system tray to see options or left click to reopen the program.", app_icon)
            logging.debug("Program minimized.")
            logging.info('Application minimized (' + timestamp + ")")
        else:
            logging.info('Application closed (' + timestamp + ")")
            logging.debug("Program closed properly.")
            #super(ScreenTool, self).closeEvent(event)  # Proceed with the default close event
            print("MainWindow closeEvent called")
            #super().closeEvent(event)
        
    def ScreenToolrestoreWindow(self):
        if not self.isVisible():
            logging.info('Application restored (' + timestamp + ")")
            self.ScreenToolshowNormal()
            self.ScreenToolactivateWindow()
        
    def ScreenToolsetDefaultSavePathAndMonitor(self):
        self.savePath = config.get("savePath", os.path.join(os.path.expanduser("~"), "Documents"))
        monitor_info = get_monitors_info()
        if monitor_info:
            # Assuming primary monitor has (0,0) starting coordinates.
            primary_monitor = next((monitor for monitor in monitor_info if monitor["X"] == 0 and monitor["Y"] == 0), monitor_info[0])
            self.selectedMonitor = primary_monitor
        else:
            logging.error('No monitors detected.')
            self.selectedMonitor = None
            
    def ScreenTooldefaultSavePath(self):
        # Provide a fallback save path, if not configured in the database
        return os.path.join(QStandardPaths.writableLocation(QStandardPaths.PicturesLocation), "Recordings")

    def ScreenToolshowRecordingOptionsDialog(self):
        dialog = RecordingControlDialog(self)
        if dialog.exec_() == QDialog.Accepted:
            return dialog.getRecordingOptions()
        else:
            return None

    def ScreenToolshowAboutDialog(self):
        #QTimer.singleShot(0, self.restoreWindow
        #)
        if not hasattr(self, 'aboutDialog'):
            self.aboutDialog = ScreenToolAboutDialog(self)
        self.aboutDialog.show()

    def ScreenTooltoggleMinimizeOnClose(self, state):
        self.minimizeOnClose = state
        config["minimizeOnClose"] = state
        update_config_file(config_file_path, config)
        logging.info('Minimize on close = ' + state + ' (' + timestamp + ")")
        
    def ScreenToolselectRecordingArea(self):
        overlay = SelectionOverlay()
        overlay.exec_()  # Execute the overlay window

        # Calculate the selected area based on the overlay's begin and end points
        if overlay.begin and overlay.end:
            x = min(overlay.begin.x(), overlay.end.x())
            y = min(overlay.begin.y(), overlay.end.y())
            width = abs(overlay.end.x() - overlay.begin.x())
            height = abs(overlay.end.y() - overlay.begin.y())
            return (x, y, width, height)
        else:
            return None
        
    def ScreenTooltoggleNotifications(self):
        global notifications_toggle
        notifications_toggle = not notifications_toggle
        print(f"Notifications toggled: {notifications_toggle}")  # Debug print statement
        self.btnNotifications.setText("Notifications ON" if notifications_toggle else "Notifications OFF")
        logging.info('Notifications Status Change = ' + timestamp)
        # Update the corresponding action in trayMenu directly
        for action in self.trayMenu.actions():
            if action.text().startswith("Toggle Notifications"):
                action.setChecked(notifications_toggle)
                break

        # Update the system tray tooltip to reflect the new state
        self.trayIcon.setToolTip(f"TSTP:Screen Tool - Notifications {'ON' if notifications_toggle else 'OFF'}")

        # Ensure to update the config file if you are storing the notification state
        config["notifications_toggle"] = notifications_toggle
        update_config_file(config_file_path, config)

    def ScreenToolquickCaptureScreenshotWithDelay(self):
        #QTimer.singleShot(0, self.restoreWindow)
        delay, confirmed = QInputDialog.getInt(self, "Capture Delay", "Set delay time in seconds:", 5, 0, 60, 1)
        if confirmed:
            QTimer.singleShot(delay * 1000, self.ScreenToolcaptureScreenshotNow)

    def ScreenToolcaptureScreenshotNow(self):
        try:
            timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            filename = f"Screenshot_{timestamp}.png"
            filePath = os.path.join(self.savePath, filename)

            # Capture the screenshot
            if self.selectedWindow is not None:
                desktop_pixmap = self.ScreenToolcaptureEntireDesktop()
                window = gw.getWindowsWithTitle(self.selectedWindow.title)[0]
                window_rect = QRect(window.left, window.top, window.width, window.height)
                adjusted_rect = self.ScreenTooladjustForMultipleMonitors(window_rect)
                cropped_pixmap = desktop_pixmap.copy(adjusted_rect)
            elif self.selectedMonitor is not None and self.selectedMonitorIndex is not None and self.selectedMonitorIndex < len(QApplication.instance().screens()):
                selected_screen = QApplication.instance().screens()[self.selectedMonitorIndex]
                cropped_pixmap = selected_screen.grabWindow(0)
            else:
                cropped_pixmap = self.ScreenToolcaptureEntireDesktop()

            # Annotate if the setting is enabled
            if self.annotateBeforeSaving:
                snipping_widget = SnippingWidget(cropped_pixmap, self)  # Create an instance of the SnippingWidget class
                final_pixmap = snipping_widget.annotateScreenshot(cropped_pixmap)
            else:
                final_pixmap = cropped_pixmap

            # Save the pixmap
            final_pixmap.save(filePath)

            print(f"Screenshot saved to: {filePath}")
            self.ScreenToolshowNotification("Screenshot Saved", f"Screenshot saved to {filePath}")

        except Exception as e:
            print(f"Error taking screenshot: {e}")
            self.ScreenToolshowNotification("Screenshot Error", f"Failed to take screenshot: {e}")

    def ScreenToolcaptureEntireDesktop(self):
        total_rect = QRect()
        for screen in QGuiApplication.screens():
            total_rect = total_rect.united(screen.geometry())

        desktop_pixmap = QPixmap(total_rect.size())
        desktop_pixmap.fill(Qt.black)
        painter = QPainter(desktop_pixmap)

        for screen in QGuiApplication.screens():
            screen_geo = screen.geometry()
            screen_pixmap = screen.grabWindow(0)
            virtual_top_left = screen_geo.topLeft() - total_rect.topLeft()
            painter.drawPixmap(virtual_top_left, screen_pixmap)

        painter.end()
        return desktop_pixmap

    def ScreenTooladjustForMultipleMonitors(self, window_rect):
        """Adjusts window QRect for multiple monitors."""
        min_x = min_y = 0
        for screen in QGuiApplication.screens():
            geometry = screen.geometry()
            min_x = min(min_x, geometry.x())
            min_y = min(min_y, geometry.y())
        return QRect(window_rect.x() - min_x, window_rect.y() - min_y, window_rect.width(), window_rect.height())

    def ScreenToolshowNotification(self, title, message):
        """Shows a notification."""
        if notifications_toggle:  # Assuming notifications_toggle is a global or class attribute
            if self.isVisible():
                QMessageBox.information(self, title, message)
            else:
                self.trayIcon.showMessage(title, message, QIcon(resource_path('app_icon.ico')))

    def ScreenToolcaptureScreenshot(self):
        #QTimer.singleShot(0, self.restoreWindow)
        areaSelectDialog = AreaSelectDialog(self)
        if areaSelectDialog.exec_() == QDialog.Accepted:
            selectedArea = areaSelectDialog.getSelectedArea()
            filePath = self.saveFile("Screenshot", "png")
            if selectedArea:
                screenshot = pyautogui.screenshot(region=selectedArea)
            elif self.selectedWindow:
                window_rect = gw.getRect(self.selectedWindow)
                screenshot = pyautogui.screenshot(region=(window_rect.left, window_rect.top, window_rect.width, window_rect.height))
            else:
                screenshot = pyautogui.screenshot()
            screenshot.save(filePath)
            if notifications_toggle:
                QMessageBox.information(self, "Screenshot Saved", f"Screenshot saved to {filePath}")
        else:
            if notifications_toggle:
                QMessageBox.information(self, "Screenshot Cancelled", "Screenshot operation was cancelled.")

    def ScreenToolshowRecordingControl(self):
        #QTimer.singleShot(0, self.restoreWindow)
        if not hasattr(self, 'recordingControlDialog'):
            self.recordingControlDialog = RecordingControlDialog(self)
        self.recordingControlDialog.show()
        
    def ScreenToolcreateGifFromScreenshots(self):
        #QTimer.singleShot(0, self.restoreWindow)
        gifCreationDialog = GifCreationDialog(self)
        gifCreationDialog.exec_()

    def ScreenToolshowSettings(self):
        if not hasattr(self, 'settingsDialog'):
            self.settingsDialog = ScreenToolSettingsDialog(self)  # 'self' refers to the instance of MainWindow, making it the parent
        self.settingsDialog.show()

        # Prevent the QDialog from being garbage collected
        self.settingsDialog.setAttribute(Qt.WA_DeleteOnClose, False)
        
    def ScreenToollaunchSnippingTool(self):
        #self.hide()
        QTimer.singleShot(100, self.ScreenToolstartSnippingTool)  # Delay to ensure the window is hidden

    def ScreenToolstartSnippingTool(self):
        # Calculate the combined geometry of all screens
        min_x, min_y, max_x, max_y = 0, 0, 0, 0
        screens = QGuiApplication.screens()
        for screen in screens:
            geometry = screen.geometry()
            min_x = min(min_x, geometry.x())
            min_y = min(min_y, geometry.y())
            max_x = max(max_x, geometry.x() + geometry.width())
            max_y = max(max_y, geometry.y() + geometry.height())

        # Take a screenshot of the entire desktop area covering all monitors
        screenshot = pyautogui.screenshot(region=(min_x, min_y, max_x - min_x, max_y - min_y))

        # Convert the screenshot to the format expected by SnippingWidget (QPixmap)
        qimg = QImage(screenshot.tobytes(), screenshot.width, screenshot.height, QImage.Format_RGB888).rgbSwapped()
        pixmap = QPixmap.fromImage(qimg)

        # Initialize SnippingWidget with the combined screenshot and show it
        self.snippingWidget = SnippingWidget(pixmap, self)
        self.snippingWidget.setGeometry(min_x, min_y, max_x - min_x, max_y - min_y)  # Set geometry to cover all monitors
        self.snippingWidget.show()

    def ScreenToolrecordScreen(self):
        #QTimer.singleShot(0, self.restoreWindow)
        if not self.isRecording:
            self.ScreenToolstartRecording()

    def ScreenToolcaptureFrame(self):
        #QTimer.singleShot(0, self.restoreWindow)
        if self.selectedMonitor and self.videoWriter:
            monitor = self.selectedMonitor
            screenshot = pyautogui.screenshot(region=(monitor.x, monitor.y, monitor.width, monitor.height))
            frame = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
            self.videoWriter.write(frame)

    def ScreenToolshowRecordingControl(self):
        if self.recordingControlDialog is None:
            self.recordingControlDialog = RecordingControlDialog(self)
        self.recordingControlDialog.show()

    def ScreenToolstartRecording(self):
        savePath = self.get_config_value("savePath") or self.defaultSavePath()
        self.annotationWidget = AnnotationWidget(self)

    def ScreenToolstopRecording(self):
        if self.isRecording and self.recordingTimer and self.videoWriter:
            self.recordingTimer.stop()
            self.videoWriter.release()
            self.videoWriter = None
            self.isRecording = False
            full_save_path = ""
            if notifications_toggle:
                QMessageBox.information(self, "Recording Stopped", "The recording has been stopped and saved.")
            annotated_video_path = self.applyAnnotationsToVideo(full_save_path)
            
    def ScreenToolapplyAnnotationsToVideo(self, video_path):
        annotated_video_path = ""
        # Implement logic to apply annotations to the video using the annotation widget
        # You can use libraries like MoviePy or OpenCV to process the video and overlay annotations
        # Return the path to the annotated video
        return annotated_video_path

    def ScreenToolcreateGifFromScreenshots(self):
        gifCreationDialog = GifCreationDialog(self)
        gifCreationDialog.exec_()

    def ScreenToolshowSettings(self):
        if not hasattr(self, 'settingsDialog'):
            self.settingsDialog = ScreenToolSettingsDialog(self)
        self.settingsDialog.show()

    def ScreenToolselectWindow(self):
        if not hasattr(self, 'windowSelectionDialog'):
            self.windowSelectionDialog = WindowSelectionDialog(self)
        self.windowSelectionDialog.show()

    def ScreenToolsaveFile(self, prefix, extension):
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        filename = f"{prefix}_{timestamp}.{extension}"
        return os.path.join(self.savePath, filename)
    
    def ScreenTooladdContextMenuOptions(self):
        """Adds or removes options to the Windows context menu based on their current state."""
        if self.is_admin():
            if self.isContextMenuOptionAdded():
                reply = QMessageBox.question(self, 'Remove Context Menu Options', "Context menu options are already added. Would you like to remove them?",
                                             QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                if reply == QMessageBox.Yes:
                    try:
                        remove_context_menu_options()
                        self.addActionToTrayMenu.setText("Add to Right Click")
                        QMessageBox.information(self, "Success", "Context menu options removed successfully.")
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to remove context menu options: {str(e)}")
            else:
                try:
                    add_context_menu_options()
                    self.addActionToTrayMenu.setText("Remove Right Click")
                    QMessageBox.information(self, "Success", "Context menu options added successfully.")
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to add context menu options: {str(e)}")
        else:
            reply = QMessageBox.question(self, 'Run as Administrator', "This action requires administrative privileges. "
                                    "Would you like to restart the application as an administrator?",
                                    QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                self.attempt_run_as_admin()

    def ScreenToolis_admin(self):
        """Checks if the program is running with administrator privileges."""
        try:
            return ctypes.windll.shell32.IsUserAnAdmin()
        except:
            return False

    def ScreenToolattempt_run_as_admin(self):
        """Attempts to restart the application with administrator privileges."""
        ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)

    def ScreenToolcheckAndAddContextMenuOption(self):
        if self.isContextMenuOptionAdded():
            self.addActionToTrayMenu.setText("Right Click Enabled")
            self.addActionToTrayMenu.setDisabled(True)
        else:
            self.addActionToTrayMenu.setText("Add to Right Click")
            self.addActionToTrayMenu.setEnabled(True)

    def ScreenToolisContextMenuOptionAdded(self):
        # Check for the existence of at least one context menu option
        option_names = [
            'TSTP:SC - Snip',
            'TSTP:SC - Screen Capture'
        ]

        # Attempt to open a registry key for each option name
        for option_name in option_names:
            key_path = r'Directory\Background\shell\{}'.format(option_name.replace(" ", "_"))
            try:
                reg_key = reg.OpenKey(reg.HKEY_CLASSES_ROOT, key_path, 0, reg.KEY_READ)
                reg.CloseKey(reg_key)
                return True
            except WindowsError:
                continue

        return False
        
    def ScreenToolpaintEvent(self, event):
        painter = QPainter(self)
        painter.drawPixmap(self.rect(), self.pixmap)
### MAIN WINDOW END ###

### LAUNCHER WIDGETS START ###
class LauncherWidget(QWidget):
    def __init__(self, parent=None, note_maker_instance=None, settings=None, notification_manager=None):
        super().__init__(parent)
        self.note_maker_instance = note_maker_instance
        self.parent = parent
        self.settings = settings
        self.initDB()
        self.initUI()
        self.loadLaunchers()
        self.loadCommonApplications()
        self.notification_manager = notification_manager or self.create_default_notification_manager()
        self.db_manager = SchedulerDatabaseManager(self.notification_manager)
        self.setupScheduler()
        self.debug_check()
        self.browser_selector = BrowserSelector(self)
        self.browser_selector.browserChanged.connect(self.update_selected_browser)
        self.selected_browser_path = None
        self.selected_browser_name = None
        self.load_selected_browser()
        self.loadSettings()

    def loadSettings(self):
        settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")

        show_path = settings.value("showPath", True, type=bool)
        show_type = settings.value("showType", True, type=bool)
        show_parameters = settings.value("showParameters", True, type=bool)

        self.showPathCheckBox.setChecked(show_path)
        self.showTypeCheckbox.setChecked(show_type)
        self.showParametersCheckBox.setChecked(show_parameters)

        self.showPathAction()
        self.showTypeAction()
        self.showParametersAction()
        
    def create_default_notification_manager(self):
        # Create and return a default notification manager instance
        return NotificationManager()
        
    def load_selected_browser(self):
        if self.settings:
            saved_browser_path = self.settings.value("browser_path", "")
            saved_browser_name = self.settings.value("browser_name", "")
            if saved_browser_path and os.path.exists(saved_browser_path):
                self.browser_selector.browser_combo.setCurrentText(saved_browser_name)
                self.update_selected_browser(saved_browser_path, saved_browser_name)

    def update_selected_browser(self, browser_path, browser_name):
        self.selected_browser_path = browser_path
        self.selected_browser_name = browser_name
        self.scheduler.set_selected_browser_path(browser_path)

    def debug_check(self):
        if self.note_maker_instance and self.note_maker_instance.get_toggle_mode():
            QMessageBox.information(self,"TOGGLE MODE ENABLED","toggleMode is enabled")

    def initDB(self):
        db_exists = os.path.exists('launcher.db')
        self.dbConnection = sqlite3.connect('launcher.db')

        if not db_exists:
            self.createDatabase()
        else:
            try:
                self.updateDatabase()
            except Exception as e:
                QMessageBox.critical(self, "Database Error", f"An error occurred while updating the database: {str(e)}")
                self.logError(f"Error updating database: {str(e)}")
                if debug_mode:
                    QMessageBox.information(self, "Debug", f"Error updating database: {str(e)}")

    def createDatabase(self):
        try:
            cursor = self.dbConnection.cursor()

            # Create tables with the updated schema
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS launchers (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    launcher_name TEXT
                )
            ''')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS launcher_items (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    launcher_id INTEGER,
                    item_name TEXT,
                    item_type TEXT,
                    item_path TEXT,
                    parameters TEXT,
                    launch_order INTEGER,
                    launch INTEGER DEFAULT 0,
                    FOREIGN KEY (launcher_id) REFERENCES launchers (id)
                )
            ''')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS activity_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT,
                    item_name TEXT,
                    message TEXT
                )
            ''')
            self.dbConnection.commit()
        except Exception as e:
            QMessageBox.critical(self, "Database Error", f"An error occurred while creating the database: {str(e)}")
            self.logError(f"Error creating database: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error creating database: {str(e)}")

    def createDatabase(self):
        try:
            cursor = self.dbConnection.cursor()

            cursor.execute('''
                CREATE TABLE IF NOT EXISTS launchers (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    launcher_name TEXT
                )
            ''')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS launcher_items (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    launcher_id INTEGER,
                    item_name TEXT,
                    item_type TEXT,
                    item_path TEXT,
                    parameters TEXT,
                    launch_order INTEGER,
                    launch INTEGER DEFAULT 0,
                    FOREIGN KEY (launcher_id) REFERENCES launchers (id)
                )
            ''')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS activity_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT,
                    item_name TEXT,
                    message TEXT
                )
            ''')
            self.dbConnection.commit()
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Database Error", f"An error occurred while creating the database: {str(e)}")
            self.logError(f"Error creating database: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error creating database: {str(e)}")

    def updateDatabase(self):
        try:
            cursor = self.dbConnection.cursor()

            # Check if the launchers table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='launchers'")
            launchers_table_exists = cursor.fetchone()

            if not launchers_table_exists:
                # launchers table doesn't exist, create it
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS launchers (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        launcher_name TEXT
                    )
                ''')
                self.dbConnection.commit()

            # Check if the launcher_items table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='launcher_items'")
            launcher_items_table_exists = cursor.fetchone()

            if launcher_items_table_exists:
                # Check if the launch column exists in the launcher_items table
                cursor.execute("PRAGMA table_info(launcher_items)")
                columns = cursor.fetchall()
                launch_column_exists = any(column[1] == 'launch' for column in columns)

                if not launch_column_exists:
                    # Prompt the user for confirmation
                    confirm = QMessageBox.question(self, "Database Update", "The database schema needs to be updated. Do you want to proceed?",
                                                   QMessageBox.Yes | QMessageBox.No)

                    if confirm == QMessageBox.Yes:
                        try:
                            # Attempt to add the launch column to the existing table
                            cursor.execute("ALTER TABLE launcher_items ADD COLUMN launch INTEGER DEFAULT 0")
                            self.dbConnection.commit()
                            QMessageBox.information(self, "Database Update", "The database has been updated successfully.")
                        except sqlite3.OperationalError:
                            # Column addition failed, create a new database with the updated schema
                            self.dbConnection.close()
                            new_db_path = 'launcher_new.db'
                            os.rename('launcher.db', 'launcher_old.db')
                            new_db_connection = sqlite3.connect(new_db_path)
                            new_cursor = new_db_connection.cursor()

                            # Create tables with the updated schema
                            new_cursor.execute('''
                                CREATE TABLE IF NOT EXISTS launchers (
                                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                                    launcher_name TEXT
                                )
                            ''')
                            new_cursor.execute('''
                                CREATE TABLE IF NOT EXISTS launcher_items (
                                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                                    launcher_id INTEGER,
                                    item_name TEXT,
                                    item_type TEXT,
                                    item_path TEXT,
                                    parameters TEXT,
                                    launch_order INTEGER,
                                    launch INTEGER DEFAULT 0,
                                    FOREIGN KEY (launcher_id) REFERENCES launchers (id)
                                )
                            ''')
                            new_cursor.execute('''
                                CREATE TABLE IF NOT EXISTS activity_log (
                                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                                    timestamp TEXT,
                                    item_name TEXT,
                                    message TEXT
                                )
                            ''')
                            new_db_connection.commit()

                            # Copy data from the old database to the new database
                            old_db_connection = sqlite3.connect('launcher_old.db')
                            old_cursor = old_db_connection.cursor()

                            old_cursor.execute("SELECT * FROM launchers")
                            launchers_data = old_cursor.fetchall()
                            new_cursor.executemany("INSERT INTO launchers VALUES (?, ?)", launchers_data)

                            old_cursor.execute("SELECT id, launcher_id, item_name, item_type, item_path, parameters, launch_order FROM launcher_items")
                            launcher_items_data = old_cursor.fetchall()
                            new_cursor.executemany("INSERT INTO launcher_items (id, launcher_id, item_name, item_type, item_path, parameters, launch_order, launch) VALUES (?, ?, ?, ?, ?, ?, ?, 0)", launcher_items_data)

                            old_cursor.execute("SELECT * FROM activity_log")
                            activity_log_data = old_cursor.fetchall()
                            new_cursor.executemany("INSERT INTO activity_log VALUES (?, ?, ?, ?)", activity_log_data)
                            new_db_connection.commit()
                            old_db_connection.close()

                            self.dbConnection = new_db_connection
                            QMessageBox.information(self, "Database Update", "A new database has been created with the updated schema. The old database has been renamed to 'launcher_old.db'.")
                    else:
                        QMessageBox.information(self, "Database Update", "Database update canceled.")
            else:
                # launcher_items table doesn't exist, create tables with the updated schema
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS launchers (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        launcher_name TEXT
                    )
                ''')
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS launcher_items (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        launcher_id INTEGER,
                        item_name TEXT,
                        item_type TEXT,
                        item_path TEXT,
                        parameters TEXT,
                        launch_order INTEGER,
                        launch INTEGER DEFAULT 0,
                        FOREIGN KEY (launcher_id) REFERENCES launchers (id)
                    )
                ''')
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS activity_log (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        timestamp TEXT,
                        item_name TEXT,
                        message TEXT
                    )
                ''')
                self.dbConnection.commit()

        except sqlite3.Error as e:
            QMessageBox.critical(self, "Database Error", f"An error occurred while updating the database: {str(e)}")
            self.logError(f"Error updating database: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error updating database: {str(e)}")
                
    def setupScheduler(self):
        self.db_manager = SchedulerDatabaseManager(self.notification_manager)
        self.scheduler = TaskScheduler(self.db_manager)
        self.scheduler.taskCompleted.connect(self.onTaskCompleted)
        self.scheduler.taskFailed.connect(self.onTaskFailed)
        self.schedulerThread = QThread()
        self.scheduler.moveToThread(self.schedulerThread)
        self.schedulerThread.started.connect(self.scheduler.start)
        self.schedulerThread.start()

    def openScheduleDialog(self):
        selectedLauncherTable = self.launcherTabs.currentWidget()
        if selectedLauncherTable:
            selected_rows = selectedLauncherTable.selectionModel().selectedRows()
            if selected_rows:
                # Schedule the selected items
                self.scheduleSelectedItems(selected_rows, selectedLauncherTable)
            else:
                # No item is selected, schedule all checked items
                self.scheduleCheckedItems(selectedLauncherTable)
        else:
            QMessageBox.warning(self, "No Active Tab", "Please select an active tab.")

    def scheduleSelectedItems(self, selected_rows, selectedLauncherTable):
        schedule_info_list = []
        for row in selected_rows:
            row = row.row()
            itemName = selectedLauncherTable.item(row, 2).text()
            itemType = selectedLauncherTable.item(row, 3).text()
            itemPath = selectedLauncherTable.item(row, 5).text()
            parameters = selectedLauncherTable.item(row, 4).text()
            schedule_info_list.append({
                "item_name": itemName,
                "item_type": itemType,
                "item_path": itemPath,
                "parameters": parameters
            })

        if schedule_info_list:
            schedulerDialog = SchedulerDialog(self.db_manager, self.parent.themes[self.parent.current_theme], self, schedule_info_list)
            if schedulerDialog.exec_() == QDialog.Accepted:
                schedule_info = schedulerDialog.get_schedule()
                for item_info in schedule_info_list:
                    self.scheduler.schedule_task(item_info["item_name"], item_info["item_path"], item_info["parameters"], schedule_info)
                self.showMessage(f"Schedules set for the selected items.")

    def scheduleCheckedItems(self, selectedLauncherTable):
        schedule_info_list = []
        launcher_name = self.launcherTabs.tabText(self.launcherTabs.currentIndex())
        launcher_id = selectedLauncherTable.property("launcher_id")
    
        schedulerDialog = SchedulerDialog(self.db_manager, self.parent.themes[self.parent.current_theme], self)
        if schedulerDialog.exec_() == QDialog.Accepted:
            schedule_info = schedulerDialog.get_schedule()
            if schedule_info:
                schedule_info["launcher_name"] = launcher_name
                schedule_info["launcher_id"] = launcher_id
                self.scheduler.schedule_launcher(schedule_info)
                self.showMessage(f"Schedules set for launcher '{launcher_name}'.")

    def promptScheduleAllItems(self, selectedLauncherTable):
        confirm = QMessageBox.question(self, "Schedule All", "No item is selected. Do you want to schedule all items in the launcher?", QMessageBox.Yes | QMessageBox.No)
        if confirm == QMessageBox.Yes:
            self.scheduleAllItems(selectedLauncherTable)
        else:
            QMessageBox.information(self, "Schedule Canceled", "The schedule was not added.")

    def scheduleAllItems(self, selectedLauncherTable):
        schedule_info_list = []
        launcher_name = self.launcherTabs.tabText(self.launcherTabs.currentIndex())
        launcher_id = selectedLauncherTable.property("launcher_id")

        schedulerDialog = SchedulerDialog(self.db_manager, self.parent.themes[self.parent.current_theme], self)
        if schedulerDialog.exec_() == QDialog.Accepted:
            schedule_info = schedulerDialog.get_schedule()
            if schedule_info:
                schedule_info["launcher_name"] = launcher_name
                schedule_info["launcher_id"] = launcher_id
                self.scheduler.schedule_launcher(schedule_info)
                self.showMessage(f"Schedules set for launcher '{launcher_name}'.")

    def initUI(self):
        layout = QVBoxLayout(self)

        # Row 1: Add Launcher, Edit Launcher, Delete Launcher, Import Launcher, Export Launcher
        launcherButtonLayout = QHBoxLayout()
        self.addLauncherButton = QPushButton("Add Launcher", self)
        self.addLauncherButton.clicked.connect(self.addLauncher)
        launcherButtonLayout.addWidget(self.addLauncherButton)

        self.editLauncherButton = QPushButton("Edit Launcher", self)
        self.editLauncherButton.clicked.connect(self.editLauncher)
        launcherButtonLayout.addWidget(self.editLauncherButton)

        self.deleteLauncherButton = QPushButton("Delete Launcher", self)
        self.deleteLauncherButton.clicked.connect(self.deleteLauncher)
        launcherButtonLayout.addWidget(self.deleteLauncherButton)

        self.importLauncherButton = QPushButton("Import Launcher", self)
        self.importLauncherButton.clicked.connect(self.importLauncher)
        launcherButtonLayout.addWidget(self.importLauncherButton)

        self.exportLauncherButton = QPushButton("Export Launcher", self)
        self.exportLauncherButton.clicked.connect(self.exportLauncher)
        launcherButtonLayout.addWidget(self.exportLauncherButton)

        layout.addLayout(launcherButtonLayout)

        # Row 2: Parameters, Type, Path
        paramTypePath = QHBoxLayout()
        self.showParametersCheckBox = QCheckBox("Parameters")
        self.showParametersCheckBox.clicked.connect(self.showParametersAction)
        self.showParametersCheckBox.setChecked(True)
        paramTypePath.addWidget(self.showParametersCheckBox)

        self.showTypeCheckbox = QCheckBox("Type")
        self.showTypeCheckbox.clicked.connect(self.showTypeAction)
        self.showTypeCheckbox.setChecked(True)
        paramTypePath.addWidget(self.showTypeCheckbox)

        self.showPathCheckBox = QCheckBox("Path")
        self.showPathCheckBox.clicked.connect(self.showPathAction)
        self.showPathCheckBox.setChecked(True)
        paramTypePath.addWidget(self.showPathCheckBox)
        layout.addLayout(paramTypePath)
        self.loadCheckboxState()

        # Row 3: Launcher Table
        self.launcherTabs = QTabWidget(self)
        self.launcherTabs.setAcceptDrops(True)
        self.launcherTabs.dragEnterEvent = self.tabDragEnterEvent
        self.launcherTabs.dropEvent = self.tabDropEvent
        self.launcherTabs.setGeometry(10, 50, 800, 400)
        layout.addWidget(self.launcherTabs)

        # Make the columns resizable
        current_tab = self.launcherTabs.currentWidget()
        if current_tab is not None:
            current_tab.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)

        # Load the state of the checkboxes
        self.loadCheckboxState()

        # Connect the checkboxes to their respective actions
        self.showPathCheckBox.clicked.connect(self.showPathAction)
        self.showTypeCheckbox.clicked.connect(self.showTypeAction)
        self.showParametersCheckBox.clicked.connect(self.showParametersAction)

        # Row 4: Search (Add Label)
        searchLayout = QHBoxLayout()
        self.searchLabel = QLabel("Search:", self)
        searchLayout.addWidget(self.searchLabel)
        self.searchEdit = QLineEdit(self)
        self.searchEdit.setPlaceholderText("Search...")
        self.searchEdit.textChanged.connect(self.filterItems)
        searchLayout.addWidget(self.searchEdit)
        layout.addLayout(searchLayout)

        # Row 5: Item Name, Item Type
        itemNameTypeLayout = QHBoxLayout()
        self.itemNameLabel = QLabel("Item Name:", self)
        itemNameTypeLayout.addWidget(self.itemNameLabel)
        self.itemNameEdit = QLineEdit(self)
        itemNameTypeLayout.addWidget(self.itemNameEdit)

        self.itemTypeLabel = QLabel("Item Type:", self)
        itemNameTypeLayout.addWidget(self.itemTypeLabel)
        self.itemTypeDropdown = QComboBox(self)
        self.itemTypeDropdown.addItems(["Website", "Program"])
        self.itemTypeDropdown.setCurrentText("Website")
        self.itemTypeDropdown.currentTextChanged.connect(self.itemTypeChanged)
        itemNameTypeLayout.addWidget(self.itemTypeDropdown)
        layout.addLayout(itemNameTypeLayout)

        # Row 6: Path, Parameters
        itemPathParamsLayout = QHBoxLayout()
        self.itemPathLabel = QLabel("Web Address:", self)
        itemPathParamsLayout.addWidget(self.itemPathLabel)
        self.itemPathEdit = QLineEdit(self)
        itemPathParamsLayout.addWidget(self.itemPathEdit)
        self.itemPathButton = QPushButton("Browse", self)
        self.itemPathButton.clicked.connect(self.browseItemPath)
        itemPathParamsLayout.addWidget(self.itemPathButton)

        self.parametersLabel = QLabel("Parameters:", self)
        itemPathParamsLayout.addWidget(self.parametersLabel)
        self.parametersEdit = QLineEdit(self)
        self.parametersEdit.setPlaceholderText("Parameters")
        self.parametersEdit.setEnabled(False)
        itemPathParamsLayout.addWidget(self.parametersEdit)
        layout.addLayout(itemPathParamsLayout)

        # Row 7: Common Programs, Launch Selected
        commonProgramsLayout = QHBoxLayout()
        self.commonAppDropdown = QComboBox(self)
        self.commonAppDropdown.currentTextChanged.connect(self.fillCommonApp)
        commonProgramsLayout.addWidget(self.commonAppDropdown)

        self.launchSelectedButton = QPushButton("Launch Selected", self)
        self.launchSelectedButton.clicked.connect(self.launchSelectedItems)
        commonProgramsLayout.addWidget(self.launchSelectedButton)
        layout.addLayout(commonProgramsLayout)

        self.scheduleButton = QPushButton("Schedule Launch", self)
        self.scheduleButton.clicked.connect(self.openScheduleDialog)
        commonProgramsLayout.addWidget(self.scheduleButton)

        # Row 8: Add Item, Edit Item, Delete Item
        itemButtonLayout = QHBoxLayout()
        self.addItemButton = QPushButton("Add Item", self)
        self.addItemButton.clicked.connect(self.addLauncherItem)
        itemButtonLayout.addWidget(self.addItemButton)

        self.editItemButton = QPushButton("Edit Item", self)
        self.editItemButton.clicked.connect(self.editLauncherItem)
        itemButtonLayout.addWidget(self.editItemButton)

        self.deleteItemButton = QPushButton("Delete Item", self)
        self.deleteItemButton.clicked.connect(self.deleteLauncherItem)
        itemButtonLayout.addWidget(self.deleteItemButton)
        layout.addLayout(itemButtonLayout)

        self.loadCommonApplications()

    def loadLaunchers(self):
        try:
            cursor = self.dbConnection.cursor()
            cursor.execute('SELECT * FROM launchers')
            launchers = cursor.fetchall()
            for launcher in launchers:
                self.addLauncherTab(launcher[0], launcher[1])
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Database Error", f"An error occurred while loading launchers: {str(e)}")
            self.logError(f"Error loading launchers: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error loading launchers: {str(e)}")

    def editLauncher(self):
        try:
            launcherTable = self.launcherTabs.currentWidget()
            if launcherTable is not None:
                launcher_id = launcherTable.property("launcher_id")
                launcher_name = self.launcherTabs.tabText(self.launcherTabs.currentIndex())

                new_launcher_name, ok = QInputDialog.getText(self, "Edit Launcher", "Enter new launcher name:", text=launcher_name)
                if ok and new_launcher_name.strip():
                    cursor = self.dbConnection.cursor()
                    cursor.execute("UPDATE launchers SET launcher_name = ? WHERE id = ?", (new_launcher_name.strip(), launcher_id))
                    self.dbConnection.commit()
                    self.launcherTabs.setTabText(self.launcherTabs.currentIndex(), new_launcher_name.strip())
                    self.showMessage(f"Launcher '{launcher_name}' updated to '{new_launcher_name.strip()}'.")
                elif ok and not new_launcher_name.strip():
                    QMessageBox.warning(self, "Invalid Launcher Name", "Launcher name cannot be empty.")
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Edit Launcher Error", f"An error occurred while editing the launcher: {str(e)}")
            self.logError(f"Error editing launcher: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error editing launcher: {str(e)}")

    def importLauncher(self):
        try:
            file_path, _ = QFileDialog.getOpenFileName(self, "Import Launcher", "", "Launcher Files (*.json)")
            if file_path:
                with open(file_path, "r") as file:
                    data = json.load(file)
                launcher_name = data["launcher_name"]
                launcher_items = data["launcher_items"]

                cursor = self.dbConnection.cursor()
                cursor.execute("INSERT INTO launchers (launcher_name) VALUES (?)", (launcher_name,))
                launcher_id = cursor.lastrowid

                for item in launcher_items:
                    cursor.execute("INSERT INTO launcher_items (launcher_id, item_name, item_type, item_path, parameters, launch_order, launch) VALUES (?, ?, ?, ?, ?, ?, ?)", (
                        launcher_id,
                        item["item_name"],
                        item["item_type"],
                        item["item_path"],
                        item["parameters"],
                        item["launch_order"],
                        item["launch"]
                    ))
                self.dbConnection.commit()
                self.addLauncherTab(launcher_id, launcher_name)
                self.showMessage(f"Launcher '{launcher_name}' imported successfully.")
        except (FileNotFoundError, json.JSONDecodeError) as e:
            QMessageBox.critical(self, "Import Error", f"Failed to import launcher: {str(e)}")
            self.logError(f"Error importing launcher: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error importing launcher: {str(e)}")
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Database Error", f"An error occurred while importing the launcher: {str(e)}")
            self.logError(f"Error importing launcher: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error importing launcher: {str(e)}")

    def exportLauncher(self):
        try:
            file_path, _ = QFileDialog.getSaveFileName(self, "Export Launcher", "", "Launcher Files (*.json)")
            if file_path:
                launcher_id = self.launcherTabs.currentWidget().property("launcher_id")
                launcher_name = self.launcherTabs.tabText(self.launcherTabs.currentIndex())

                cursor = self.dbConnection.cursor()
                cursor.execute("SELECT item_name, item_type, item_path, parameters, launch_order, launch FROM launcher_items WHERE launcher_id = ?", (launcher_id,))
                launcher_items = []
                for row in cursor.fetchall():
                    launcher_items.append({
                        "item_name": row[0],
                        "item_type": row[1],
                        "item_path": row[2],
                        "parameters": row[3],
                        "launch_order": row[4],
                        "launch": row[5]
                    })

                data = {
                    "launcher_name": launcher_name,
                    "launcher_items": launcher_items
                }

                with open(file_path, "w") as file:
                    json.dump(data, file, indent=4)

                self.showMessage(f"Launcher '{launcher_name}' exported successfully.")
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Export Error", f"An error occurred while exporting the launcher: {str(e)}")
            self.logError(f"Error exporting launcher: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error exporting launcher: {str(e)}")
        except IOError as e:
            QMessageBox.critical(self, "Export Error", f"Failed to save the launcher file: {str(e)}")
            self.logError(f"Error exporting launcher: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error exporting launcher: {str(e)}")
            
    def test_function(self):
        QMessageBox.information(self,"Test Function","Test Function Has Been Triggered!")
        pass

    def showPathAction(self):
        # Implement the logic to show/hide the Path column
        if hasattr(self, 'launcherTabs'):
            for i in range(self.launcherTabs.count()):
                launcherTable = self.launcherTabs.widget(i)
                launcherTable.setColumnHidden(5, not self.showPathCheckBox.isChecked())

        # Save the state of the checkbox
        settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
        settings.setValue("showPath", self.showPathCheckBox.isChecked())

    def showTypeAction(self):
        # Implement the logic to show/hide the Type column
        if hasattr(self, 'launcherTabs'):
            for i in range(self.launcherTabs.count()):
                launcherTable = self.launcherTabs.widget(i)
                launcherTable.setColumnHidden(3, not self.showTypeCheckbox.isChecked())

        # Save the state of the checkbox
        settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
        settings.setValue("showType", self.showTypeCheckbox.isChecked())

    def showParametersAction(self):
        # Implement the logic to show/hide the Parameters column
        if hasattr(self, 'launcherTabs'):
            for i in range(self.launcherTabs.count()):
                launcherTable = self.launcherTabs.widget(i)
                launcherTable.setColumnHidden(4, not self.showParametersCheckBox.isChecked())

        # Save the state of the checkbox
        settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
        settings.setValue("showParameters", self.showParametersCheckBox.isChecked())

    def loadCheckboxState(self):
        # Load the state of the checkboxes from the settings
        settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
        self.showPathCheckBox.setChecked(settings.value("showPath", True, type=bool))
        self.showTypeCheckbox.setChecked(settings.value("showType", True, type=bool))
        self.showParametersCheckBox.setChecked(settings.value("showParameters", True, type=bool))

        # Apply the loaded state to the table columns
        if hasattr(self, 'launcherTabs'):
            self.showPathAction()
            self.showTypeAction()
            self.showParametersAction()

    def addLauncherTab(self, launcher_id, launcher_name):
        try:
            launcherTable = QTableWidget(self)
            launcherTable.setColumnCount(7)
            launcherTable.setHorizontalHeaderLabels(["Order", "(X)", "Name", "Type", "Parameters", "Path", "Launch"])
            launcherTable.setSelectionBehavior(QAbstractItemView.SelectRows)
            launcherTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
            launcherTable.horizontalHeader().setStretchLastSection(True)
            launcherTable.verticalHeader().setVisible(False)
            launcherTable.setEditTriggers(QAbstractItemView.NoEditTriggers)
            launcherTable.setProperty("launcher_id", launcher_id)
            self.launcherTabs.addTab(launcherTable, launcher_name)
            self.loadLauncherItems(launcher_id, launcherTable)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred: {str(e)}")
            self.logError(f"Error: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error: {str(e)}")

    def loadLauncherItems(self, launcher_id, launcherTable):
        try:
            cursor = self.dbConnection.cursor()
            cursor.execute('SELECT id, launch_order, item_name, item_type, parameters, item_path, launch FROM launcher_items WHERE launcher_id = ? ORDER BY launch_order', (launcher_id,))
            items = cursor.fetchall()
            num_items = len(items)
            launcherTable.setRowCount(num_items)

            for row, item in enumerate(items):
                # Combo box for launch order
                orderComboBox = QComboBox()
                orderComboBox.addItems([str(i + 1) for i in range(num_items)])
                orderComboBox.setCurrentIndex(item[1] - 1)
                orderComboBox.currentIndexChanged.connect(lambda index, item_id=item[0], table=launcherTable: self.change_order(item_id, index + 1, table))
                launcherTable.setCellWidget(row, 0, orderComboBox)

                # Widget for checkbox to center it
                widget = QWidget()
                layout = QHBoxLayout(widget)
                layout.setAlignment(Qt.AlignCenter)
                layout.setContentsMargins(0, 0, 0, 0)
                launchCheckbox = QCheckBox()
                launchCheckbox.setChecked(bool(item[6]))
                layout.addWidget(launchCheckbox)
                widget.setLayout(layout)
                launcherTable.setCellWidget(row, 1, widget)
                launchCheckbox.stateChanged.connect(lambda state, item_id=item[0], table=launcherTable: self.change_launch(item_id, state == Qt.Checked, table))

                # Other item setups
                launcherTable.setItem(row, 2, QTableWidgetItem(item[2]))
                launcherTable.setItem(row, 3, QTableWidgetItem(item[3]))
                launcherTable.setItem(row, 4, QTableWidgetItem(item[4]))
                launcherTable.setItem(row, 5, QTableWidgetItem(item[5]))

                # Launch button
                launchButton = QPushButton("Launch")
                launchButton.clicked.connect(lambda _, r=row, table=launcherTable: self.launchItem(r, table))
                launcherTable.setCellWidget(row, 6, launchButton)

        except sqlite3.Error as e:
            QMessageBox.critical(self, "Error Loading Launcher Items", f"An error occurred while loading launcher items: {str(e)}")

    def change_order(self, item_id, new_order, launcherTable):
        try:
            # Update the database with the new order
            cursor = self.dbConnection.cursor()
            cursor.execute('UPDATE launcher_items SET launch_order = ? WHERE id = ?', (new_order, item_id))
            self.dbConnection.commit()

            # Refresh the items in the launcher table to reflect the updated order
            launcher_id = launcherTable.property("launcher_id")
            self.loadLauncherItems(launcher_id, launcherTable)
            QMessageBox.information(self, "Order Updated", f"Launch order for item ID {item_id} updated to {new_order}.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to update launch order: {str(e)}")

    def change_launch(self, item_id, launch, launcherTable):
        try:
            # Update the database with the new launch value
            cursor = self.dbConnection.cursor()
            cursor.execute('UPDATE launcher_items SET launch = ? WHERE id = ?', (int(launch), item_id))
            self.dbConnection.commit()
            self.loadLauncherItems(launcherTable.property("launcher_id"), launcherTable)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to update launch value: {str(e)}")

    def loadLauncherItems(self, launcher_id, launcherTable):
        try:
            cursor = self.dbConnection.cursor()
            cursor.execute('SELECT id, launch_order, item_name, item_type, parameters, item_path, launch FROM launcher_items WHERE launcher_id = ? ORDER BY launch_order', (launcher_id,))
            items = cursor.fetchall()
            num_items = len(items)
            launcherTable.setRowCount(num_items)

            for row, item in enumerate(items):
                # Combo box for launch order
                orderComboBox = QComboBox()
                orderComboBox.addItems([str(i + 1) for i in range(num_items)])
                orderComboBox.setCurrentIndex(item[1] - 1)
                orderComboBox.currentIndexChanged.connect(lambda index, item_id=item[0], table=launcherTable: self.change_order(item_id, index + 1, table))
                launcherTable.setCellWidget(row, 0, orderComboBox)

                # Widget for checkbox to center it
                widget = QWidget()
                layout = QHBoxLayout(widget)
                layout.setAlignment(Qt.AlignCenter)
                layout.setContentsMargins(0, 0, 0, 0)
                launchCheckbox = QCheckBox()
                launchCheckbox.setChecked(bool(item[6]))
                layout.addWidget(launchCheckbox)
                widget.setLayout(layout)
                launcherTable.setCellWidget(row, 1, widget)
                launchCheckbox.stateChanged.connect(lambda state, item_id=item[0], table=launcherTable: self.change_launch(item_id, state == Qt.Checked, table))

                # Other item setups
                launcherTable.setItem(row, 2, QTableWidgetItem(item[2]))
                launcherTable.setItem(row, 3, QTableWidgetItem(item[3]))
                launcherTable.setItem(row, 4, QTableWidgetItem(item[4]))
                launcherTable.setItem(row, 5, QTableWidgetItem(item[5]))

                # Launch button
                launchButton = QPushButton("Launch")
                launchButton.clicked.connect(lambda _, r=row, table=launcherTable: self.launchItem(r, table))
                launcherTable.setCellWidget(row, 6, launchButton)

        except sqlite3.Error as e:
            QMessageBox.critical(self, "Error Loading Launcher Items", f"An error occurred while loading launcher items: {str(e)}")

    def deleteLauncher(self):
        try:
            launcherTable = self.launcherTabs.currentWidget()
            launcher_id = launcherTable.property("launcher_id")
            launcher_name = self.launcherTabs.tabText(self.launcherTabs.currentIndex())

            confirm = QMessageBox.question(self, "Confirm Deletion", f"Are you sure you want to delete the '{launcher_name}' launcher?",
                                           QMessageBox.Yes | QMessageBox.No)
            if confirm == QMessageBox.Yes:
                cursor = self.dbConnection.cursor()
                cursor.execute('DELETE FROM launcher_items WHERE launcher_id = ?', (launcher_id,))
                cursor.execute('DELETE FROM launchers WHERE id = ?', (launcher_id,))
                self.dbConnection.commit()
                self.launcherTabs.removeTab(self.launcherTabs.currentIndex())
                self.showMessage(f"Launcher '{launcher_name}' deleted successfully.")
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Error", f"An error occurred: {str(e)}")
            self.logError(f"Error: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error: {str(e)}")

    def loadCommonApplications(self):
        try:
            common_apps = {
                "Empty": "",
                "Notepad": "C:\\Windows\\notepad.exe",
                "Calculator": "C:\\Windows\\System32\\calc.exe",
                "Paint": "C:\\Windows\\System32\\mspaint.exe",
                "Snipping Tool": "C:\\Windows\\System32\\SnippingTool.exe",
                "Sticky Notes": "C:\\Windows\\System32\\StikyNot.exe",
                "Microsoft Edge": "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe",
                "Windows Media Player": "C:\\Program Files\\Windows Media Player\\wmplayer.exe",
                "Windows Photo Viewer": "C:\\Windows\\System32\\rundll32.exe,StateFlags0100 C:\\Windows\\System32\\shimgvw.dll,ImageView_Fullscreen",
                "WordPad": "C:\\Program Files\\Windows NT\\Accessories\\wordpad.exe",
                "Microsoft Store": "C:\\Program Files\\WindowsApps\\Microsoft.WindowsStore_12097.1001.113.0_x64__8wekyb3d8bbwe\\Microsoft.WindowsStore.exe",
                "Microsoft Weather": "C:\\Program Files\\WindowsApps\\Microsoft.BingWeather_4.23.12121.0_x64__8wekyb3d8bbwe\\Microsoft.BingWeather.exe",
                "Microsoft Movies & TV": "C:\\Program Files\\WindowsApps\\Microsoft.ZuneVideo_10.21092.10011.0_x64__8wekyb3d8bbwe\\Microsoft.ZuneVideo.exe",
                "Groove Music": "C:\\Program Files\\WindowsApps\\Microsoft.ZuneMusic_10.21092.10011.0_x64__8wekyb3d8bbwe\\Microsoft.ZuneMusic.exe",
                "Cortana": "C:\\Windows\\SystemApps\\Microsoft.Windows.Cortana_cw5n1h2txyewy\\SearchUI.exe",
                "Microsoft Photos": "C:\\Program Files\\WindowsApps\\Microsoft.Windows.Photos_2022.31080.10011.0_x64__8wekyb3d8bbwe\\Microsoft.Photos.exe",
                "Microsoft To-Do": "C:\\Program Files\\WindowsApps\\Microsoft.Todos_2.57.32831.0_x64__8wekyb3d8bbwe\\Microsoft.Todos.exe",
                "Microsoft Solitaire Collection": "C:\\Program Files\\WindowsApps\\Microsoft.MicrosoftSolitaireCollection_4.4.8081.0_x64__8wekyb3d8bbwe\\Microsoft.MicrosoftSolitaireCollection.exe",
                "Microsoft Paint 3D": "C:\\Program Files\\WindowsApps\\Microsoft.MSPaint_2020.2103.9001.0_x64__8wekyb3d8bbwe\\PaintScript.exe",
                "Microsoft PowerPoint Viewer": "C:\\Program Files\\Microsoft Office\\root\\Office16\\POWERPNT.EXE",
                "Microsoft Excel Viewer": "C:\\Program Files\\Microsoft Office\\root\\Office16\\EXCEL.EXE",
                "Microsoft Word Viewer": "C:\\Program Files\\Microsoft Office\\root\\Office16\\WINWORD.EXE",
                "Microsoft Skype": "C:\\Program Files\\Microsoft Office\\root\\Office16\\lync.exe",
                "Microsoft Teams": "C:\\Program Files\\Microsoft Office\\root\\Office16\\teams.exe",
                "Microsoft Outlook": "C:\\Program Files\\Microsoft Office\\root\\Office16\\OUTLOOK.EXE",
                "Microsoft PowerPoint": "C:\\Program Files\\Microsoft Office\\root\\Office16\\POWERPNT.EXE",
                "Microsoft Excel": "C:\\Program Files\\Microsoft Office\\root\\Office16\\EXCEL.EXE",
                "Microsoft Word": "C:\\Program Files\\Microsoft Office\\root\\Office16\\WINWORD.EXE",
                "Windows Terminal": "C:\\Windows\\System32\\wt.exe",
                "Remote Desktop Connection": "C:\\Windows\\System32\\mstsc.exe",
                "Windows Fax and Scan": "C:\\Windows\\System32\\wfs.exe",
                "Windows Media Center": "C:\\Windows\\ehome\\ehshell.exe",
                "Windows PowerShell": "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe",
                "Windows Store": "C:\\Program Files\\WindowsApps\\Microsoft.WindowsStore_11811.1001.4.0_x64__8wekyb3d8bbwe\\WindowsStore.exe",
                "Windows Task Manager": "C:\\Windows\\System32\\Taskmgr.exe",
                "Windows Command Prompt": "C:\\Windows\\System32\\cmd.exe",
                "Windows Calendar": "C:\\Program Files\\WindowsApps\\Microsoft.WindowsCalculator_11.2302.6.0_x64__8wekyb3d8bbwe\\Calculator.exe",
                "Windows Clock": "C:\\Windows\\System32\\w32tm.exe",
                "Windows Defender Security Center": "C:\\Windows\\System32\\securitycentericon.exe",
                "Windows File Explorer": "C:\\Windows\\explorer.exe",
                "Windows Maps": "C:\\Program Files\\WindowsApps\\Microsoft.WindowsMaps_2023.21040.1.0_x64__8wekyb3d8bbwe\\Microsoft.WindowsMaps.exe",
                "Windows Settings": "C:\\Windows\\ImmersiveControlPanel\\SystemSettings.exe",
                "Windows Snipping Tool": "C:\\Windows\\System32\\SnippingTool.exe",
                "Windows Sticky Notes": "C:\\Windows\\System32\\StikyNot.exe",
                "Windows 3D Viewer": "C:\\Program Files\\WindowsApps\\Microsoft.Microsoft3DViewer_5.2301.5001.0_x64__8wekyb3d8bbwe\\Microsoft.Microsoft3DViewer.exe",
                "Windows Voice Recorder": "C:\\Windows\\System32\\SoundRecorder.exe",
                "Windows Store Apps": "C:\\Program Files\\WindowsApps\\*",
                "Empty": ""
            }
            self.commonAppDropdown.clear()
            for app_name, app_path in common_apps.items():
                self.commonAppDropdown.addItem(app_name, app_path)
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred: {str(e)}")
            self.logError(f"Error: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error: {str(e)}")

    def fillCommonApp(self, app_name):
        app_path = self.commonAppDropdown.currentData()
        if app_path:
            self.itemNameEdit.setText(app_name)
            self.itemPathEdit.setText(app_path)
            self.itemTypeDropdown.setCurrentText("Program")
        else:
            self.itemNameEdit.clear()
            self.itemPathEdit.clear()
            self.itemTypeDropdown.setCurrentText("Website")

    def itemTypeChanged(self, itemType):
        if itemType == "Program":
            self.itemPathLabel.setText("Item Path:")
            self.itemPathEdit.show()
            self.itemPathButton.show()
            self.parametersEdit.show()
            self.parametersLabel.setEnabled(True)
            self.parametersEdit.setEnabled(True)  # Properly enable the parametersEdit
            self.commonAppDropdown.show()
        elif itemType == "Website":
            self.itemPathLabel.setText("Web Address:")
            self.commonAppDropdown.hide()
            self.itemPathEdit.show()
            self.itemPathButton.hide()
            self.parametersEdit.hide()
            self.parametersEdit.setEnabled(False)  # Properly disable the parametersEdit
            self.parametersLabel.setEnabled(False)
            self.itemPathEdit.clear()

    def browseItemPath(self):
        if self.itemTypeDropdown.currentText() == "Program":
            itemPath = QFileDialog.getOpenFileName(self, "Select Program", "", "Executable Files (*.exe)")[0]
            if itemPath:
                self.itemPathEdit.setText(itemPath)

    def validatePath(self):
        itemPath = self.itemPathEdit.text()
        if itemPath:
            if not os.path.exists(itemPath):
                self.itemPathEdit.setStyleSheet("border: 1px solid red;")
            else:
                self.itemPathEdit.setStyleSheet("")

    def tabDragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def tabDropEvent(self, event):
        launcher_id = self.launcherTabs.currentWidget().property("launcher_id")
        for url in event.mimeData().urls():
            file_path = url.toLocalFile()
            file_name = os.path.basename(file_path)
            file_ext = os.path.splitext(file_name)[1].lower()
            if file_ext == ".exe":
                item_type = "Program"
            else:
                item_type = "Website"
            cursor = self.dbConnection.cursor()
            cursor.execute('INSERT INTO launcher_items (launcher_id, item_name, item_type, item_path, parameters, launch_order) VALUES (?, ?, ?, ?, ?, ?)',
                           (launcher_id, file_name, item_type, file_path, "", self.launcherTabs.currentWidget().rowCount() + 1))
            self.dbConnection.commit()
        self.loadLauncherItems(launcher_id, self.launcherTabs.currentWidget())
        event.acceptProposedAction()

    def filterItems(self, text):
        try:
            for i in range(self.launcherTabs.count()):
                launcherTable = self.launcherTabs.widget(i)
                for j in range(launcherTable.rowCount()):
                    item = launcherTable.item(j, 1)  # Make sure this is the correct column index
                    if item is not None:
                        item.setBackground(QBrush())  # Reset background for all items first
                        if text.lower() in item.text().lower():
                            item.setBackground(QColor("yellow"))  # Highlight matching items
                    else:
                        # If the item is None, create and set a new QTableWidgetItem if needed
                        new_item = QTableWidgetItem()
                        launcherTable.setItem(j, 2, new_item)  # Assuming column 1 should have an item
                        new_item.setBackground(QBrush())
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred: {str(e)}")
            self.logError(f"Error: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error: {str(e)}")

    def scheduleItem(self):
        launcherTable = self.launcherTabs.currentWidget()
        selectedRows = launcherTable.selectionModel().selectedRows()
        if selectedRows:
            row = selectedRows[0].row()
            itemName = launcherTable.item(row, 1).text()
            itemType = launcherTable.item(row, 2).text()
            itemPath = launcherTable.item(row, 3).text()
            parameters = launcherTable.item(row, 4).text()
            schedulerDialog = SchedulerDialog(itemName, itemType, itemPath, parameters)
            if schedulerDialog.exec_() == QDialog.Accepted:
                schedule = schedulerDialog.getSchedule()
                self.scheduler.schedule_task(itemName, itemPath, parameters, schedule)
                self.showMessage(f"Item '{itemName}' scheduled successfully.")
        else:
            QMessageBox.warning(self, "No Selection", "Please select an item to schedule.")

    def logActivity(self, item_name, message):
        try:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            cursor = self.dbConnection.cursor()
            cursor.execute('INSERT INTO activity_log (timestamp, item_name, message) VALUES (?, ?, ?)',
                           (timestamp, item_name, message))
            self.dbConnection.commit()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred: {str(e)}")
            self.logError(f"Error: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error: {str(e)}")

    def onTaskCompleted(self, item_name):
        self.showMessage(f"Task '{item_name}' completed successfully.")

    def onTaskFailed(self, item_name, error_message):
        self.showMessage(f"Task '{item_name}' failed: {error_message}")

    def showMessage(self, message):
        if not self.note_maker_instance.get_toggle_mode():
            QMessageBox.information(self, "Information", message)

    def logMessage(self, message):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"{timestamp} - {message}\n"
        with open("launcher_log.txt", "a") as log_file:
            log_file.write(log_entry)

    def logError(self, error_message):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"{timestamp} - ERROR: {error_message}\n"
        with open("launcher_log.txt", "a") as log_file:
            log_file.write(log_entry)
            
    def addLauncherItem(self):
        try:
            current_tab = self.launcherTabs.currentWidget()
            if current_tab is not None:
                launcher_id = current_tab.property("launcher_id")
                itemName = self.itemNameEdit.text()
                itemType = self.itemTypeDropdown.currentText()
                itemPath = self.itemPathEdit.text()
                parameters = self.parametersEdit.text()

                if itemName and (itemType == "Website" or (itemType == "Program" and os.path.exists(itemPath))):
                    cursor = self.dbConnection.cursor()
                    cursor.execute('INSERT INTO launcher_items (launcher_id, item_name, item_type, item_path, parameters, launch_order) VALUES (?, ?, ?, ?, ?, ?)',
                                   (launcher_id, itemName, itemType, itemPath, parameters, current_tab.rowCount() + 1))
                    self.dbConnection.commit()
                    self.loadLauncherItems(launcher_id, current_tab)
                    self.itemNameEdit.clear()
                    self.itemPathEdit.clear()
                    self.parametersEdit.clear()
                    self.showMessage("Item added successfully.")
                else:
                    QMessageBox.warning(self, "Invalid Input", "Please enter a valid item name and path/URL.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred: {str(e)}")
            self.logError(f"Error: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error: {str(e)}")

    def addLauncher(self):
        try:
            launcherName, ok = QInputDialog.getText(self, "Add Launcher", "Enter launcher name:")
            if ok and launcherName.strip():
                cursor = self.dbConnection.cursor()
                cursor.execute('INSERT INTO launchers (launcher_name) VALUES (?)', (launcherName.strip(),))
                launcher_id = cursor.lastrowid
                self.dbConnection.commit()
                self.addLauncherTab(launcher_id, launcherName.strip())
                self.showMessage("Launcher added successfully.")
            elif ok and not launcherName.strip():
                QMessageBox.warning(self, "Invalid Launcher Name", "Launcher name cannot be empty.")
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Error", f"An error occurred: {str(e)}")
            self.logError(f"Error: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error: {str(e)}")

    def editLauncherItem(self):
        try:
            launcherTable = self.launcherTabs.currentWidget()
            if launcherTable is not None:
                selected_rows = launcherTable.selectionModel().selectedRows()
                if selected_rows:
                    row = selected_rows[0].row()
                    launcher_id = launcherTable.property("launcher_id")
                    item_name = launcherTable.item(row, 2).text()
                    item_type = launcherTable.item(row, 3).text()
                    parameters = launcherTable.item(row, 4).text()
                    item_path = launcherTable.item(row, 5).text()

                    dialog = QDialog(self)
                    dialog.setWindowTitle(f"Edit Launcher Item: {item_name}")
                    layout = QVBoxLayout(dialog)

                    item_name_layout = QHBoxLayout()
                    item_name_label = QLabel("Item Name:")
                    self.item_name_edit = QLineEdit(item_name)
                    item_name_layout.addWidget(item_name_label)
                    item_name_layout.addWidget(self.item_name_edit)
                    layout.addLayout(item_name_layout)

                    item_type_layout = QHBoxLayout()
                    item_type_label = QLabel("Item Type:")
                    self.item_type_dropdown = QComboBox()
                    self.item_type_dropdown.addItems(["Website", "Program"])
                    self.item_type_dropdown.setCurrentText(item_type)
                    item_type_layout.addWidget(item_type_label)
                    item_type_layout.addWidget(self.item_type_dropdown)
                    layout.addLayout(item_type_layout)

                    item_path_layout = QHBoxLayout()
                    item_path_label = QLabel("Item Path:")
                    self.item_path_edit = QLineEdit(item_path)
                    self.item_path_button = QPushButton("Browse")
                    self.item_path_button.clicked.connect(self.browseItemPath)
                    item_path_layout.addWidget(item_path_label)
                    item_path_layout.addWidget(self.item_path_edit)
                    item_path_layout.addWidget(self.item_path_button)
                    layout.addLayout(item_path_layout)

                    parameters_layout = QHBoxLayout()
                    parameters_label = QLabel("Parameters:")
                    self.parameters_edit = QLineEdit(parameters)
                    parameters_layout.addWidget(parameters_label)
                    parameters_layout.addWidget(self.parameters_edit)
                    layout.addLayout(parameters_layout)

                    button_layout = QHBoxLayout()
                    save_button = QPushButton("Save")
                    save_button.clicked.connect(lambda: self.updateLauncherItem(launcher_id, item_name, item_type, item_path, parameters, dialog))
                    cancel_button = QPushButton("Cancel")
                    cancel_button.clicked.connect(dialog.reject)
                    button_layout.addWidget(save_button)
                    button_layout.addWidget(cancel_button)
                    layout.addLayout(button_layout)

                    dialog.exec_()
                else:
                    QMessageBox.warning(self, "No Selection", "Please select an item to edit.")
            else:
                QMessageBox.warning(self, "No Launcher Tab", "Please select a launcher tab to edit the item.")
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Error", f"An error occurred while editing the launcher item: {str(e)}")
            self.logError(f"Error editing launcher item: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error editing launcher item: {str(e)}")

    def deleteLauncherItem(self):
        try:
            launcherTable = self.launcherTabs.currentWidget()
            selected_rows = launcherTable.selectionModel().selectedRows()
            if selected_rows:
                row = selected_rows[0].row()
                item_name = launcherTable.item(row, 2).text() if launcherTable.item(row, 2) else ""
                item_type = launcherTable.item(row, 3).text() if launcherTable.item(row, 3) else ""
                parameters = launcherTable.item(row, 4).text() if launcherTable.item(row, 4) else ""
                item_path = launcherTable.item(row, 5).text() if launcherTable.item(row, 5) else ""

                confirm = QMessageBox.question(self, "Confirm Deletion", f"Are you sure you want to delete the item: {item_name}?",
                                               QMessageBox.Yes | QMessageBox.No)
                if confirm == QMessageBox.Yes:
                    cursor = self.dbConnection.cursor()
                    cursor.execute('DELETE FROM launcher_items WHERE item_name = ? AND item_type = ? AND parameters = ? AND item_path = ?',
                                   (item_name, item_type, parameters, item_path))
                    self.dbConnection.commit()
                    self.loadLauncherItems(launcherTable.property("launcher_id"), launcherTable)
                    QMessageBox.information(self, "Item Deleted", "The item was deleted successfully.")
                else:
                    QMessageBox.information(self, "Deletion Cancelled", "Item deletion was cancelled.")
            else:
                QMessageBox.warning(self, "No Selection", "Please select an item to delete.")
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Error", f"An error occurred while deleting the launcher item: {str(e)}")

    def updateLauncherItem(self, launcher_id, item_name, item_type, item_path, parameters, dialog):
        try:
            cursor = self.dbConnection.cursor()
            cursor.execute('UPDATE launcher_items SET item_name = ?, item_type = ?, item_path = ?, parameters = ? WHERE item_name = ? AND item_type = ? AND item_path = ? AND parameters = ? AND launcher_id = ?',
                           (self.item_name_edit.text(), self.item_type_dropdown.currentText(), self.item_path_edit.text(), self.parameters_edit.text(), item_name, item_type, item_path, parameters, launcher_id))
            self.dbConnection.commit()
            self.loadLauncherItems(launcher_id, self.launcherTabs.currentWidget())
            dialog.accept()
            QMessageBox.information(self, "Item Updated", "The item was updated successfully.")
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Error", f"An error occurred while updating the launcher item: {str(e)}")
            self.logError(f"Error updating launcher item: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error updating launcher item: {str(e)}")
                
    def isItemRemoved(self, launcher_id, item_id):
        try:
            cursor = self.dbConnection.cursor()
            cursor.execute('SELECT COUNT(*) FROM launcher_items WHERE id = ? AND launcher_id = ?', (item_id, launcher_id))
            count = cursor.fetchone()[0]
            return count == 0
        except Exception as e:
            self.logError(f"Error checking if item is removed: {str(e)}")
            if debug_mode:
                QMessageBox.information(self, "Debug", f"Error checking if item is removed: {str(e)}")
            return False

    def launchItem(self, row, launcherTable):
        try:
            item_type = launcherTable.item(row, 3).text()  # Type from the fourth column
            item_path = launcherTable.item(row, 5).text()  # Path from the sixth column
            parameters = launcherTable.item(row, 4).text()  # Parameters from the fifth column

            print(f"Launching: {item_path}")
            print(f"With parameters: {parameters}")

            if item_type == "Program":
                command = [item_path] + parameters.split() if parameters else [item_path]
                subprocess.Popen(command, shell=True)
            elif item_type == "Website":
                # Opens a website in a new tab
                if self.selected_browser_path and self.selected_browser_name:
                    self.launch_urls_with_selected_browser([item_path], new_window=False)  # Single URL in a list, new_window=False
                else:
                    QMessageBox.critical(self, "Launch Error", "Browser not found or not selected.")

        except Exception as e:
            logging.error("Failed to launch item: %s", e)
            QMessageBox.critical(self, "Launch Error", f"Failed to launch item: {e}")

    def launchSelectedItems(self):
        try:
            current_tab = self.launcherTabs.currentWidget()
            if current_tab is None:
                QMessageBox.critical(self, "Error", "No active tab selected.")
                return

            # Collect all selected items
            selected_items = []
            for row in range(current_tab.rowCount()):
                checkbox_widget = current_tab.cellWidget(row, 1)
                if checkbox_widget and checkbox_widget.findChild(QCheckBox).isChecked():
                    dropdown_value = int(current_tab.cellWidget(row, 0).currentText())
                    item_type = current_tab.item(row, 3).text()
                    item_path = current_tab.item(row, 5).text()
                    parameters = current_tab.item(row, 4).text()
                    selected_items.append((dropdown_value, row, item_type, item_path, parameters))

            # Sort items by dropdown value and row index
            selected_items.sort()

            # Group items by their dropdown value
            grouped_items = {}
            for item in selected_items:
                dropdown_value = item[0]
                if dropdown_value not in grouped_items:
                    grouped_items[dropdown_value] = []
                grouped_items[dropdown_value].append(item)

            # Debugging output
            if debug_mode:
                for group, items in grouped_items.items():
                    QMessageBox.information(self, "Debug Group Info", f"Group {group}: {[(i[2], i[3]) for i in items]}")

            # Launch grouped items with a delay
            delay_seconds = 1  # Set the delay time in seconds
            for group in sorted(grouped_items.keys()):
                first = True
                for _, _, item_type, item_path, parameters in grouped_items[group]:
                    if item_type == "Program":
                        self.launchProgram(item_path, parameters)
                    elif item_type == "Website":
                        if first:
                            self.launch_url_in_browser(item_path, new_window=True)
                            first = False
                        else:
                            self.launch_url_in_browser(item_path, new_window=False)
                    time.sleep(delay_seconds)  # Delay before launching the next item

        except Exception as e:
            logging.error("Failed to launch selected items: %s", e)
            QMessageBox.critical(self, "Launch Error", f"Failed to launch items: {str(e)}")

    def launchProgram(self, item_path, parameters):
        try:
            command = [item_path] + parameters.split() if parameters else [item_path]
            subprocess.Popen(command, shell=True)
        except Exception as e:
            logging.error("Failed to launch program: %s", e)
            QMessageBox.critical(self, "Launch Error", f"Failed to launch program: {str(e)}")

    def launch_url_in_browser(self, url, new_window=True):
        try:
            if self.selected_browser_path and self.selected_browser_name:
                command = [self.selected_browser_path]
                if new_window:
                    command.extend(["--new-window", url])
                else:
                    command.extend(["--new-tab", url])
                subprocess.Popen(command, shell=True)
            else:
                QMessageBox.critical(self, "Launch Error", "Browser not found or not selected.")
        except Exception as e:
            logging.error("Failed to launch URL in browser: %s", e)
            QMessageBox.critical(self, "Launch Error", f"Failed to launch URL: {str(e)}")

    def launch_urls_with_selected_browser(self, urls, new_window=True):
        if self.selected_browser_path and self.selected_browser_name:
            if self.selected_browser_name == "Firefox":
                command = [self.selected_browser_path]
                if new_window:
                    command.append('-new-window')
                command.extend(urls)  # Adding all URLs to the command list
                subprocess.Popen(command, shell=True)
            elif self.selected_browser_name == "Internet Explorer":
                command = [self.selected_browser_path]
                if new_window:
                    command.append("--new-window")
                command.extend(urls)
                subprocess.Popen(command, shell=True)
            else:
                # Handling for Chrome, Edge, and others
                browser_commands = {
                    "Chrome": ["--new-window"] if new_window else [],
                    "Edge": ["--new-window"] if new_window else [],
                    "Opera": ["--new-window"] if new_window else [],
                    "Safari": []
                }

                command = [self.selected_browser_path] + browser_commands.get(self.selected_browser_name, [])
                command.extend(urls)  # Adding all URLs to the command list

                subprocess.Popen(command, shell=True)
        else:
            QMessageBox.critical(self, "Launch Error", "Browser not found or not selected.")

    def openBrowserSelector(self):
        if not hasattr(self, 'browser_selector'):
            self.browser_selector = BrowserSelector(theme=self.parent.themes[self.parent.current_theme])
        self.browser_selector.show()

    def onTaskCompleted(self, item_name):
        self.showMessage(f"Task '{item_name}' completed successfully.")

    def onTaskFailed(self, item_name, error_message):
        self.showMessage(f"Task '{item_name}' failed: {error_message}")

class BrowserSelector(QWidget):
    browserChanged = pyqtSignal(str, str)
    def __init__(self, parent=None, theme=None):
        super().__init__(parent)
        self.setWindowTitle("TSTP:Omni Omega - Browser Selection")
        if theme:
            self.setStyleSheet(theme)
        self.settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
        self.browser_settings_path = "browser_settings.json"
        self.initUI()
        self.load_saved_browser()

    def initUI(self):
        layout = QVBoxLayout(self)

        self.browser_combo = QComboBox(self)
        self.detected_browsers = self.detect_browsers()
        self.browser_combo.addItems(sorted(self.detected_browsers.keys()))

        browser_path_label = QLabel("Custom Browser Path:")
        layout.addWidget(browser_path_label)
        self.custom_browser_input = QLineEdit(self)
        self.custom_browser_input.setPlaceholderText("Enter custom browser path")
        browse_button = QPushButton("Browse", self)
        browse_button.clicked.connect(self.browse_folder)
        browser_path_layout = QHBoxLayout()
        browser_path_layout.addWidget(self.custom_browser_input)
        browser_path_layout.addWidget(browse_button)
        layout.addLayout(browser_path_layout)

        self.run_mode_combo = QComboBox(self)
        self.run_mode_combo.addItems(["Normal", "Incognito"])

        self.test_button = QPushButton("Test Browser", self)
        self.test_button.clicked.connect(self.run_browser)

        self.save_button = QPushButton("Save Browser", self)
        self.save_button.clicked.connect(self.save_selected_browser)

        layout.addWidget(QLabel("Select Browser:"))
        layout.addWidget(self.browser_combo)
        layout.addWidget(QLabel("Run Mode:"))
        layout.addWidget(self.run_mode_combo)
        layout.addWidget(self.test_button)
        layout.addWidget(self.save_button)
        
        self.browser_combo.currentIndexChanged.connect(self.browser_combo_changed)
        
        self.setLayout(layout)
        self.show()

    def load_saved_browser(self):
        saved_browser_path = self.settings.value("browser_path")
        if saved_browser_path:
            for i, browser in enumerate(self.detected_browsers.keys()):
                if self.detected_browsers[browser] == saved_browser_path:
                    self.browser_combo.setCurrentIndex(i)
                    break

    def browse_folder(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "Select Browser Executable", "", "Executable Files (*.exe)")
        if file_path:
            self.custom_browser_input.setText(file_path)

    def run_browser(self):
        browser_path = self.custom_browser_input.text().strip() or self.get_selected_browser_path()
        if browser_path and os.path.exists(browser_path):
            run_mode = self.get_run_mode()
            browser_name = self.get_selected_browser()

            # Define the command-line arguments for each browser
            browser_commands = {
                "Chrome": [browser_path, "--new-window"],
                "Firefox": [browser_path, "-new-window"],
                "Edge": [browser_path, "--new-window"],
                "Opera": [browser_path, "--new-window"],
                "Safari": [browser_path],
                "Internet Explorer": [browser_path, "-new"]
            }

            command = browser_commands.get(browser_name, [browser_path])
            if run_mode == "incognito":
                incognito_flags = {
                    "chrome": "--incognito",
                    "firefox": "-private-window",
                    "edge": "--inprivate",
                    "opera": "--private",
                    "safari": "-private",
                    "internet explorer": "-private"
                }
                incognito_flag = incognito_flags.get(browser_name.lower(), "")
                if incognito_flag:
                    command.append(incognito_flag)

            subprocess.Popen(command, shell=True)
        else:
            QMessageBox.information(self, "Error", "Browser executable not found.")

    def save_selected_browser(self):
        browser_path = self.custom_browser_input.text().strip() or self.get_selected_browser_path()
        browser_name = self.get_selected_browser()

        if browser_path and os.path.exists(browser_path):
            self.settings.setValue("browser_path", browser_path)
            self.settings.setValue("browser_name", browser_name)
            QMessageBox.information(self, "Success", "Browser path saved successfully.")
            self.close()  # Close the window after saving
        else:
            QMessageBox.warning(self, "Error", "Invalid browser path.")

    def detect_browsers(self):
        browser_paths = {
            "Chrome": [
                "C:/Program Files/Google/Chrome/Application/chrome.exe",
                "C:/Program Files (x86)/Google/Chrome/Application/chrome.exe"
            ],
            "Firefox": [
                "C:/Program Files/Mozilla Firefox/firefox.exe",
                "C:/Program Files (x86)/Mozilla Firefox/firefox.exe"
            ],
            "Edge": [
                "C:/Program Files (x86)/Microsoft/Edge/Application/msedge.exe",
                "C:/Program Files/Microsoft/Edge/Application/msedge.exe"
            ],
            "Opera": [
                "C:/Program Files/Opera/Opera.exe",
                "C:/Program Files (x86)/Opera/Opera.exe"
            ],
            "Safari": [
                "C:/Program Files/Safari/Safari.exe",
                "C:/Program Files (x86)/Safari/Safari.exe"
            ],
            "Internet Explorer": [
                "C:/Program Files/Internet Explorer/iexplore.exe",
                "C:/Program Files (x86)/Internet Explorer/iexplore.exe"
            ]
        }

        # Dynamic additional paths for Opera
        additional_paths = [
            os.path.join(os.getenv('LOCALAPPDATA'), "Programs/Opera/Opera.exe"),
            os.path.join(os.getenv('ALLUSERSPROFILE'), "Programs/Opera/Opera.exe")
        ]

        installed_browsers = {}

        # Check default paths for all browsers
        for browser, paths in browser_paths.items():
            for path in paths:
                if os.path.exists(path):
                    installed_browsers[browser] = path
                    break  # Assumes the first found path is the correct one

        # Check additional paths for Opera
        for path in additional_paths:
            if os.path.exists(path):
                installed_browsers["Opera"] = path
                break

        return installed_browsers

    def get_selected_browser_path(self):
        selected_browser = self.browser_combo.currentText()
        return self.detected_browsers.get(selected_browser, None)

    def get_selected_browser(self):
        return self.browser_combo.currentText()

    def get_run_mode(self):
        return self.run_mode_combo.currentText().lower()

    def browser_combo_changed(self, index):
        selected_browser = self.browser_combo.currentText()
        selected_browser_path = self.detected_browsers.get(selected_browser, None)
        self.browserChanged.emit(selected_browser_path, selected_browser)

class EditScheduleDialog(QDialog):
    def __init__(self, schedule_info, parent=None):
        super().__init__(parent)
        self.schedule_info = schedule_info  # Save original schedule info for fallback
        self.setup_ui(schedule_info)

    def setup_ui(self, schedule_info):
        layout = QVBoxLayout(self)
        self.setWindowTitle("Edit Schedule")

        # Item information
        item_info_layout = QHBoxLayout()
        item_info_layout.addWidget(QLabel("Item Name:"))
        self.item_name_edit = QLineEdit(schedule_info["item_name"])
        item_info_layout.addWidget(self.item_name_edit)
        item_info_layout.addWidget(QLabel("Item Type:"))
        self.item_type_edit = QLineEdit(schedule_info["item_type"])
        item_info_layout.addWidget(self.item_type_edit)
        layout.addLayout(item_info_layout)

        # Time format selection
        time_format_layout = QHBoxLayout()
        time_format_layout.addWidget(QLabel("Time Format:"))
        self.formatCombo = QComboBox(self)
        self.formatCombo.addItems(["12-hour", "24-hour"])
        self.formatCombo.currentIndexChanged.connect(self.update_time_format)
        time_format_layout.addWidget(self.formatCombo)
        layout.addLayout(time_format_layout)

        # Time and date setting
        time_date_layout = QHBoxLayout()
        self.timeEdit = QTimeEdit(self)
        self.timeEdit.setTime(QTime.fromString(schedule_info["time"], "hh:mm AP"))
        time_date_layout.addWidget(self.timeEdit)

        if "date" in schedule_info:
            self.dateEdit = QDateEdit(self)
            self.dateEdit.setDate(schedule_info["date"])
            time_date_layout.addWidget(self.dateEdit)
        layout.addLayout(time_date_layout)

        # Day of week checkboxes
        daysLayout = QHBoxLayout()
        self.dayChecks = {}
        for day in ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]:
            checkbox = QCheckBox(day, self)
            checkbox.setChecked(day in schedule_info["days"])
            self.dayChecks[day] = checkbox
            daysLayout.addWidget(checkbox)
        layout.addLayout(daysLayout)

        # Buttons for dialog control
        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttonBox.accepted.connect(self.validate_inputs)
        buttonBox.rejected.connect(self.reject)
        layout.addWidget(buttonBox)

    def update_time_format(self, index):
        format = self.formatCombo.currentText()
        if format == "24-hour":
            self.timeEdit.setDisplayFormat("HH:mm")
        else:
            self.timeEdit.setDisplayFormat("hh:mm AP")

    def validate_inputs(self):
        # Validate the inputs before closing the dialog
        item_name = self.item_name_edit.text().strip()
        item_type = self.item_type_edit.text().strip()
        if not item_name or not item_type:
            QMessageBox.warning(self, "Validation Error", "Item name and type cannot be empty.")
            return

        # If validation is successful
        self.accept()

    def get_schedule_info(self):
        days_selected = [day for day, checkbox in self.dayChecks.items() if checkbox.isChecked()]
        time = self.timeEdit.time().toString("HH:mm" if self.formatCombo.currentText() == "24-hour" else "hh:mm AP")
        date = self.dateEdit.date().toPyDate() if hasattr(self, "dateEdit") else None
        item_name = self.item_name_edit.text().strip()
        item_type = self.item_type_edit.text().strip()
        return {"days": days_selected, "time": time, "date": date, "item_name": item_name, "item_type": item_type}

class SchedulerDialog(QDialog):
    def __init__(self, item_name, item_type, item_path, db_manager=None, theme=None, schedule_info_list=None):
        super().__init__()
        self.item_name = item_name
        self.item_type = item_type
        self.item_path = item_path
        self.db_manager = db_manager
        self.schedule_info_list = schedule_info_list or []
        self.theme = theme
        self.setup_ui()


    def setup_ui(self):
        self.setStyleSheet(self.theme)
        layout = QVBoxLayout(self)

        if self.schedule_info_list:
            item_name = self.schedule_info_list[0]["item_name"]
            self.setWindowTitle(f"Schedule Tasks - {item_name}")
        else:
            self.setWindowTitle("Schedule Tasks")

        # Item name label
        if self.schedule_info_list:
            item_name = self.schedule_info_list[0]["item_name"]
            item_name_label = QLabel(f"Item: {item_name}")
            layout.addWidget(item_name_label)

        # Time and date setting
        time_date_layout = QHBoxLayout()
        self.hourCombo = QSpinBox(self)
        self.hourCombo.setRange(0, 23)
        self.minuteCombo = QSpinBox(self)
        self.minuteCombo.setRange(0, 59)
        self.ampmCombo = QComboBox(self)
        self.ampmCombo.addItems(["AM", "PM"])
        time_layout = QHBoxLayout()
        time_layout.addWidget(self.hourCombo)
        time_layout.addWidget(QLabel(":"))
        time_layout.addWidget(self.minuteCombo)
        time_layout.addWidget(self.ampmCombo)
        time_date_layout.addLayout(time_layout)

        self.dateEdit = QDateEdit(self)
        self.dateEdit.setDate(QDate.currentDate())
        time_date_layout.addWidget(self.dateEdit)
        layout.addLayout(time_date_layout)

        # Day of week selection
        self.day_selector_combo = QComboBox(self)
        self.day_selector_combo.addItems(["All Days", "Weekdays", "Weekends", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"])
        layout.addWidget(QLabel("Select Days:"))
        layout.addWidget(self.day_selector_combo)

        # Buttons for dialog control
        button_layout = QHBoxLayout()
        self.addButton = QPushButton("Add Schedule", self)
        self.addButton.clicked.connect(self.add_schedule)
        self.addButton.setEnabled(True)  # Enable the button initially
        button_layout.addWidget(self.addButton)

        clear_button = QPushButton("Clear", self)
        clear_button.clicked.connect(self.clear_inputs)
        button_layout.addWidget(clear_button)

        close_button = QPushButton("Close", self)
        close_button.clicked.connect(self.reject)
        button_layout.addWidget(close_button)

        show_schedule_button = QPushButton("Show Schedule", self)
        show_schedule_button.clicked.connect(self.show_schedule_window)
        button_layout.addWidget(show_schedule_button)

        layout.addLayout(button_layout)

        # Validate inputs on changes
        self.hourCombo.valueChanged.connect(self.validate_inputs)
        self.minuteCombo.valueChanged.connect(self.validate_inputs)
        self.ampmCombo.currentTextChanged.connect(self.validate_inputs)
        self.dateEdit.dateChanged.connect(self.validate_inputs)
        self.day_selector_combo.currentIndexChanged.connect(self.validate_inputs)

    def update_time_format(self, format):
        if format == "24-hour":
            self.timeEdit.setDisplayFormat("HH:mm")
        else:
            self.timeEdit.setDisplayFormat("hh:mm AP")

    def get_schedule(self):
        try:
            hours = self.hourCombo.value()
            minutes = self.minuteCombo.value()
            ampm = self.ampmCombo.currentText()
            if ampm == "PM" and hours < 12:
                hours += 12
            elif ampm == "AM" and hours == 12:
                hours = 0
            schedule_time = QTime(hours, minutes)
            schedule_date = self.dateEdit.date().toPyDate()
            selected_day = self.day_selector_combo.currentText()

            if selected_day == "All Days":
                days_selected = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
            elif selected_day == "Weekdays":
                days_selected = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
            elif selected_day == "Weekends":
                days_selected = ["Saturday", "Sunday"]
            else:
                days_selected = [selected_day]

            if not days_selected:
                raise ValueError("At least one day must be selected.")

            return {
                "days": days_selected,
                "time": schedule_time.toString("HH:mm"),
                "date": schedule_date
            }
        except ValueError as e:
            QMessageBox.warning(self, "Invalid Input", str(e))
            return None

    def add_schedule(self):
        schedule_info = self.get_schedule()
        if schedule_info:
            confirm_dialog = QMessageBox.question(
                self, "Confirm Schedule",
                f"Are you sure you want to add the following schedule?\n\n"
                f"Time: {schedule_info['time']}\n"
                f"Date: {schedule_info['date'].strftime('%Y-%m-%d')}\n"
                f"Days: {', '.join(schedule_info['days'])}",
                QMessageBox.Yes | QMessageBox.No
            )

            if confirm_dialog == QMessageBox.Yes:
                for item_info in self.schedule_info_list:
                    self.db_manager.add_schedule({
                        "item_name": item_info["item_name"],
                        "item_type": item_info["item_type"],
                        "item_path": item_info["item_path"],
                        "parameters": item_info["parameters"],
                        "days": schedule_info["days"],
                        "time": schedule_info["time"],
                        "date": schedule_info["date"]
                    })
                self.parent().scheduler.load_scheduled_tasks()  # Add this line
                self.accept()
            else:
                QMessageBox.information(self, "Schedule Canceled", "The schedule was not added.")

    def validate_inputs(self):
        # Enable the "Add Schedule" button only if all inputs are valid
        self.addButton.setEnabled(True)

    def clear_inputs(self):
        self.hourCombo.setCurrentIndex(0)
        self.minuteCombo.setCurrentIndex(0)
        self.ampmCombo.setCurrentIndex(0)
        self.dateEdit.setDate(QDate.currentDate())
        self.day_selector_combo.setCurrentIndex(0)

    def show_schedule_window(self):
        self.schedule_window = ScheduleWindow(self.db_manager, self.theme)
        self.schedule_window.show()

    def load_schedules(self):
        self.scheduleTable.setRowCount(0)
        schedules = self.db_manager.get_schedules()
        for schedule in schedules:
            self.add_schedule_to_table(schedule)

    def add_schedule_to_table(self, schedule):
        try:
            row = self.scheduleTable.rowCount()
            self.scheduleTable.insertRow(row)

            if not schedule:
                raise ValueError("Schedule data is empty.")

            # Validate tuple structure
            if len(schedule) < 8:
                raise ValueError("Incomplete schedule data.")

            item_name = str(schedule[1])
            item_path = str(schedule[2])
            parameters = str(schedule[3])
            schedule_type = str(schedule[4])
            time_str = str(schedule[5])
            days = str(schedule[6])
            item_type = str(schedule[7])  # Get item_type from the 7th column
            active = str(schedule[8])

            # Check for active status
            if active != '1':
                raise ValueError("Inactive schedule cannot be added.")

            # Convert time to QTime for display
            time = QTime.fromString(time_str, "HH:mm")
            if not time.isValid():
                raise ValueError("Invalid time format. Expected HH:mm.")

            # Add data to the table
            self.scheduleTable.setItem(row, 0, QTableWidgetItem(item_name))
            self.scheduleTable.setItem(row, 1, QTableWidgetItem(time.toString("HH:mm")))
            self.scheduleTable.setItem(row, 2, QTableWidgetItem(parameters))
            self.scheduleTable.setItem(row, 3, QTableWidgetItem(days))
            self.scheduleTable.setItem(row, 4, QTableWidgetItem(schedule_type))

            # Add Edit and Delete buttons
            btn_edit = QPushButton("Edit")
            btn_delete = QPushButton("Delete")
            btn_edit.clicked.connect(lambda: self.edit_schedule(row))
            btn_delete.clicked.connect(lambda: self.delete_schedule(row))

            self.scheduleTable.setCellWidget(row, 5, btn_edit)
            self.scheduleTable.setCellWidget(row, 6, btn_delete)
        except ValueError as ve:
            QMessageBox.warning(self, "Validation Error", str(ve))
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An unexpected error occurred while adding the task to the table: {str(e)}")

    def get_schedule_from_table(self, row):
        item_name_item = self.scheduleTable.item(row, 1)
        if item_name_item is None:
            raise ValueError("Invalid item selected for editing.")
        item_name = item_name_item.text()
        time = self.scheduleTable.item(row, 2).text()
        schedule_days = self.scheduleTable.item(row, 3).text()
        item_type = self.scheduleTable.item(row, 4).text()

        days = schedule_days.split(', ')

        return {
            "item_name": item_name,
            "time": time,
            "days": days,
            "item_type": item_type
        }

    def load_scheduled_tasks(self):
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT id, item_name, item_path, parameters, schedule_type, schedule_time, 
                   monday, tuesday, wednesday, thursday, friday, saturday, sunday,
                   item_type 
            FROM scheduled_tasks 
            WHERE active = 1
        """)
        for task in cursor.fetchall():
            self.add_job(task)

    def edit_schedule(self, row):
        schedule_info = self.get_schedule_from_table(row)
        time_obj = QTime.fromString(schedule_info["time"], self.timeEdit.displayFormat())
        schedule_info["time"] = time_obj  # Replace the time string with QTime object
        edit_dialog = EditScheduleDialog(schedule_info, self)
        if edit_dialog.exec_() == QDialog.Accepted:
            updated_schedule_info = edit_dialog.get_schedule_info()
            self.db_manager.update_schedule(schedule_info, updated_schedule_info)
            self.update_schedule_in_table(row, updated_schedule_info)

    def update_schedule_in_table(self, row, schedule_info):
        self.scheduleTable.setItem(row, 0, QTableWidgetItem(schedule_info["item_name"]))
        self.scheduleTable.setItem(row, 1, QTableWidgetItem(schedule_info["time"]))
        self.scheduleTable.setItem(row, 2, QTableWidgetItem(schedule_info["date"].strftime("%Y-%m-%d")))
        self.scheduleTable.setItem(row, 3, QTableWidgetItem(", ".join(schedule_info["days"])))
        self.scheduleTable.setItem(row, 4, QTableWidgetItem(schedule_info["item_type"]))

    def delete_schedule(self, row):
        schedule_info = self.get_schedule_from_table(row)
        self.db_manager.delete_schedule(schedule_info)
        self.scheduleTable.removeRow(row)

    def delete_task(self, task):
        self.db_manager.remove_task(task["id"])
        self.load_scheduled_tasks()

    def show_error_dialog(self, error_message, schedule_info):
        QMessageBox.critical(self, "Schedule Error", f"Error: {error_message}\n\n"
                                                    f"Item Name: {schedule_info.get('item_name', 'Unknown')}\n"
                                                    f"Item Type: {schedule_info.get('item_type', 'Unknown')}\n"
                                                    f"Time: {schedule_info.get('time', 'Unknown')}\n"
                                                    f"Date: {schedule_info.get('date', 'Unknown').strftime('%Y-%m-%d') if isinstance(schedule_info.get('date'), datetime.date) else 'Unknown'}\n"
                                                    f"Days: {', '.join(schedule_info.get('days', []))}")
        
class ScheduleWindow(QMainWindow):
    def __init__(self, db_manager, theme, parent=None):
        super().__init__(parent)
        self.db_manager = db_manager
        self.theme = theme
        self.setWindowTitle("Scheduled Tasks")
        self.setup_ui()
        self.load_scheduled_tasks()
        self.setGeometry(100, 100, 900, 800)

    def setup_ui(self):
        self.setStyleSheet(self.theme)
        central_widget = QWidget(self)
        layout = QVBoxLayout(central_widget)

        self.scheduleTable = QTableWidget(self)
        self.scheduleTable.setColumnCount(7)
        self.scheduleTable.setHorizontalHeaderLabels(["State", "Item Name", "Time", "Schedule Days", "Type", "Edit", "Delete"])
        self.scheduleTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.scheduleTable.horizontalHeader().setStretchLastSection(True)
        self.scheduleTable.verticalHeader().setVisible(False)
        self.scheduleTable.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.scheduleTable)

        button_layout = QHBoxLayout()
        self.addScheduleButton = QPushButton("Add Schedule", self)
        self.addScheduleButton.clicked.connect(self.open_scheduler_dialog)
        button_layout.addWidget(self.addScheduleButton)
        layout.addLayout(button_layout)

        self.setCentralWidget(central_widget)

    def load_scheduled_tasks(self):
        self.scheduleTable.setRowCount(0)
        scheduled_tasks = self.db_manager.get_schedules()
        for task in scheduled_tasks:
            self.add_task_to_table(task)

    def add_task_to_table(self, task):
        try:
            row = self.scheduleTable.rowCount()
            self.scheduleTable.insertRow(row)

            if not task:
                raise ValueError("Schedule data is empty.")

            # Validate tuple structure
            if len(task) < 17:
                raise ValueError("Incomplete schedule data.")

            item_name = str(task[1])
            item_path = str(task[2])
            parameters = str(task[3])
            schedule_type = str(task[4])
            time_str = str(task[5])
            monday = str(task[6])
            tuesday = str(task[7])
            wednesday = str(task[8])
            thursday = str(task[9])
            friday = str(task[10])
            saturday = str(task[11])
            sunday = str(task[12])
            item_type = str(task[13])
            active = str(task[14])
            launcher_name = str(task[15])
            launcher_id = str(task[16])

            # Check for active status
            if active != '1':
                raise ValueError("Inactive schedule cannot be added.")

            # Convert time to QTime for display
            time = QTime.fromString(time_str, "HH:mm")
            if not time.isValid():
                raise ValueError("Invalid time format. Expected HH:mm.")

            # Add data to the table
            state_checkbox = QCheckBox()
            state_checkbox.setChecked(active == '1')
            state_checkbox.stateChanged.connect(lambda state, item_name=item_name: self.update_schedule_state(item_name, state == Qt.Checked))
            self.scheduleTable.setCellWidget(row, 0, state_checkbox)

            if item_type == 'all':
                item_name = launcher_name
            else:
                item_name = str(task[1])

            self.scheduleTable.setItem(row, 1, QTableWidgetItem(item_name))
            self.scheduleTable.setItem(row, 2, QTableWidgetItem(time.toString("HH:mm")))

            schedule_days = self.get_schedule_days(monday, tuesday, wednesday, thursday, friday, saturday, sunday)
            self.scheduleTable.setItem(row, 3, QTableWidgetItem(schedule_days))

            self.scheduleTable.setItem(row, 4, QTableWidgetItem(item_type))

            # Add Edit and Delete buttons
            btn_edit = QPushButton("Edit")
            btn_delete = QPushButton("Delete")
            btn_edit.clicked.connect(lambda: self.edit_schedule(row))
            btn_delete.clicked.connect(lambda: self.delete_schedule(row))

            self.scheduleTable.setCellWidget(row, 5, btn_edit)
            self.scheduleTable.setCellWidget(row, 6, btn_delete)
        except ValueError as ve:
            QMessageBox.warning(self, "Validation Error", str(ve))
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An unexpected error occurred while adding the task to the table: {str(e)}")
            
    def get_schedule_days(self, monday, tuesday, wednesday, thursday, friday, saturday, sunday):
        days = []
        if monday == '1': days.append('Monday')
        if tuesday == '1': days.append('Tuesday')
        if wednesday == '1': days.append('Wednesday')
        if thursday == '1': days.append('Thursday')
        if friday == '1': days.append('Friday')
        if saturday == '1': days.append('Saturday')
        if sunday == '1': days.append('Sunday')
        return ', '.join(days)

    def update_schedule_state(self, item_name, active):
        try:
            self.db_manager.update_schedule_state(item_name, active)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to update schedule state: {str(e)}")
            self.db_manager.notification_manager.log_error(f"Error updating schedule state: {e}")

    def open_scheduler_dialog(self):
        self.scheduler_dialog = SchedulerDialog(
            "", "", "", "",
            self.db_manager, self.theme, self
        )
        self.scheduler_dialog.exec_()
        self.load_scheduled_tasks()

    def open_schedule_window(self):
        self.schedule_window = ScheduleWindow(self.db_manager, self.themes[self.current_theme])
        self.schedule_window.show()

    def edit_schedule(self, row):
        try:
            schedule_info = self.get_schedule_from_table(row)
            edit_dialog = EditScheduleDialog(schedule_info, self)
            if edit_dialog.exec_() == QDialog.Accepted:
                updated_schedule_info = edit_dialog.get_schedule_info()
                self.db_manager.update_schedule(schedule_info, updated_schedule_info)
                self.update_schedule_in_table(row, updated_schedule_info)
        except ValueError as ve:
            QMessageBox.warning(self, "Error", str(ve))

    def delete_schedule(self, row):
        try:
            item_name_item = self.scheduleTable.item(row, 1)
            if item_name_item is not None:
                item_name = item_name_item.text()
                schedule_info = self.get_schedule_from_table(row)
                self.db_manager.delete_schedule(schedule_info)
                self.scheduleTable.removeRow(row)
            else:
                QMessageBox.warning(self, "Error", "Invalid item selected for deletion.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to delete schedule: {str(e)}")
            self.db_manager.notification_manager.log_error(f"Error deleting schedule: {e}")

    def get_schedule_from_table(self, row):
        item_name_item = self.scheduleTable.item(row, 1)
        if item_name_item is None:
            raise ValueError("Invalid item selected for editing.")
        item_name = item_name_item.text()
        time = self.scheduleTable.item(row, 2).text()
        schedule_days = self.scheduleTable.item(row, 3).text()
        item_type = self.scheduleTable.item(row, 4).text()

        days = schedule_days.split(', ')

        return {
            "item_name": item_name,
            "time": time,
            "days": days,
            "item_type": item_type
        }

    def update_schedule_in_table(self, row, schedule_info):
        self.scheduleTable.setItem(row, 0, QTableWidgetItem(schedule_info["item_name"]))
        self.scheduleTable.setItem(row, 1, QTableWidgetItem(schedule_info["time"]))
        self.scheduleTable.setItem(row, 2, QTableWidgetItem(str(int('Monday' in schedule_info["days"]))))
        self.scheduleTable.setItem(row, 3, QTableWidgetItem(str(int('Tuesday' in schedule_info["days"]))))
        self.scheduleTable.setItem(row, 4, QTableWidgetItem(str(int('Wednesday' in schedule_info["days"]))))
        self.scheduleTable.setItem(row, 5, QTableWidgetItem(str(int('Thursday' in schedule_info["days"]))))
        self.scheduleTable.setItem(row, 6, QTableWidgetItem(str(int('Friday' in schedule_info["days"]))))
        self.scheduleTable.setItem(row, 7, QTableWidgetItem(str(int('Saturday' in schedule_info["days"]))))
        self.scheduleTable.setItem(row, 8, QTableWidgetItem(str(int('Sunday' in schedule_info["days"]))))
        self.scheduleTable.setItem(row, 9, QTableWidgetItem(schedule_info["item_type"]))

class SchedulerDatabaseManager:
    def __init__(self, notification_manager=None):
        self.db_path = 'launcher_schedule.db'
        self.notification_manager = notification_manager or self.create_default_notification_manager()
        self.db_connection = self.initialize_database()

    def create_default_notification_manager(self):
        return NotificationManager()

    def initialize_database(self):
        db_exists = os.path.exists(self.db_path)
        connection = sqlite3.connect(self.db_path)
        if not db_exists:
            self.create_database(connection)
        else:
            cursor = connection.cursor()
            try:
                cursor.execute("SELECT monday FROM scheduled_tasks LIMIT 1")
                cursor.execute("SELECT item_name FROM launcher_items LIMIT 1")
            except sqlite3.OperationalError:
                self.db_connection = connection
                self.migrate_database()
        self.db_connection = connection
        return connection
    
    def create_database(self, connection):
        try:
            cursor = connection.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS scheduled_tasks (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    item_name TEXT,
                    item_path TEXT,
                    parameters TEXT,
                    schedule_type TEXT,
                    schedule_time TEXT,
                    monday INTEGER DEFAULT 0,
                    tuesday INTEGER DEFAULT 0,
                    wednesday INTEGER DEFAULT 0,
                    thursday INTEGER DEFAULT 0,
                    friday INTEGER DEFAULT 0,
                    saturday INTEGER DEFAULT 0,
                    sunday INTEGER DEFAULT 0,
                    item_type TEXT,
                    active INTEGER DEFAULT 1,
                    dropdown_value INTEGER DEFAULT 0,
                    launcher_name TEXT,
                    launcher_id TEXT       
                )
            ''')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS launcher_items (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    launcher_id INTEGER,
                    item_name TEXT,
                    item_type TEXT,
                    item_path TEXT,
                    parameters TEXT,
                    launch_order INTEGER,
                    launch INTEGER DEFAULT 0,
                    FOREIGN KEY (launcher_id) REFERENCES launchers (id)
                )
            ''')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS launchers (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    launcher_name TEXT
                )
            ''')
            connection.commit()
        except sqlite3.Error as e:
            self.notification_manager.log_error(f"Database creation failed: {e}")

    def validate_database(self, connection):
        try:
            cursor = connection.cursor()
            cursor.execute("SELECT * FROM scheduled_tasks LIMIT 1")
            return True
        except sqlite3.Error as e:
            self.notification_manager.log_error(f"Database validation failed: {e}")
            return False

    def close_database_connection(self):
        if self.db_connection:
            self.db_connection.close()

    def migrate_database(self):
        try:
            connection = self.db_connection
            cursor = connection.cursor()

            # Check if the dropdown_value column exists
            cursor.execute("PRAGMA table_info(scheduled_tasks)")
            columns = [column[1] for column in cursor.fetchall()]
            if "dropdown_value" not in columns:
                # Add the dropdown_value column to the existing table
                cursor.execute("ALTER TABLE scheduled_tasks ADD COLUMN dropdown_value INTEGER DEFAULT 0")
                connection.commit()
        except sqlite3.Error as e:
            self.notification_manager.log_error(f"Database migration failed: {e}")
            raise

    def copy_data(self, old_db_path, new_db_path):
        try:
            old_conn = sqlite3.connect(old_db_path)
            new_conn = sqlite3.connect(new_db_path)
            old_cursor = old_conn.cursor()
            new_cursor = new_conn.cursor()

            old_cursor.execute("SELECT * FROM scheduled_tasks")
            rows = old_cursor.fetchall()
            new_cursor.executemany("INSERT INTO scheduled_tasks VALUES (?, ?, ?, ?, ?, ?, ?, ?)", rows)
            new_conn.commit()
            old_conn.close()
            new_conn.close()
        except sqlite3.Error as e:
            self.notification_manager.log_error(f"Data copying failed: {e}")

    def get_connection(self):
        return self.db_connection

    def get_schedules(self):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("SELECT * FROM scheduled_tasks WHERE active = 1")
            return cursor.fetchall()
        except sqlite3.Error as e:
            self.notification_manager.log_error(f"Error retrieving schedules: {e}")
            return []

    def add_schedule(self, schedule_info):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("""
                INSERT INTO scheduled_tasks (
                    item_name, item_path, parameters, schedule_type, schedule_time,
                    monday, tuesday, wednesday, thursday, friday, saturday, sunday,
                    item_type, active, dropdown_value
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                schedule_info['item_name'],
                schedule_info['item_path'],
                schedule_info['parameters'],
                "once",
                schedule_info['time'],
                int('Monday' in schedule_info['days']),
                int('Tuesday' in schedule_info['days']),
                int('Wednesday' in schedule_info['days']),
                int('Thursday' in schedule_info['days']),
                int('Friday' in schedule_info['days']),
                int('Saturday' in schedule_info['days']),
                int('Sunday' in schedule_info['days']),
                schedule_info['item_type'],
                1,
                schedule_info.get('dropdown_value', 0)  # Use a default value of 0 if not provided
            ))
            self.db_connection.commit()
        except sqlite3.Error as e:
            self.notification_manager.log_error(f"Error adding schedule: {e}")

    def update_schedule(self, old_schedule_info, new_schedule_info):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("""
                UPDATE scheduled_tasks
                SET item_name = ?, item_path = ?, parameters = ?, schedule_time = ?,
                    monday = ?, tuesday = ?, wednesday = ?, thursday = ?,
                    friday = ?, saturday = ?, sunday = ?, item_type = ?
                WHERE item_name = ? AND item_path = ? AND parameters = ? AND schedule_time = ?
                    AND monday = ? AND tuesday = ? AND wednesday = ? AND thursday = ?
                    AND friday = ? AND saturday = ? AND sunday = ? AND item_type = ?
            """, (
                new_schedule_info['item_name'],
                new_schedule_info['item_path'],
                new_schedule_info['parameters'],
                new_schedule_info['time'],
                int('Monday' in new_schedule_info['days']),
                int('Tuesday' in new_schedule_info['days']),
                int('Wednesday' in new_schedule_info['days']),
                int('Thursday' in new_schedule_info['days']),
                int('Friday' in new_schedule_info['days']),
                int('Saturday' in new_schedule_info['days']),
                int('Sunday' in new_schedule_info['days']),
                new_schedule_info['item_type'],
                old_schedule_info['item_name'],
                old_schedule_info['item_path'],
                old_schedule_info['parameters'],
                old_schedule_info['time'],
                int('Monday' in old_schedule_info['days']),
                int('Tuesday' in old_schedule_info['days']),
                int('Wednesday' in old_schedule_info['days']),
                int('Thursday' in old_schedule_info['days']),
                int('Friday' in old_schedule_info['days']),
                int('Saturday' in old_schedule_info['days']),
                int('Sunday' in old_schedule_info['days']),
                old_schedule_info['item_type']
            ))
            self.db_connection.commit()
        except sqlite3.Error as e:
            self.notification_manager.log_error(f"Error updating schedule: {e}")

    def get_item_path(self, schedule_info):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("SELECT item_path FROM scheduled_tasks WHERE item_name = ? AND item_type = ? AND parameters = ?", (
                schedule_info["item_name"],
                schedule_info["item_type"],
                schedule_info["parameters"]
            ))
            result = cursor.fetchone()
            if result:
                return result[0]
            else:
                return None
        except sqlite3.Error as e:
            self.notification_manager.log_error(f"Error retrieving item path: {e}")
            return None
        
    def get_schedule_id(self, schedule_info):
        try:
            cursor = self.db_connection.cursor()
            days = ','.join(schedule_info["days"])

            cursor.execute("SELECT id FROM scheduled_tasks WHERE item_name = ? AND item_type = ? AND parameters = ? AND schedule_time = ? AND days = ?", (
                schedule_info["item_name"],
                schedule_info["item_type"],
                schedule_info["parameters"],
                schedule_info["time"],
                days
            ))

            result = cursor.fetchone()
            return result[0] if result else None
        except sqlite3.Error as e:
            self.notification_manager.log_error(f"Error retrieving schedule ID: {e}")
            return None

    def delete_schedule(self, schedule_info):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("""
                DELETE FROM scheduled_tasks
                WHERE item_name = ? AND item_type = ? AND schedule_time = ?
                    AND monday = ? AND tuesday = ? AND wednesday = ? AND thursday = ?
                    AND friday = ? AND saturday = ? AND sunday = ?
            """, (
                schedule_info["item_name"],
                schedule_info["item_type"],
                schedule_info["time"],
                int('Monday' in schedule_info['days']),
                int('Tuesday' in schedule_info['days']),
                int('Wednesday' in schedule_info['days']),
                int('Thursday' in schedule_info['days']),
                int('Friday' in schedule_info['days']),
                int('Saturday' in schedule_info['days']),
                int('Sunday' in schedule_info['days'])
            ))
            self.db_connection.commit()
        except sqlite3.Error as e:
            self.notification_manager.log_error(f"Error deleting schedule: {e}")
            raise
        
    def update_schedule_state(self, item_name, active):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("""
                UPDATE scheduled_tasks
                SET active = ?
                WHERE item_name = ?
            """, (int(active), item_name))
            self.db_connection.commit()
        except sqlite3.Error as e:
            self.notification_manager.log_error(f"Error updating schedule state: {e}")
            raise
            
class TaskScheduler(QObject):
    taskCompleted = pyqtSignal(str)
    taskFailed = pyqtSignal(str, str)

    def __init__(self, db_manager):
        super().__init__()
        self.db_manager = db_manager
        self.connection = db_manager.get_connection()
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.check_and_execute_tasks)
        self.timer.start(1000)
        self.selected_browser_path = None

    def set_selected_browser_path(self, browser_path):
        self.selected_browser_path = browser_path

    def schedule_task(self, item_name, item_path, parameters, schedule_info, launch_all=False, dropdown_value=0):
        cursor = self.connection.cursor()
        item_type = 'all' if launch_all else 'selected'
        cursor.execute('''
            INSERT INTO scheduled_tasks (
                item_name, item_path, parameters, schedule_type, schedule_time,
                monday, tuesday, wednesday, thursday, friday, saturday, sunday,
                active, item_type, dropdown_value
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            item_name, item_path, parameters, "once", schedule_info['time'],
            int('Monday' in schedule_info['days']),
            int('Tuesday' in schedule_info['days']),
            int('Wednesday' in schedule_info['days']),
            int('Thursday' in schedule_info['days']),
            int('Friday' in schedule_info['days']),
            int('Saturday' in schedule_info['days']),
            int('Sunday' in schedule_info['days']),
            1, item_type, dropdown_value
        ))
        self.connection.commit()
        self.load_scheduled_tasks()

    def load_scheduled_tasks(self):
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT id, launcher_name, launcher_id, schedule_type, schedule_time,
                   monday, tuesday, wednesday, thursday, friday, saturday, sunday
            FROM scheduled_tasks
            WHERE active = 1
        """)
        for task in cursor.fetchall():
            self.add_job(task)

    def add_job(self, task):
        task_id, launcher_name, launcher_id, schedule_type, schedule_time, \
        monday, tuesday, wednesday, thursday, friday, saturday, sunday = task

        days = []
        if monday: days.append('Monday')
        if tuesday: days.append('Tuesday')
        if wednesday: days.append('Wednesday')
        if thursday: days.append('Thursday')
        if friday: days.append('Friday')
        if saturday: days.append('Saturday')
        if sunday: days.append('Sunday')

        job_action = lambda: self.launch_launcher(launcher_id)
        if schedule_type == "once":
            job = schedule.every().day.at(schedule_time).do(job_action)
        else:
            for day in days:
                job = getattr(schedule.every(), day.lower()).at(schedule_time).do(job_action)
        job.tag(task_id)

    def launch_task(self, item_name, item_path, parameters, item_type):
        try:
            if item_type == "Website":
                if self.selected_browser_path:
                    command = [self.selected_browser_path, item_path]
                else:
                    command = ["firefox", item_path]  # Default to Firefox if no browser is selected
            else:
                command = [item_path] + parameters.split() if parameters else [item_path]
    
            subprocess.Popen(command, shell=True, start_new_session=True)  # Add start_new_session=True to detach the process
            self.taskCompleted.emit(item_name)
        except Exception as e:
            self.taskFailed.emit(item_name, str(e))

    def launch_all_items(self):
        # Retrieve all items from the database and launch them
        cursor = self.connection.cursor()
        cursor.execute("SELECT item_name, item_path, parameters FROM scheduled_tasks WHERE active = 1")
        for item_name, item_path, parameters in cursor.fetchall():
            try:
                command = [item_path] + parameters.split() if parameters else [item_path]
                subprocess.Popen(command, shell=True)
                self.taskCompleted.emit(item_name)
            except Exception as e:
                self.taskFailed.emit(item_name, str(e))

    def remove_task(self, task_id):
        schedule.clear(task_id)  # Remove task using the job's tag which is the task ID
        cursor = self.connection.cursor()
        cursor.execute("UPDATE scheduled_tasks SET active = 0 WHERE id = ?", (task_id,))
        self.connection.commit()

    def start(self):
        # Continuously check and execute pending tasks
        while True:
            schedule.run_pending()
            time.sleep(1)  # Reduce the sleep time to 1 second

    def check_and_execute_tasks(self):
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT id, item_name, item_path, parameters, schedule_type, schedule_time,
                   monday, tuesday, wednesday, thursday, friday, saturday, sunday,
                   item_type
            FROM scheduled_tasks
            WHERE active = 1
        """)
        for task in cursor.fetchall():
            self.execute_task(task)

    def schedule_launcher(self, schedule_info):
        cursor = self.connection.cursor()
        cursor.execute('''
            INSERT INTO scheduled_tasks (
                launcher_name, launcher_id, schedule_type, schedule_time,
                monday, tuesday, wednesday, thursday, friday, saturday, sunday,
                active
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            schedule_info['launcher_name'],
            schedule_info['launcher_id'],
            "once", schedule_info['time'],
            int('Monday' in schedule_info['days']),
            int('Tuesday' in schedule_info['days']),
            int('Wednesday' in schedule_info['days']),
            int('Thursday' in schedule_info['days']),
            int('Friday' in schedule_info['days']),
            int('Saturday' in schedule_info['days']),
            int('Sunday' in schedule_info['days']),
            1
        ))
        self.connection.commit()
        self.load_scheduled_tasks()

    def execute_task(self, task):
        task_id, item_name, item_path, parameters, schedule_type, schedule_time, \
        monday, tuesday, wednesday, thursday, friday, saturday, sunday, item_type, launcher_name, launcher_id = task

        current_time = QTime.currentTime().toString("HH:mm")
        scheduled_time = QTime.fromString(schedule_time, "HH:mm").toString("HH:mm")

        current_day = QDate.currentDate().toString("dddd")
        should_run = False

        if current_day == "Monday" and monday == '1':
            should_run = True
        elif current_day == "Tuesday" and tuesday == '1':
            should_run = True
        elif current_day == "Wednesday" and wednesday == '1':
            should_run = True
        elif current_day == "Thursday" and thursday == '1':
            should_run = True
        elif current_day == "Friday" and friday == '1':
            should_run = True
        elif current_day == "Saturday" and saturday == '1':
            should_run = True
        elif current_day == "Sunday" and sunday == '1':
            should_run = True

        if scheduled_time == current_time and should_run:
            if item_type == 'all':
                self.launch_all_items()
            elif item_type == 'selected':
                self.launch_task(item_name, item_path, parameters, item_type)
            elif item_type == 'launcher':
                self.launch_launcher(launcher_id)

    def launch_launcher(self, launcher_id):
        try:
            cursor = self.connection.cursor()
            cursor.execute("""
                SELECT item_name, item_path, parameters, item_type
                FROM launcher_items
                WHERE launcher_id = ? AND launch = 1
                ORDER BY launch_order
            """, (launcher_id,))
            items = cursor.fetchall()

            for item_name, item_path, parameters, item_type in items:
                self.launch_task(item_name, item_path, parameters, item_type)
        except sqlite3.Error as e:
            self.db_manager.notification_manager.log_error(f"Error launching launcher: {e}")
### LAUNCHER WIDGETS END ###

### ADDITIONAL NOTES WIDGETS START ###
class ProductivityWidgets(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.high_score = 0
        self.initUI()

    def initUI(self):
        self.layout = QVBoxLayout(self)
        # Create a sub-tab widget inside this widget
        self.subTabs = QTabWidget(self)
        self.notesTab = AdditionalNotesWidget(self)  # This will be the additional notes tab
        self.calendarTab = ClockCalendarWidget(self)  # This will be the calendar tab
        self.calculatorTab = CalculatorWidget(self)  # This will be the calculator tab
        self.fileFolderViewTab = FileFolderViewWidget(self)  # This will be the file/folder view tab
        self.gamesTab = QWidget()  # Placeholder for games tab
        self.toDoTab = ToDoWidget(self)  # This will be the to-do tab
        # Setup each tab
        self.subTabs.addTab(self.notesTab, "Additional Notes")
        self.subTabs.addTab(self.calendarTab, "Date/Time")
        self.subTabs.addTab(self.calculatorTab, "Calculator")
        self.subTabs.addTab(self.fileFolderViewTab, "File/Folder View")
        self.setupGamesTab()  # Setup the games tab
        self.subTabs.addTab(self.gamesTab, "Games")
        self.subTabs.addTab(self.toDoTab, "To-Do List")  # Add the to-do tab
        self.layout.addWidget(self.subTabs)

    def setupGamesTab(self):
        self.gamesTab = QWidget()
        layout = QVBoxLayout(self.gamesTab)
        
        # Create a tabbed widget for games
        self.gamesTabWidget = QTabWidget(self.gamesTab)
        
        # Create a tab for Tic-Tac-Toe
        ticTacToeTab = QWidget()
        ticTacToeTabLayout = QVBoxLayout(ticTacToeTab)
        self.tic_tac_toe_game = TicTacToeBoard()
        ticTacToeTabLayout.addWidget(self.tic_tac_toe_game)
        ticTacToeTab.setLayout(ticTacToeTabLayout)
        self.gamesTabWidget.addTab(ticTacToeTab, "Tic-Tac-Toe")

        SnakeTab = QWidget()
        SnakeTabLayout = QVBoxLayout(SnakeTab)
        self.snake_game = SnakeGame()
        SnakeTabLayout.addWidget(self.snake_game)
        SnakeTab.setLayout(SnakeTabLayout)
        self.gamesTabWidget.addTab(SnakeTab, "Snake")
        
        # Create a tab for Tetris
        tetrisTab = QWidget()
        tetrisTabLayout = QVBoxLayout(tetrisTab)
        self.tetris_game = TetrisBoard()
        self.tetris_name_label = QLabel("Tetris")
        self.tetris_name_label.setAlignment(Qt.AlignCenter)
        tetrisTabLayout.addWidget(self.tetris_name_label)
        
        self.tetris_high_score_label = QLabel(f"High Score: {self.tetris_game.high_score}")
        self.tetris_high_score_label.setAlignment(Qt.AlignCenter)
        tetrisTabLayout.addWidget(self.tetris_high_score_label)
        
        self.tetris_score_label = QLabel("Score: 0")
        self.tetris_score_label.setAlignment(Qt.AlignCenter)
        tetrisTabLayout.addWidget(self.tetris_score_label)
        
        tetrisTabLayout.addWidget(self.tetris_game)
        
        button_layout = QHBoxLayout()
        self.tetris_start_button = QPushButton("Start")
        self.tetris_start_button.clicked.connect(self.tetris_game.start_game)
        button_layout.addWidget(self.tetris_start_button)
        
        self.tetris_pause_button = QPushButton("Pause")
        self.tetris_pause_button.clicked.connect(self.tetris_game.pause_game)
        button_layout.addWidget(self.tetris_pause_button)
        
        self.tetris_popout_button = QPushButton("Pop Out")
        self.tetris_popout_button.clicked.connect(self.popout_tetris)
        button_layout.addWidget(self.tetris_popout_button)
        
        tetrisTabLayout.addLayout(button_layout)
        tetrisTab.setLayout(tetrisTabLayout)
        self.gamesTabWidget.addTab(tetrisTab, "Tetris")
        
        # Create a tab for Breakout
        breakoutTab = QWidget()
        breakoutTabLayout = QVBoxLayout(breakoutTab)
        
        self.breakout_launch_button = QPushButton("Launch Breakout Game")
        self.breakout_launch_button.clicked.connect(self.launchBreakoutGame)
        
        self.high_score_label = QLabel(f"High Score: {self.high_score}")
        self.high_score_label.setAlignment(Qt.AlignCenter)
        
        breakoutTabLayout.addWidget(self.high_score_label)
        breakoutTabLayout.addWidget(self.breakout_launch_button)
        
        breakoutTab.setLayout(breakoutTabLayout)
        self.gamesTabWidget.addTab(breakoutTab, "Breakout")
        
        # Setup other tabs (Music, Video)
        self.setupMusicTab()
        self.gamesTabWidget.addTab(self.musicTab, "Music")
        self.setupVideoTab()
        self.gamesTabWidget.addTab(self.videoTab, "Video")
        
        layout.addWidget(self.gamesTabWidget)
        self.gamesTab.setLayout(layout)
        
        self.tetris_game.scoreUpdated.connect(self.update_tetris_score)

    def launchBreakoutGame(self):
        self.popout_window = PopOutWindow(self)
        self.popout_window.show()

    def updateHighScore(self, high_score):
        self.high_score = high_score
        self.high_score_label.setText(f"High Score: {self.high_score}")

    def update_tetris_score(self, score):
        self.tetris_score_label.setText(f"Score: {score}")
        self.tetris_high_score_label.setText(f"High Score: {self.tetris_game.high_score}")

    def popout_tetris(self):
        # Create the pop-out window without a parent
        self.tetris_popout = TetrisPopOutWindow()
        
        # Apply the current application style to the new window
        self.tetris_popout.setStyle(QApplication.style())
        
        # If you're using a custom stylesheet, apply it here
        if self.styleSheet():
            self.tetris_popout.setStyleSheet(self.styleSheet())
        
        self.tetris_popout.setAttribute(Qt.WA_DeleteOnClose)
        self.tetris_popout.show()

    def setupMusicTab(self):
        self.musicTab = QWidget()
        layout = QVBoxLayout(self.musicTab)
        # Add music player widget or controls here
        self.musicTab.setLayout(layout)

    def setupVideoTab(self):
        self.videoTab = QWidget()
        layout = QVBoxLayout(self.videoTab)
        # Add video player widget or controls here
        self.videoTab.setLayout(layout)

class AdditionalNotesWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.dbConnection = None
        self.popped_out_windows = {}
        self.initDB()
        self.initUI()
        self.loadAdditionalNotes()

    def initUI(self):
        self.layout = QVBoxLayout(self)

        self.scroll_area = QScrollArea(self)
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)  # Disable horizontal scrolling
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)  # Enable vertical scrolling

        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)

        self.tabs = QTabWidget(self)
        self.tabs.setTabsClosable(True)
        self.tabs.tabCloseRequested.connect(self.closeTab)
        self.tabs.tabBar().tabMoved.connect(self.saveTabOrder)
        self.scroll_layout.addWidget(self.tabs)

        new_tab_button = QPushButton("New Note")
        new_tab_button.clicked.connect(self.createNewTab)
        self.scroll_layout.addWidget(new_tab_button)

        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        self.layout.addWidget(self.scroll_area)
        self.setLayout(self.layout)

    def setupTabs(self):
        cursor = self.dbConnection.cursor()
        cursor.execute('SELECT id, tab_order FROM additional_notes ORDER BY tab_order')
        notes = cursor.fetchall()
        for note in notes:
            self.addTabFromDatabase(note[0])

    def createTab(self, tab_name, note_id=None):
        widget = QWidget()
        layout = QVBoxLayout(widget)

        collapse_button = QPushButton("Collapse/Expand Additional Options")
        collapse_button.setCheckable(True)
        collapse_button.setChecked(True)
        collapse_button.toggled.connect(lambda checked: section_widget.setVisible(checked))
        layout.addWidget(collapse_button)

        section_widget = QWidget()
        section_layout = QVBoxLayout(section_widget)
        collapse_button.toggle()

        # Row Layout
        row_layout = QHBoxLayout()
        self.first_name_checkbox = QCheckBox("First Name:")
        self.first_name_checkbox.setFixedWidth(75)
        self.first_name_checkbox.setChecked(True)
        self.first_name_edit = QLineEdit()
        self.first_name_edit.setObjectName("first_name_edit")
        self.first_name_checkbox.stateChanged.connect(lambda state, line_edit=self.first_name_edit: self.toggleField(state, line_edit))
        row_layout.addWidget(self.first_name_checkbox)
        row_layout.addWidget(self.first_name_edit)

        self.user_name_copy_button = QPushButton(">")
        self.user_name_copy_button.clicked.connect(lambda: self.copy_textbox("first_name_edit"))
        row_layout.addWidget(self.user_name_copy_button)

        # Row 0 Layout
        row0_layout = QHBoxLayout()
        self.last_name_checkbox = QCheckBox("User Name:")
        self.last_name_checkbox.setFixedWidth(75)
        self.last_name_checkbox.setChecked(True)
        self.last_name_edit = QLineEdit()
        self.last_name_edit.setObjectName("last_name_edit")
        self.last_name_checkbox.stateChanged.connect(lambda state, line_edit=self.last_name_edit: self.toggleField(state, line_edit))
        row0_layout.addWidget(self.last_name_checkbox)
        row0_layout.addWidget(self.last_name_edit)

        self.user_name_copy_button = QPushButton(">")
        self.user_name_copy_button.clicked.connect(lambda: self.copy_textbox("last_name_edit"))
        row0_layout.addWidget(self.user_name_copy_button)
        
        # Row 1 Layout
        row1_layout = QHBoxLayout()
        self.user_name_checkbox = QCheckBox("User Name:")
        self.user_name_checkbox.setFixedWidth(75)
        self.user_name_checkbox.setChecked(True)
        self.user_name_edit = QLineEdit()
        self.user_name_edit.setObjectName("user_name_edit")
        self.user_name_checkbox.stateChanged.connect(lambda state, line_edit=self.user_name_edit: self.toggleField(state, line_edit))
        row1_layout.addWidget(self.user_name_checkbox)
        row1_layout.addWidget(self.user_name_edit)

        self.user_name_copy_button = QPushButton(">")
        self.user_name_copy_button.clicked.connect(lambda: self.copy_textbox("user_name_edit"))
        row1_layout.addWidget(self.user_name_copy_button)

        # Row 2 Layout
        row2_layout = QHBoxLayout()
        self.username_checkbox = QCheckBox("Username:")
        self.username_checkbox.setFixedWidth(75)
        self.username_checkbox.setChecked(True)
        self.username_edit = QLineEdit()
        self.username_edit.setObjectName("username_edit")
        self.username_checkbox.stateChanged.connect(lambda state, line_edit=self.username_edit: self.toggleField(state, line_edit))
        row2_layout.addWidget(self.username_checkbox)
        row2_layout.addWidget(self.username_edit)
        
        self.username_copy_button = QPushButton(">")
        self.username_copy_button.clicked.connect(lambda: self.copy_textbox("username_edit"))
        row2_layout.addWidget(self.username_copy_button)

        # Row 3 Layout
        row3_layout = QHBoxLayout()
        self.email_checkbox = QCheckBox("Email:")
        self.email_checkbox.setFixedWidth(75)
        self.email_checkbox.setChecked(True)
        self.email_edit = QLineEdit()
        self.email_edit.setObjectName("email_edit")
        self.email_checkbox.stateChanged.connect(lambda state, line_edit=self.email_edit: self.toggleField(state, line_edit))
        row3_layout.addWidget(self.email_checkbox)
        row3_layout.addWidget(self.email_edit)

        self.email_copy_button = QPushButton(">")
        self.email_copy_button.clicked.connect(lambda: self.copy_textbox("email_edit"))
        row3_layout.addWidget(self.email_copy_button)

        # Row 4 Layout
        row4_layout = QHBoxLayout()
        self.company_checkbox = QCheckBox("Company:")
        self.company_checkbox.setFixedWidth(75)
        self.company_checkbox.setChecked(True)
        self.company_edit = QLineEdit()
        self.company_edit.setObjectName("company_edit")
        self.company_checkbox.stateChanged.connect(lambda state, line_edit=self.company_edit: self.toggleField(state, line_edit))
        row4_layout.addWidget(self.company_checkbox)
        row4_layout.addWidget(self.company_edit)

        self.company_copy_button = QPushButton(">")
        self.company_copy_button.clicked.connect(lambda: self.copy_textbox("company_edit"))
        row4_layout.addWidget(self.company_copy_button)

        # Row 5 Layout
        row5_layout = QHBoxLayout()
        self.ticket_checkbox = QCheckBox("Ticket:")
        self.ticket_checkbox.setFixedWidth(75)
        self.ticket_checkbox.setChecked(True)
        self.ticket_edit = QLineEdit()
        self.ticket_edit.setObjectName("ticket_edit")
        self.ticket_checkbox.stateChanged.connect(lambda state, line_edit=self.ticket_edit: self.toggleField(state, line_edit))
        row5_layout.addWidget(self.ticket_checkbox)
        row5_layout.addWidget(self.ticket_edit)

        self.ticket_copy_button = QPushButton(">")
        self.ticket_copy_button.clicked.connect(lambda: self.copy_textbox("ticket_edit"))
        row5_layout.addWidget(self.ticket_copy_button)

        # Row 6 Layout
        row6_layout = QHBoxLayout()
        self.password_checkbox = QCheckBox("Password:")
        self.password_checkbox.setFixedWidth(75)
        self.password_checkbox.setChecked(True)
        self.password_edit = QLineEdit()
        self.password_edit.setObjectName("password_edit")
        self.password_edit.setEchoMode(QLineEdit.Password)
        self.password_checkbox.stateChanged.connect(lambda state, line_edit=self.password_edit: self.toggleField(state, line_edit))
        row6_layout.addWidget(self.password_checkbox)
        row6_layout.addWidget(self.password_edit)

        self.show_password_button = QCheckBox("")
        self.show_password_button.stateChanged.connect(self.togglePasswordVisibility)
        row6_layout.addWidget(self.show_password_button)

        self.password_copy_button = QPushButton(">")
        self.password_copy_button.clicked.connect(lambda: self.copy_textbox("password_edit"))
        row6_layout.addWidget(self.password_copy_button)

        section_layout.addLayout(row_layout)
        section_layout.addLayout(row0_layout)
        section_layout.addLayout(row1_layout)
        section_layout.addLayout(row2_layout)
        section_layout.addLayout(row3_layout)
        section_layout.addLayout(row4_layout)
        section_layout.addLayout(row5_layout)
        section_layout.addLayout(row6_layout)

        section_widget.setLayout(section_layout)
        layout.addWidget(section_widget)

        self.notes_edit = QTextEdit()
        self.notes_edit.setObjectName("notes_edit")
        layout.addWidget(self.notes_edit)

        button_layout = QHBoxLayout()
        self.send_button = QPushButton("Send to Main Notes")
        self.send_button.clicked.connect(self.sendToMain)
        button_layout.addWidget(self.send_button)

        self.save_button = QPushButton("Save Note")
        self.save_button.clicked.connect(lambda: self.saveNote(note_id))
        button_layout.addWidget(self.save_button)

        self.delete_button = QPushButton("Delete Note")
        self.delete_button.clicked.connect(lambda: self.deleteNoteFromTab(tab_name, note_id))
        button_layout.addWidget(self.delete_button)

        self.pop_out_button = QPushButton("Pop Out")
        self.pop_out_button.clicked.connect(lambda: self.popOut(note_id))
        button_layout.addWidget(self.pop_out_button)

        self.close_checkbox = QCheckBox("Close on Send/Save")
        self.close_checkbox.setChecked(False)
        layout.addWidget(self.close_checkbox)

        layout.addLayout(button_layout)
        widget.setLayout(layout)
        return widget
    
    def copy_textbox(self, text):
        current_tab = self.tabs.currentWidget()
        text = current_tab.findChild(QLineEdit, text).text()
        QMessageBox.information(self,"Debug",text)

    def togglePasswordVisibility(self, state):
        if state == Qt.Checked:
            self.password_edit.setEchoMode(QLineEdit.Normal)
        else:
            self.password_edit.setEchoMode(QLineEdit.Password)

    def sendToMain(self):
        current_tab = self.tabs.currentWidget()
        first_name = current_tab.findChild(QLineEdit, "first_name_edit").text()
        last_name = current_tab.findChild(QLineEdit, "last_name_edit").text()
        user_name = current_tab.findChild(QLineEdit, "user_name_edit").text()
        username = current_tab.findChild(QLineEdit, "username_edit").text()
        email = current_tab.findChild(QLineEdit, "email_edit").text()
        company = current_tab.findChild(QLineEdit, "company_edit").text()
        ticket = current_tab.findChild(QLineEdit, "ticket_edit").text()
        notes = current_tab.findChild(QTextEdit, "notes_edit").toPlainText()

        try:
            # Traverse up the widget hierarchy to find the OmniOmega instance
            parent = self.parent
            while parent is not None and not isinstance(parent, OmniOmega):
                parent = parent.parentWidget()

            if parent is not None:
                main_text_edit = parent.textArea
                if main_text_edit is not None:
                    cursor = main_text_edit.textCursor()
                    if first_name != "":
                        first_name = "First Name: " + first_name + "\n"
                    if last_name != "":
                        last_name = "Last Name: " + last_name + "\n"
                    if user_name != "":
                        user_name = "User Name: " + user_name + "\n"
                    if username != "":
                        username = "Username: " + username + "\n"
                    if email != "":
                        email = "E-Mail: " + email + "\n"
                    if company != "":
                        company = "Company: " + company + "\n"
                    if ticket != "":
                        ticket = "Ticket: " + ticket + "\n"
                    if notes != "":
                        notes = "Notes: " + notes + "\n"
                    note_content = (f"""{first_name}{last_name}{user_name}{username}{email}{company}{ticket}{notes}------------------------""")
                    parent.insertNoteInTextArea(cursor, note_content)
                    if self.close_checkbox.isChecked():
                        self.closeTab(self.tabs.currentIndex())
        except AttributeError as e:
            QMessageBox.warning(self, "Error", f"Failed to send to main text area: {str(e)}")

    def toggleField(self, state, line_edit):
        line_edit.setVisible(state == Qt.Checked)

    def saveNote(self, note_id):
        current_tab = self.tabs.currentWidget()
        tab_name = self.tabs.tabText(self.tabs.currentIndex())
        first_name = current_tab.findChild(QLineEdit, "first_name_edit").text()
        last_name = current_tab.findChild(QLineEdit, "last_name_edit").text()
        user_name = current_tab.findChild(QLineEdit, "user_name_edit").text()
        username = current_tab.findChild(QLineEdit, "username_edit").text()
        email = current_tab.findChild(QLineEdit, "email_edit").text()
        company = current_tab.findChild(QLineEdit, "company_edit").text()
        ticket = current_tab.findChild(QLineEdit, "ticket_edit").text()
        password = current_tab.findChild(QLineEdit, "password_edit").text()
        notes = current_tab.findChild(QTextEdit, "notes_edit").toPlainText()

        if note_id is not None:
            self.updateAdditionalNotes(note_id, first_name, last_name, user_name, username, email, company, ticket, password, notes)
        else:
            if debug_mode:
                print("saveNote Debug Message")
            note_id = self.saveAdditionalNotes(first_name, last_name, user_name, username, email, company, ticket, password, notes)
            self.tabs.setTabText(self.tabs.currentIndex(), f"Note {note_id}")

        if self.close_checkbox.isChecked():
            self.hide()

    def closeTab(self, index):
        tab = self.tabs.widget(index)
        tab_name = self.tabs.tabText(index)
        if tab_name.startswith("Note"):
            note_id = int(tab_name.split(" ")[1])
            self.deleteAdditionalNotes(note_id)
        self.tabs.removeTab(index)

    def saveTabOrder(self):
        for i in range(self.tabs.count()):
            tab_name = self.tabs.tabText(i)
            if tab_name.startswith("Note"):
                note_id = int(tab_name.split(" ")[1])
                cursor = self.dbConnection.cursor()
                cursor.execute('UPDATE additional_notes SET tab_order = ? WHERE id = ?', (i, note_id))
                self.dbConnection.commit()

    def addTabFromDatabase(self, note_id):
        cursor = self.dbConnection.cursor()
        cursor.execute('SELECT * FROM additional_notes WHERE id = ?', (note_id,))
        note = cursor.fetchone()
        tab_name = f"Note {note[0]}"
        tab = self.createTab(tab_name, note[0])
        tab.findChild(QLineEdit, "first_name_edit").setText(note[1])
        tab.findChild(QLineEdit, "last_name_edit").setText(note[2])
        tab.findChild(QLineEdit, "user_name_edit").setText(note[3])
        tab.findChild(QLineEdit, "username_edit").setText(note[4])
        tab.findChild(QLineEdit, "email_edit").setText(note[5])
        tab.findChild(QLineEdit, "company_edit").setText(note[6])
        tab.findChild(QLineEdit, "ticket_edit").setText(note[7])
        tab.findChild(QLineEdit, "password_edit").setText(note[8])
        tab.findChild(QTextEdit, "notes_edit").setPlainText(note[9])
        self.tabs.addTab(tab, tab_name)

    def popOut(self, note_id):
        tab_index = self.getTabIndexById(note_id)
        if tab_index is not None:
            tab_widget = self.tabs.widget(tab_index)
            self.tabs.removeTab(tab_index)
            pop_out_window = QMainWindow()
            pop_out_window.setCentralWidget(tab_widget)
            pop_out_window.setWindowTitle(f"Note {note_id}")
            pop_out_window.show()
            pop_out_window.closed.connect(lambda: self.popIn(note_id, tab_widget))
            self.popped_out_windows[note_id] = pop_out_window

    def popIn(self, note_id, tab_widget):
        if note_id in self.popped_out_windows:
            pop_out_window = self.popped_out_windows.pop(note_id)
            pop_out_window.close()
            tab_name = f"Note {note_id}"
            self.tabs.addTab(tab_widget, tab_name)
            self.saveTabOrder()

    def initDB(self):
        try:
            db_exists = os.path.exists('additional_notes.db')
            self.dbConnection = sqlite3.connect('additional_notes.db')

            if not db_exists:
                self.setupDatabase()
            else:
                self.checkAndRepairDatabase()
        except Exception as e:
            self.handleDBError(e)

    def setupDatabase(self):
        try:
            cursor = self.dbConnection.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS additional_notes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    first_name TEXT,
                    last_name TEXT,
                    user_name TEXT,
                    username TEXT,
                    email TEXT,
                    company TEXT,
                    ticket TEXT,
                    password TEXT,
                    notes TEXT,
                    tab_order INTEGER
                )
            ''')
            self.dbConnection.commit()
        except Exception as e:
            self.handleDBError(e)

    def saveAdditionalNotes(self, first_name, last_name, user_name, username, email, company, ticket, password, notes):
        try:
            cursor = self.dbConnection.cursor()
            cursor.execute('''
                INSERT INTO additional_notes (first_name, last_name, user_name, username, email, company, ticket, password, notes, tab_order)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (first_name, last_name, user_name, username, email, company, ticket, password, notes, self.tabs.count()))
            self.dbConnection.commit()
            return cursor.lastrowid
        except Exception as e:
            self.handleDBError(e)
            return None

    def updateAdditionalNotes(self, note_id, first_name, last_name, user_name, username, email, company, ticket, password, notes):
        try:
            cursor = self.dbConnection.cursor()
            cursor.execute('''
                UPDATE additional_notes
                SET first_name = ?, last_name = ?, user_name = ?, username = ?, email = ?, company = ?, ticket = ?, password = ?, notes = ?
                WHERE id = ?
            ''', (first_name, last_name, user_name, username, email, company, ticket, password, notes, note_id))
            self.dbConnection.commit()
        except Exception as e:
            self.handleDBError(e)

    def deleteAdditionalNotes(self, note_id):
        try:
            cursor = self.dbConnection.cursor()
            cursor.execute('DELETE FROM additional_notes WHERE id = ?', (note_id,))
            self.dbConnection.commit()
        except Exception as e:
            self.handleDBError(e)

    def loadAdditionalNotes(self):
        try:
            cursor = self.dbConnection.cursor()
            cursor.execute('SELECT * FROM additional_notes ORDER BY tab_order')
            notes = cursor.fetchall()
            for note in notes:
                self.addTabFromDatabase(note[0])
        except Exception as e:
            self.handleDBError(e)

    def checkAndRepairDatabase(self):
        try:
            cursor = self.dbConnection.cursor()
            cursor.execute("PRAGMA table_info(additional_notes)")
            columns = [col[1] for col in cursor.fetchall()]

            required_columns = {'id', 'first_name', 'last_name', 'user_name', 'username', 'email', 'company', 'ticket', 'password', 'notes', 'tab_order'}
            if set(columns) != required_columns:
                self.backupAndRecreateDatabase(columns)
        except Exception as e:
            self.handleDBError(e)

    def backupAndRecreateDatabase(self, columns):
        try:
            print("backupAndRecreateDatabase Debug Message 1")
            backup_path = 'additional_notes_backup.db'
            if os.path.exists(backup_path):
                os.remove(backup_path)
            self.dbConnection.close()
            os.rename('additional_notes.db', backup_path)

            self.dbConnection = sqlite3.connect('additional_notes.db')
            self.setupDatabase()

            print("backupAndRecreateDatabase Debug Message 2")
            if 'id' in columns:
                cursor = sqlite3.connect(backup_path).cursor()
                cursor.execute('SELECT * FROM additional_notes')
                rows = cursor.fetchall()

                for row in rows:
                    if debug_mode:
                        print("backupAndRecreateDatabase Debug Message 3 - " + row)
                    self.saveAdditionalNotes(*row[1:9])  # Skip id and tab_order
                self.parent.showMessage("Database structure updated and data imported from backup.")
        except Exception as e:
            self.handleDBError(e)

    def handleDBError(self, error):
        QMessageBox.information(self, "Database Error", "Database Error: " + str(error))

    def getTabIndexById(self, note_id):
        for index in range(self.tabs.count()):
            tab_name = self.tabs.tabText(index)
            if tab_name == f"Note {note_id}":
                return index
        return None

    def deleteNoteFromTab(self, tab_name, note_id):
        if tab_name.startswith("Note"):
            self.deleteAdditionalNotes(note_id)
            tab_index = self.tabs.currentIndex()
            self.tabs.removeTab(tab_index)

    def createNewTab(self):
        tab_count = self.tabs.count()
        tab_name = f"Tab {tab_count + 1}"
        tab = self.createTab(tab_name)
        self.tabs.addTab(tab, tab_name)
        self.tabs.setCurrentWidget(tab)

class CalculatorWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)

        self.display = QLineEdit()
        self.display.setReadOnly(True)
        self.display.setStyleSheet("font-size: 24px; padding: 10px;")
        layout.addWidget(self.display)

        self.button_layout = QGridLayout()
        self.createButtons()
        layout.addLayout(self.button_layout)

        self.scientific_mode = False
        self.scientific_buttons = []
        self.createScientificButtons()

        self.mode_button = QPushButton("Scientific Mode")
        self.mode_button.clicked.connect(self.toggleScientificMode)
        layout.addWidget(self.mode_button)

    def createButtons(self):
        buttons = [
            ("7", 0, 0), ("8", 0, 1), ("9", 0, 2), ("C", 0, 3),
            ("4", 1, 0), ("5", 1, 1), ("6", 1, 2), ("/", 1, 3),
            ("1", 2, 0), ("2", 2, 1), ("3", 2, 2), ("*", 2, 3),
            ("0", 3, 0), (".", 3, 1), ("+", 3, 2), ("-", 3, 3),
            ("=", 4, 2)
        ]

        for text, row, col in buttons:
            button = QPushButton(text)
            button.setStyleSheet("font-size: 18px; padding: 10px;")
            button.clicked.connect(lambda checked, x=text: self.buttonClicked(x))
            self.button_layout.addWidget(button, row, col)

    def createScientificButtons(self):
        scientific_buttons = [
            ("sin", 0, 0), ("cos", 0, 1), ("tan", 0, 2), ("log", 0, 3),
            ("sqrt", 1, 0), ("pow", 1, 1), ("pi", 1, 2), ("e", 1, 3)
        ]

        for text, row, col in scientific_buttons:
            button = QPushButton(text)
            button.setStyleSheet("font-size: 18px; padding: 10px;")
            button.clicked.connect(lambda checked, x=text: self.scientificButtonClicked(x))
            self.scientific_buttons.append(button)
            self.button_layout.addWidget(button, row + 5, col)

    def toggleScientificMode(self):
        self.scientific_mode = not self.scientific_mode
        for button in self.scientific_buttons:
            button.setVisible(self.scientific_mode)
        self.mode_button.setText("Standard Mode" if self.scientific_mode else "Scientific Mode")

    def buttonClicked(self, text):
        if text == "C":
            self.display.clear()
        elif text == "=":
            try:
                result = str(eval(self.display.text()))
                self.display.setText(result)
            except:
                self.display.setText("Error")
        else:
            self.display.setText(self.display.text() + text)

    def scientificButtonClicked(self, text):
        if text == "sin":
            self.display.setText(str(math.sin(float(self.display.text()))))
        elif text == "cos":
            self.display.setText(str(math.cos(float(self.display.text()))))
        elif text == "tan":
            self.display.setText(str(math.tan(float(self.display.text()))))
        elif text == "log":
            self.display.setText(str(math.log10(float(self.display.text()))))
        elif text == "sqrt":
            self.display.setText(str(math.sqrt(float(self.display.text()))))
        elif text == "pow":
            num, ok = QInputDialog.getDouble(self, "Power", "Enter the power:", 2.0, -100.0, 100.0, 2)
            if ok:
                self.display.setText(str(float(self.display.text()) ** num))
        elif text == "pi":
            self.display.setText(str(math.pi))
        elif text == "e":
            self.display.setText(str(math.e))

class PreviewWidget(QWidget):
    def __init__(self, file_path):
        super().__init__()
        self.file_path = file_path
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)
        
        if self.file_path.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
            image = QImage(self.file_path)
            pixmap = QPixmap.fromImage(image)
            label = QLabel()
            label.setPixmap(pixmap.scaled(300, 300, Qt.KeepAspectRatio, Qt.SmoothTransformation))
            layout.addWidget(label)
        elif self.file_path.lower().endswith(('.mp4', '.avi', '.mov')):
            video_widget = QVideoWidget()
            media_player = QMediaPlayer(None, QMediaPlayer.VideoSurface)
            media_player.setVideoOutput(video_widget)
            media_player.setMedia(QMediaContent(QUrl.fromLocalFile(self.file_path)))
            layout.addWidget(video_widget)
            media_player.play()
        elif self.file_path.lower().endswith(('.txt', '.py', '.html', '.css', '.js')):
            with open(self.file_path, 'r', encoding='utf-8') as file:
                content = file.read()
            text_edit = QTextEdit()
            text_edit.setPlainText(content)
            text_edit.setReadOnly(True)
            layout.addWidget(text_edit)
        else:
            label = QLabel("No preview available for this file type.")
            layout.addWidget(label)

class CustomToolBar(QToolBar):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setMovable(True)

    def dragEnterEvent(self, event):
        if event.mimeData().hasText():
            event.acceptProposedAction()

    def dropEvent(self, event):
        pos = event.pos()
        button = self.childAt(pos)
        if button:
            index = self.actions().index(button.defaultAction())
            self.insertAction(self.actions()[index], self.actionAt(event.pos()))
        else:
            self.addAction(self.actionAt(event.pos()))
        event.acceptProposedAction()

class FileSystemProxyModel(QSortFilterProxyModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.filter_options = {}

    def setFilterOptions(self, options):
        self.filter_options = options
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        index = self.sourceModel().index(source_row, 0, source_parent)
        file_path = self.sourceModel().filePath(index)

        if 'text' in self.filter_options:
            if self.filter_options['text'].lower() not in os.path.basename(file_path).lower():
                return False

        if 'type' in self.filter_options:
            if self.filter_options['type'] == 'file' and os.path.isdir(file_path):
                return False
            if self.filter_options['type'] == 'folder' and not os.path.isdir(file_path):
                return False

        # Add more filter conditions as needed

        return True

    def setFilterText(self, text):
        self.filter_options['text'] = text
        self.invalidateFilter()

class FileFolderViewWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.clipboard = []
        self.quick_access_folders = []
        self.initUI()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if hasattr(self, 'preview_widget'):
            self.updatePreview(self.file_system_model.filePath(self.proxy_model.mapToSource(self.file_view.currentIndex())))

    def initUI(self):
        layout = QVBoxLayout(self)

        # Toolbar
        self.toolbar = QToolBar(self)
        self.addToolbarButton("Home", "🏠", self.goHome)
        self.addToolbarButton("Up", "⬆️", self.goUp)
        self.addToolbarButton("Copy", "📋", self.copySelected)
        self.addToolbarButton("Paste", "📌", self.pasteFiles)
        self.addToolbarButton("Delete", "🗑️", self.deleteSelected)
        self.addToolbarButton("Folder", "📁", self.createFolder)
        self.addToolbarButton("File", "📄", self.createFile)
    
        layout.addWidget(self.toolbar)

        # Search Bar
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("Search files and folders")
        self.search_bar.textChanged.connect(self.filterFiles)
        layout.addWidget(self.search_bar)

        # Breadcrumb Navigation
        self.breadcrumb = QComboBox()
        self.breadcrumb.setEditable(True)
        self.breadcrumb.activated[str].connect(self.onBreadcrumbActivated)
        layout.addWidget(self.breadcrumb)

        # Tab Widget
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)

        # File View and Preview Area
        file_view_widget = QWidget()
        file_view_layout = QVBoxLayout(file_view_widget)

        self.file_view = QTreeView()
        self.file_system_model = QFileSystemModel()
        self.file_system_model.setRootPath(QDir.rootPath())
    
        self.proxy_model = FileSystemProxyModel(self)
        self.proxy_model.setSourceModel(self.file_system_model)
    
        self.file_view.setModel(self.proxy_model)
        self.file_view.setRootIndex(self.proxy_model.mapFromSource(self.file_system_model.index(QDir.rootPath())))
        self.file_view.setSelectionMode(QTreeView.ExtendedSelection)
        self.file_view.clicked.connect(self.onItemClicked)
        self.file_view.setContextMenuPolicy(Qt.CustomContextMenu)
        self.file_view.customContextMenuRequested.connect(self.showContextMenu)
        file_view_layout.addWidget(self.file_view, 2)

        self.preview_area = QScrollArea()
        self.preview_area.setWidgetResizable(True)
        self.preview_area.setMinimumWidth(200)
        self.preview_widget = QLabel("No preview available")
        self.preview_widget.setAlignment(Qt.AlignCenter)
        self.preview_area.setWidget(self.preview_widget)
        file_view_layout.addWidget(self.preview_area, 1)

        self.tab_widget.addTab(file_view_widget, "File View")

        # Collapse/Expand Preview Button
        self.toggle_preview_button = QPushButton("Toggle Preview")
        self.toggle_preview_button.clicked.connect(self.togglePreview)
        file_view_layout.addWidget(self.toggle_preview_button)

        # Read-Only Textbox as Status Bar
        self.status_bar = QLineEdit()
        self.status_bar.setReadOnly(True)
        layout.addWidget(self.status_bar)

        self.current_path = QDir.rootPath()
        self.updateBreadcrumb()
        self.updateStatusBar()

        # Add System Info Tab
        self.system_info_widget = SystemInfoWidget()
        self.tab_widget.addTab(self.system_info_widget, "System Info")
        self.toggle_preview_button.toggle()

    def updateStatusBar(self, message=None):
        if message:
            self.status_bar.setText(message)
        else:
            try:
                total_size = sum(os.path.getsize(os.path.join(self.current_path, f)) for f in os.listdir(self.current_path) if os.path.isfile(os.path.join(self.current_path, f)))
                num_files = len([f for f in os.listdir(self.current_path) if os.path.isfile(os.path.join(self.current_path, f))])
                num_folders = len([f for f in os.listdir(self.current_path) if os.path.isdir(os.path.join(self.current_path, f))])
                self.status_bar.setText(f"{num_files} files, {num_folders} folders, Total size: {self.format_size(total_size)}")
            except Exception as e:
                logging.error(f"Error updating status bar: {e}")
                self.status_bar.setText("Error updating status")

    def addToolbarButton(self, text, icon, callback):
        action = self.toolbar.addAction(icon + " " + text, callback)
        action.setData(text)

    def goHome(self):
        try:
            self.changeDirectory(QDir.homePath())
        except Exception as e:
            logging.error(f"Error navigating to home directory: {e}")

    def goUp(self):
        try:
            parent_path = os.path.dirname(self.current_path)
            self.changeDirectory(parent_path)
        except Exception as e:
            logging.error(f"Error navigating up: {e}")

    def copySelected(self):
        try:
            self.clipboard = [self.proxy_model.mapToSource(index) for index in self.file_view.selectedIndexes() if index.column() == 0]
            self.updateStatusBar(f"{len(self.clipboard)} item(s) copied")
        except Exception as e:
            logging.error(f"Error copying selected items: {e}")

    def pasteFiles(self):
        try:
            for index in self.clipboard:
                source_path = self.file_system_model.filePath(index)
                dest_path = os.path.join(self.current_path, os.path.basename(source_path))
                if os.path.isfile(source_path):
                    shutil.copy2(source_path, dest_path)
                elif os.path.isdir(source_path):
                    shutil.copytree(source_path, dest_path)
            self.updateStatusBar(f"{len(self.clipboard)} item(s) pasted")
            self.clipboard.clear()
        except Exception as e:
            logging.error(f"Error pasting files: {e}")

    def deleteSelected(self):
        try:
            selected = [self.file_system_model.filePath(self.proxy_model.mapToSource(index)) 
                        for index in self.file_view.selectedIndexes() if index.column() == 0]
            if selected:
                reply = QMessageBox.question(self, "Confirm Delete", f"Are you sure you want to delete {len(selected)} item(s)?")
                if reply == QMessageBox.Yes:
                    for path in selected:
                        if os.path.isfile(path):
                            os.remove(path)
                        elif os.path.isdir(path):
                            shutil.rmtree(path)
                    self.updateStatusBar(f"{len(selected)} item(s) deleted")
        except Exception as e:
            logging.error(f"Error deleting selected items: {e}")

    def createFolder(self):
        try:
            name, ok = QInputDialog.getText(self, "Create Folder", "Enter folder name:")
            if ok and name:
                path = os.path.join(self.current_path, name)
                os.makedirs(path, exist_ok=True)
                self.updateStatusBar(f"Folder '{name}' created")
        except Exception as e:
            logging.error(f"Error creating folder: {e}")

    def createFile(self):
        try:
            name, ok = QInputDialog.getText(self, "Create File", "Enter file name:")
            if ok and name:
                path = os.path.join(self.current_path, name)
                open(path, 'a').close()
                self.updateStatusBar(f"File '{name}' created")
        except Exception as e:
            logging.error(f"Error creating file: {e}")

    def moveSelected(self):
        try:
            selected = [self.file_system_model.filePath(self.proxy_model.mapToSource(index)) 
                        for index in self.file_view.selectedIndexes() if index.column() == 0]
            if selected:
                dest = QFileDialog.getExistingDirectory(self, "Select Destination")
                if dest:
                    for path in selected:
                        shutil.move(path, os.path.join(dest, os.path.basename(path)))
                    self.updateStatusBar(f"{len(selected)} item(s) moved")
        except Exception as e:
            logging.error(f"Error moving selected items: {e}")

    def showAdvancedSearch(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("Advanced Search")
        layout = QVBoxLayout(dialog)

        type_combo = QComboBox()
        type_combo.addItems(["Any", "File", "Folder"])
        layout.addWidget(QLabel("Type:"))
        layout.addWidget(type_combo)

        date_from = QDateEdit()
        date_from.setCalendarPopup(True)
        layout.addWidget(QLabel("Date From:"))
        layout.addWidget(date_from)

        date_to = QDateEdit()
        date_to.setCalendarPopup(True)
        layout.addWidget(QLabel("Date To:"))
        layout.addWidget(date_to)

        size_min = QSpinBox()
        size_min.setSuffix(" MB")
        layout.addWidget(QLabel("Minimum Size (MB):"))
        layout.addWidget(size_min)

        size_max = QSpinBox()
        size_max.setSuffix(" MB")
        layout.addWidget(QLabel("Maximum Size (MB):"))
        layout.addWidget(size_max)

        search_button = QPushButton("Search")
        layout.addWidget(search_button)

        def on_search():
            options = {}
            if type_combo.currentText() != "Any":
                options['type'] = type_combo.currentText().lower()
            if date_from.date() != date_from.minimumDate():
                options['date_from'] = date_from.date().toPyDate()
            if date_to.date() != date_to.minimumDate():
                options['date_to'] = date_to.date().toPyDate()
            if size_min.value() > 0:
                options['size_min'] = size_min.value()
            if size_max.value() > 0:
                options['size_max'] = size_max.value()
            
            self.proxy_model.setFilterOptions(options)
            dialog.accept()

        search_button.clicked.connect(on_search)
        dialog.exec_()

    def filterFiles(self, text):
        self.proxy_model.setFilterText(text)
        self.file_view.expandAll()
        self.updateStatusBar()

    def onItemDoubleClicked(self, index):
        try:
            source_index = self.proxy_model.mapToSource(index)
            path = self.file_system_model.filePath(source_index)
            if os.path.isdir(path):
                self.changeDirectory(path)
            else:
                self.openFile(path)
        except Exception as e:
            logging.error(f"Error handling item double click: {e}")

    def openFile(self, path):
        try:
            QDesktopServices.openUrl(QUrl.fromLocalFile(path))
            self.addPreviewTab(path)
        except Exception as e:
            logging.error(f"Error opening file: {e}")

    def onItemClicked(self, index):
        try:
            source_index = self.proxy_model.mapToSource(index)
            path = self.file_system_model.filePath(source_index)
            self.updatePreview(path)
        except Exception as e:
            logging.error(f"Error handling item click: {e}")

    def updatePreview(self, path):
        try:
            if os.path.isfile(path):
                if path.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
                    pixmap = QPixmap(path)
                    scaled_pixmap = pixmap.scaled(self.preview_area.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    self.preview_widget.setPixmap(scaled_pixmap)
                else:
                    self.preview_widget.setText("No preview available for this file type")
            else:
                self.preview_widget.setText("Select a file to preview")
        except Exception as e:
            logging.error(f"Error updating preview: {e}")

    def showContextMenu(self, position):
        menu = QMenu()
        open_action = menu.addAction("Open")
        copy_action = menu.addAction("Copy")
        paste_action = menu.addAction("Paste")
        delete_action = menu.addAction("Delete")
        rename_action = menu.addAction("Rename")
        add_to_quick_access_action = menu.addAction("Add to Quick Access")

        action = menu.exec_(self.file_view.mapToGlobal(position))
        try:
            if action == open_action:
                self.onItemDoubleClicked(self.file_view.indexAt(position))
            elif action == copy_action:
                self.copySelected()
            elif action == paste_action:
                self.pasteFiles()
            elif action == delete_action:
                self.deleteSelected()
            elif action == rename_action:
                self.renameSelected()
            elif action == add_to_quick_access_action:
                self.addToQuickAccess()
        except Exception as e:
            logging.error(f"Error handling context menu action: {e}")

    def renameSelected(self):
        try:
            indexes = self.file_view.selectedIndexes()
            if len(indexes) == 1:
                index = self.proxy_model.mapToSource(indexes[0])
                old_name = self.file_system_model.fileName(index)
                new_name, ok = QInputDialog.getText(self, "Rename", "Enter new name:", text=old_name)
                if ok and new_name:
                    old_path = self.file_system_model.filePath(index)
                    new_path = os.path.join(os.path.dirname(old_path), new_name)
                    os.rename(old_path, new_path)
                    self.updateStatusBar(f"Renamed '{old_name}' to '{new_name}'")
        except Exception as e:
            logging.error(f"Error renaming selected item: {e}")

    def changeDirectory(self, path):
        try:
            self.current_path = path
            source_index = self.file_system_model.index(path)
            proxy_index = self.proxy_model.mapFromSource(source_index)
            self.file_view.setRootIndex(proxy_index)
            self.updateBreadcrumb()
            self.updateStatusBar()
        except Exception as e:
            logging.error(f"Error changing directory: {e}")

    def updateBreadcrumb(self):
        try:
            self.breadcrumb.clear()
            path = self.current_path
            while path != os.path.dirname(path):
                self.breadcrumb.insertItem(0, os.path.basename(path) or path, path)
                path = os.path.dirname(path)
        except Exception as e:
            logging.error(f"Error updating breadcrumb: {e}")

    def onBreadcrumbActivated(self, path):
        try:
            self.changeDirectory(path)
        except Exception as e:
            logging.error(f"Error activating breadcrumb: {e}")

    @staticmethod
    def format_size(size):
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0

    def addPreviewTab(self, file_path):
        try:
            file_name = os.path.basename(file_path)
            preview_widget = QLabel(f"Preview of {file_name}")
            self.tab_widget.addTab(preview_widget, file_name)
            self.tab_widget.setCurrentIndex(self.tab_widget.count() - 1)
        except Exception as e:
            logging.error(f"Error adding preview tab: {e}")

    def closePreviewTab(self, index):
        try:
            self.tab_widget.removeTab(index)
        except Exception as e:
            logging.error(f"Error closing preview tab: {e}")

    def updateQuickAccessPanel(self):
        try:
            self.quick_access_list.clear()
            for folder in self.quick_access_folders:
                self.quick_access_list.addItem(folder)
        except Exception as e:
            logging.error(f"Error updating quick access panel: {e}")

    def onQuickAccessItemClicked(self, item):
        try:
            self.changeDirectory(item.text())
        except Exception as e:
            logging.error(f"Error handling quick access item click: {e}")

    def addToQuickAccess(self):
        try:
            indexes = self.file_view.selectedIndexes()
            if len(indexes) == 1:
                index = self.proxy_model.mapToSource(indexes[0])
                path = self.file_system_model.filePath(index)
                if os.path.isdir(path) and path not in self.quick_access_folders:
                    self.quick_access_folders.append(path)
                    self.updateQuickAccessPanel()
                    self.saveSettings()
        except Exception as e:
            logging.error(f"Error adding to quick access: {e}")

    def batchRename(self):
        try:
            selected = [self.file_system_model.filePath(self.proxy_model.mapToSource(index)) 
                        for index in self.file_view.selectedIndexes() if index.column() == 0]
            if not selected:
                return

            dialog = QDialog(self)
            dialog.setWindowTitle("Batch Rename")
            layout = QVBoxLayout(dialog)

            prefix_input = QLineEdit()
            layout.addWidget(QLabel("Prefix:"))
            layout.addWidget(prefix_input)

            suffix_input = QLineEdit()
            layout.addWidget(QLabel("Suffix:"))
            layout.addWidget(suffix_input)

            start_number = QSpinBox()
            start_number.setMinimum(0)
            layout.addWidget(QLabel("Start Number:"))
            layout.addWidget(start_number)

            rename_button = QPushButton("Rename")
            layout.addWidget(rename_button)

            def on_rename():
                prefix = prefix_input.text()
                suffix = suffix_input.text()
                start = start_number.value()

                for i, path in enumerate(selected):
                    dir_name = os.path.dirname(path)
                    file_name = os.path.basename(path)
                    name, ext = os.path.splitext(file_name)
                    new_name = f"{prefix}{start + i}{suffix}{ext}"
                    new_path = os.path.join(dir_name, new_name)
                    os.rename(path, new_path)

                self.updateStatusBar(f"Renamed {len(selected)} items")
                dialog.accept()

            rename_button.clicked.connect(on_rename)
            dialog.exec_()
        except Exception as e:
            logging.error(f"Error performing batch rename: {e}")

    def customizeToolbar(self):
        try:
            dialog = QDialog(self)
            dialog.setWindowTitle("Customize Toolbar")
            layout = QVBoxLayout(dialog)

            available_actions = [action for action in self.toolbar.actions()]
            action_list = QListWidget()
            for action in available_actions:
                item = QListWidgetItem(action.data())
                item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
                item.setCheckState(Qt.Checked if action.isVisible() else Qt.Unchecked)
                action_list.addItem(item)

            layout.addWidget(action_list)

            save_button = QPushButton("Save")
            layout.addWidget(save_button)

            def on_save():
                for i in range(action_list.count()):
                    item = action_list.item(i)
                    action = available_actions[i]
                    action.setVisible(item.checkState() == Qt.Checked)
                self.saveSettings()
                dialog.accept()

            save_button.clicked.connect(on_save)
            dialog.exec_()
        except Exception as e:
            logging.error(f"Error customizing toolbar: {e}")

    def saveSettings(self):
        try:
            settings = QSettings("MyCompany", "FileFolderViewer")
            settings.beginGroup("QuickAccess")
            settings.setValue("folders", self.quick_access_folders)
            settings.endGroup()

            settings.beginGroup("Toolbar")
            visible_actions = [action.data() for action in self.toolbar.actions() if action.isVisible()]
            settings.setValue("visibleActions", visible_actions)
            settings.endGroup()
        except Exception as e:
            logging.error(f"Error saving settings: {e}")

    def loadSettings(self):
        try:
            settings = QSettings("MyCompany", "FileFolderViewer")
            settings.beginGroup("QuickAccess")
            self.quick_access_folders = settings.value("folders", [])
            settings.endGroup()

            settings.beginGroup("Toolbar")
            visible_actions = settings.value("visibleActions", [])
            for action in self.toolbar.actions():
                action.setVisible(action.data() in visible_actions)
            settings.endGroup()

            self.updateQuickAccessPanel()
        except Exception as e:
            logging.error(f"Error loading settings: {e}")

    def keyPressEvent(self, event):
        try:
            if event.key() == Qt.Key_Delete:
                self.deleteSelected()
            elif event.matches(QKeySequence.Copy):
                self.copySelected()
            elif event.matches(QKeySequence.Paste):
                self.pasteFiles()
            elif event.matches(QKeySequence.Find):
                self.search_bar.setFocus()
            else:
                super().keyPressEvent(event)
        except Exception as e:
            logging.error(f"Error handling key press event: {e}")

    def togglePreview(self):
        try:
            if self.preview_area.isVisible():
                self.preview_area.hide()
                self.toggle_preview_button.setText("Show Preview")
            else:
                self.preview_area.show()
                self.toggle_preview_button.setText("Hide Preview")
        except Exception as e:
            logging.error(f"Error toggling preview: {e}")

class SystemInfoWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.paused = False
        self.dark_mode = True  # Default to dark mode
        self.initUI()
        self.system_info_worker = SystemInfoWorker()
        self.system_info_worker.updateSystemInfo.connect(self.updateInfo)
        self.system_info_worker.start()

    def initUI(self):
        layout = QVBoxLayout(self)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)

        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        layout.addWidget(self.scroll_area)

        # Create initial sections
        self.system_info_groupbox = self.addInfoSection("System Information")
        self.os_info_groupbox = self.addInfoSection("OS Information")
        self.cpu_info_groupbox = self.addInfoSection("CPU Information")
        self.memory_info_groupbox = self.addInfoSection("Memory Information")
        self.disk_info_groupbox = self.addInfoSection("Disk Information")
        self.network_info_groupbox = self.addNetworkInfoSection("Network Information")

        # Buttons
        button_layout = QHBoxLayout()
        self.clipboard_button = QPushButton("Copy to Clipboard")
        self.save_button = QPushButton("Save")
        self.pause_button = QPushButton("Pause")
        self.clipboard_button.clicked.connect(self.copyToClipboard)
        self.save_button.clicked.connect(self.saveToFile)
        self.pause_button.clicked.connect(self.togglePauseResume)

        button_layout.addWidget(self.clipboard_button)
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.pause_button)

        # Toggle Dark/Light Mode
        self.toggle_mode_button = QPushButton("Toggle Dark/Light Mode")
        self.toggle_mode_button.clicked.connect(self.toggleMode)
        button_layout.addWidget(self.toggle_mode_button)

        layout.addLayout(button_layout)

        self.setLayout(layout)
        self.applyMode()

    def addInfoSection(self, title):
        section_frame = QFrame()
        section_frame.setFrameShape(QFrame.StyledPanel)
        section_layout = QVBoxLayout(section_frame)

        toggle_button = QCheckBox(title)
        toggle_button.setChecked(True)
        section_layout.addWidget(toggle_button)

        section_groupbox = QGroupBox()
        section_groupbox.setLayout(QGridLayout())
        section_layout.addWidget(section_groupbox)

        toggle_button.stateChanged.connect(lambda state: section_groupbox.setVisible(state == Qt.Checked))

        self.scroll_layout.addWidget(section_frame)
        return section_groupbox

    def addNetworkInfoSection(self, title):
        section_frame = QFrame()
        section_frame.setFrameShape(QFrame.StyledPanel)
        section_layout = QVBoxLayout(section_frame)

        toggle_button = QCheckBox(title)
        toggle_button.setChecked(True)
        section_layout.addWidget(toggle_button)

        section_groupbox = QGroupBox()
        section_groupbox.setLayout(QVBoxLayout())
        section_layout.addWidget(section_groupbox)

        toggle_button.stateChanged.connect(lambda state: section_groupbox.setVisible(state == Qt.Checked))

        self.scroll_layout.addWidget(section_frame)
        return section_groupbox

    @pyqtSlot(dict)
    def updateInfo(self, info):
        if not self.paused:
            self.updateSection(self.system_info_groupbox, info['system'])
            self.updateSection(self.os_info_groupbox, info['os'])
            self.updateSection(self.cpu_info_groupbox, info['cpu'])
            self.updateSection(self.memory_info_groupbox, info['memory'])
            self.updateSection(self.disk_info_groupbox, info['disk'])
            self.updateNetworkSection(self.network_info_groupbox, info['network'])

    def updateSection(self, groupbox, details):
        layout = groupbox.layout()
        self.clearLayout(layout)
        
        for row, (key, value) in enumerate(details.items()):
            key_label = QLabel(key)
            value_label = QLabel(str(value))
            value_label.setWordWrap(True)
            layout.addWidget(key_label, row, 0)
            layout.addWidget(value_label, row, 1)

    def updateNetworkSection(self, groupbox, network_details):
        layout = groupbox.layout()
        self.clearLayout(layout)

        for adapter, details in network_details.items():
            adapter_groupbox = QGroupBox(adapter)
            adapter_layout = QGridLayout()
            adapter_groupbox.setLayout(adapter_layout)

            for row, (key, value) in enumerate(details.items()):
                key_label = QLabel(key)
                value_label = QLabel(str(value))
                value_label.setWordWrap(True)
                adapter_layout.addWidget(key_label, row, 0)
                adapter_layout.addWidget(value_label, row, 1)

            layout.addWidget(adapter_groupbox)

    def clearLayout(self, layout):
        while layout.count():
            child = layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

    def copyToClipboard(self):
        clipboard = QApplication.clipboard()
        text = self.collectInformationText()
        clipboard.setText(text)

    def saveToFile(self):
        file_name, _ = QFileDialog.getSaveFileName(self, "Save File", "", "Text Files (*.txt);;All Files (*)")
        if file_name:
            with open(file_name, 'w') as file:
                file.write(self.collectInformationText())

    def collectInformationText(self):
        text = ""
        for i in range(self.scroll_layout.count()):
            frame = self.scroll_layout.itemAt(i).widget()
            if isinstance(frame, QFrame):
                checkbox = frame.layout().itemAt(0).widget()
                if isinstance(checkbox, QCheckBox):
                    text += f"\n{checkbox.text()}\n{'=' * len(checkbox.text())}\n"
                    groupbox = frame.layout().itemAt(1).widget()
                    layout = groupbox.layout()
                    if isinstance(layout, QGridLayout):
                        for j in range(layout.rowCount()):
                            key_item = layout.itemAtPosition(j, 0)
                            value_item = layout.itemAtPosition(j, 1)
                            if key_item and value_item:
                                key = key_item.widget().text()
                                value = value_item.widget().text()
                                text += f"{key}: {value}\n"
                    elif isinstance(layout, QVBoxLayout):
                        for j in range(layout.count()):
                            adapter_groupbox = layout.itemAt(j).widget()
                            if isinstance(adapter_groupbox, QGroupBox):
                                text += f"\n  {adapter_groupbox.title()}\n  {'-' * len(adapter_groupbox.title())}\n"
                                adapter_layout = adapter_groupbox.layout()
                                for k in range(adapter_layout.rowCount()):
                                    key_item = adapter_layout.itemAtPosition(k, 0)
                                    value_item = adapter_layout.itemAtPosition(k, 1)
                                    if key_item and value_item:
                                        key = key_item.widget().text()
                                        value = value_item.widget().text()
                                        text += f"  {key}: {value}\n"
        return text

    def togglePauseResume(self):
        self.paused = not self.paused
        self.pause_button.setText("Resume" if self.paused else "Pause")

    def toggleMode(self):
        self.dark_mode = not self.dark_mode
        self.applyMode()

    def applyMode(self):
        if self.dark_mode:
            self.setStyleSheet("""
                QWidget { background-color: #2e2e2e; color: #ffffff; }
                QGroupBox { border: 1px solid #ffffff; border-radius: 5px; margin-top: 1ex; }
                QGroupBox::title { subcontrol-origin: margin; left: 10px; padding: 0 3px 0 3px; }
                QPushButton { background-color: #4a4a4a; border: 1px solid #ffffff; border-radius: 3px; padding: 5px; }
                QPushButton:hover { background-color: #5a5a5a; }
                QLabel { border: 1px solid #ffffff; border-radius: 3px; padding: 5px; }
            """)
        else:
            self.setStyleSheet("""
                QWidget { background-color: #ffffff; color: #000000; }
                QGroupBox { border: 1px solid #000000; border-radius: 5px; margin-top: 1ex; }
                QGroupBox::title { subcontrol-origin: margin; left: 10px; padding: 0 3px 0 3px; }
                QPushButton { background-color: #e0e0e0; border: 1px solid #000000; border-radius: 3px; padding: 5px; }
                QPushButton:hover { background-color: #d0d0d0; }
                QLabel { border: 1px solid #000000; border-radius: 3px; padding: 5px; }
            """)

class SystemInfoWorker(QThread):
    updateSystemInfo = pyqtSignal(dict)

    def __init__(self):
        super().__init__()
        self.last_info = None

    def run(self):
        while True:
            current_info = self.get_system_info()
            if self.last_info != current_info:
                self.updateSystemInfo.emit(current_info)
                self.last_info = current_info
            time.sleep(5)  # Refresh every 5 seconds

    def get_system_info(self):
        try:
            pythoncom.CoInitialize()
            return {
                'system': SystemInfo.get_system_info(),
                'os': SystemInfo.get_os_info(),
                'cpu': SystemInfo.get_cpu_info(),
                'memory': SystemInfo.get_memory_info(),
                'disk': SystemInfo.get_disk_info(),
                'network': SystemInfo.get_network_info()
            }
        except Exception as e:
            print(f"Error retrieving system information: {e}")
            return {}
        finally:
            pythoncom.CoUninitialize()

class SystemInfo:
    @staticmethod
    def get_system_info():
        wmi_obj = wmi.WMI()
        computer_system = wmi_obj.Win32_ComputerSystem()[0]
        bios = wmi_obj.Win32_BIOS()[0]

        return {
            "Machine Name": platform.node(),
            "Manufacturer": computer_system.Manufacturer,
            "Model": computer_system.Model,
            "System Type": computer_system.SystemType,
            "BIOS Version": bios.Version,
            "BIOS Manufacturer": bios.Manufacturer,
            "BIOS Serial Number": bios.SerialNumber
        }

    @staticmethod
    def get_os_info():
        wmi_obj = wmi.WMI()
        os_info = wmi_obj.Win32_OperatingSystem()[0]

        return {
            "OS Name": os_info.Caption,
            "OS Version": os_info.Version,
            "OS Manufacturer": os_info.Manufacturer,
            "OS Architecture": os_info.OSArchitecture,
            "OS Build Number": os_info.BuildNumber,
            "OS Registered User": os_info.RegisteredUser,
            "System Drive": os_info.SystemDrive,
            "Windows Directory": os_info.WindowsDirectory,
            "System Directory": os.environ['SystemRoot'],
            "Boot Device": os_info.BootDevice,
            "System Locale": os_info.Locale,
            "Input Locale": os_info.OSLanguage,
            "Time Zone": os_info.CurrentTimeZone
        }

    @staticmethod
    def get_cpu_info():
        wmi_obj = wmi.WMI()
        cpu_info = wmi_obj.Win32_Processor()[0]

        return {
            "Processor Name": cpu_info.Name,
            "Manufacturer": cpu_info.Manufacturer,
            "CPU ID": cpu_info.ProcessorId,
            "Core Count": cpu_info.NumberOfCores,
            "Logical Processors": cpu_info.NumberOfLogicalProcessors,
            "Max Clock Speed": f"{cpu_info.MaxClockSpeed} MHz",
            "Current Clock Speed": f"{cpu_info.CurrentClockSpeed} MHz",
            "Socket Designation": cpu_info.SocketDesignation,
            "L2 Cache Size": f"{cpu_info.L2CacheSize} KB",
            "L3 Cache Size": f"{cpu_info.L3CacheSize} KB",
            "CPU Load": f"{psutil.cpu_percent()}%"
        }

    @staticmethod
    def get_memory_info():
        memory = psutil.virtual_memory()
        swap = psutil.swap_memory()

        return {
            "Total Physical Memory": f"{memory.total / (1024**3):.2f} GB",
            "Available Physical Memory": f"{memory.available / (1024**3):.2f} GB",
            "Memory Usage": f"{memory.percent}%",
            "Total Virtual Memory": f"{(memory.total + swap.total) / (1024**3):.2f} GB",
            "Available Virtual Memory": f"{(memory.available + swap.free) / (1024**3):.2f} GB",
            "Used Virtual Memory": f"{(memory.used + swap.used) / (1024**3):.2f} GB"
        }

    @staticmethod
    def get_disk_info():
        disks = {}
        for partition in psutil.disk_partitions():
            try:
                partition_usage = psutil.disk_usage(partition.mountpoint)
            except PermissionError:
                continue
            disks[partition.device] = {
                "Mount Point": partition.mountpoint,
                "File System Type": partition.fstype,
                "Total Size": f"{partition_usage.total / (1024**3):.2f} GB",
                "Used Space": f"{partition_usage.used / (1024**3):.2f} GB",
                "Free Space": f"{partition_usage.free / (1024**3):.2f} GB",
                "Usage": f"{partition_usage.percent}%"
            }
        return disks

    @staticmethod
    def get_network_info():
        network_info = {}
        for interface, addrs in psutil.net_if_addrs().items():
            network_info[interface] = {}
            for addr in addrs:
                if addr.family == socket.AF_INET:
                    network_info[interface]["IPv4 Address"] = addr.address
                    network_info[interface]["IPv4 Netmask"] = addr.netmask
                elif addr.family == socket.AF_INET6:
                    network_info[interface]["IPv6 Address"] = addr.address
                elif addr.family == psutil.AF_LINK:
                    network_info[interface]["MAC Address"] = addr.address

            # Add network stats
            stats = psutil.net_if_stats()[interface]
            network_info[interface]["Status"] = "Up" if stats.isup else "Down"
            network_info[interface]["Speed"] = f"{stats.speed} Mbps"
            network_info[interface]["MTU"] = stats.mtu

        # Add external IP
        try:
            external_ip = requests.get('https://api.ipify.org').text
            network_info['External IP'] = {"Address": external_ip}
        except:
            network_info['External IP'] = {"Address": "Unable to retrieve"}

        return network_info
                   
class AlarmWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.initUI()
        self.initDB()
        self.loadAlarms()
        self.start_notification_timer()
        self.notification_manager = NotificationManager()

    def initUI(self):
        layout = QVBoxLayout(self)

        self.alarm_list = QListWidget()
        self.alarm_list.doubleClicked.connect(self.editAlarm)
        layout.addWidget(self.alarm_list)

        controls_layout = QHBoxLayout()
        self.add_alarm_button = QPushButton("Add Alarm")
        self.add_alarm_button.clicked.connect(self.addAlarm)
        self.delete_alarm_button = QPushButton("Delete Alarm")
        self.delete_alarm_button.clicked.connect(self.deleteAlarm)
        self.snooze_button = QPushButton("Snooze")
        self.snooze_button.clicked.connect(self.snoozeAlarm)
        controls_layout.addWidget(self.add_alarm_button)
        controls_layout.addWidget(self.delete_alarm_button)
        controls_layout.addWidget(self.snooze_button)
        layout.addLayout(controls_layout)

    def initDB(self):
        try:
            self.conn = sqlite3.connect('alarms.db')
            c = self.conn.cursor()
            c.execute("""CREATE TABLE IF NOT EXISTS alarms (
                         id INTEGER PRIMARY KEY AUTOINCREMENT,
                         alarm_time TEXT,
                         snooze_time TEXT,
                         created_at TEXT,
                         updated_at TEXT)""")
            c.execute("""CREATE TABLE IF NOT EXISTS alarm_usage (
                         id INTEGER PRIMARY KEY AUTOINCREMENT,
                         alarm_id INTEGER,
                         used_at TEXT,
                         FOREIGN KEY (alarm_id) REFERENCES alarms(id))""")
            self.conn.commit()
        except sqlite3.Error as e:
            logging.error(f"Error initializing database: {e}")
            QMessageBox.critical(self, "Error", "Failed to initialize the database.")

    def loadAlarms(self):
        try:
            c = self.conn.cursor()
            c.execute("SELECT * FROM alarms")
            alarms = c.fetchall()
            for alarm in alarms:
                self.alarm_list.addItem(f"{alarm[1]} (Snooze: {alarm[2]}, Created: {alarm[3]}, Updated: {alarm[4]})")
        except sqlite3.Error as e:
            logging.error(f"Error loading alarms: {e}")
            QMessageBox.critical(self, "Error", "Failed to load alarms from the database.")

    def addAlarm(self):
        date_time_dialog = DateTimeDialog("Set Alarm", "Enter alarm time:", parent=self)
        if date_time_dialog.exec_() == QDialog.Accepted:
            alarm_time = date_time_dialog.getDateTime().toString()
            snooze_time, ok = QInputDialog.getInt(self, "Set Snooze Time", "Enter snooze time (minutes):", 5, 1, 60)
            if ok:
                try:
                    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    c = self.conn.cursor()
                    c.execute("INSERT INTO alarms (alarm_time, snooze_time, created_at, updated_at) VALUES (?, ?, ?, ?)",
                              (alarm_time, str(snooze_time), now, now))
                    self.conn.commit()
                    self.alarm_list.addItem(f"{alarm_time} (Snooze: {snooze_time} minutes, Created: {now}, Updated: {now})")
                    logging.info(f"Added new alarm: {alarm_time} (Snooze: {snooze_time} minutes)")
                except sqlite3.Error as e:
                    logging.error(f"Error adding alarm: {e}")
                    QMessageBox.critical(self, "Error", "Failed to add the alarm to the database.")

    def editAlarm(self, index):
        item = self.alarm_list.item(index.row())
        alarm_time_snooze = item.text().split(" (Snooze: ")
        alarm_time = QDateTime.fromString(alarm_time_snooze[0])
        snooze_time = int(alarm_time_snooze[1][:-8])
        created_at = alarm_time_snooze[1].split(", Created: ")[1].split(", Updated: ")[0]
        updated_at = alarm_time_snooze[1].split(", Updated: ")[1][:-1]
        new_alarm_time, ok = QInputDialog.getDateTime(self, "Edit Alarm", "Enter new alarm time:", alarm_time)
        if ok:
            new_snooze_time, ok = QInputDialog.getInt(self, "Edit Snooze Time", "Enter new snooze time (minutes):", snooze_time, 1, 60)
            if ok:
                try:
                    c = self.conn.cursor()
                    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    c.execute("UPDATE alarms SET alarm_time = ?, snooze_time = ?, updated_at = ? WHERE alarm_time = ?", (new_alarm_time.toString(), str(new_snooze_time), now, alarm_time_snooze[0]))
                    self.conn.commit()
                    item.setText(f"{new_alarm_time.toString()} (Snooze: {new_snooze_time} minutes, Created: {created_at}, Updated: {now})")
                    logging.info(f"Edited alarm: {new_alarm_time.toString()} (Snooze: {new_snooze_time} minutes)")
                except sqlite3.Error as e:
                    logging.error(f"Error editing alarm: {e}")
                    QMessageBox.critical(self, "Error", "Failed to update the alarm in the database.")

    def deleteAlarm(self):
        selected = self.alarm_list.selectedItems()
        if selected:
            for item in selected:
                alarm_time_snooze = item.text().split(" (Snooze: ")
                try:
                    c = self.conn.cursor()
                    c.execute("DELETE FROM alarms WHERE alarm_time = ?", (alarm_time_snooze[0],))
                    c.execute("DELETE FROM alarm_usage WHERE alarm_id = (SELECT id FROM alarms WHERE alarm_time = ?)", (alarm_time_snooze[0],))
                    self.conn.commit()
                    self.alarm_list.takeItem(self.alarm_list.row(item))
                    logging.info(f"Deleted alarm: {alarm_time_snooze[0]}")
                except sqlite3.Error as e:
                    logging.error(f"Error deleting alarm: {e}")
                    QMessageBox.critical(self, "Error", "Failed to delete the alarm from the database.")

    def snoozeAlarm(self):
        selected = self.alarm_list.selectedItems()
        if selected:
            for item in selected:
                alarm_time_snooze = item.text().split(" (Snooze: ")
                alarm_time = QDateTime.fromString(alarm_time_snooze[0])
                snooze_time = int(alarm_time_snooze[1][:-8])
                new_alarm_time = alarm_time.addSecs(snooze_time * 60)
                try:
                    c = self.conn.cursor()
                    c.execute("UPDATE alarms SET alarm_time = ?, updated_at = ? WHERE alarm_time = ?", (new_alarm_time.toString(), datetime.now().strftime("%Y-%m-%d %H:%M:%S"), alarm_time_snooze[0]))
                    c.execute("INSERT INTO alarm_usage (alarm_id, used_at) VALUES ((SELECT id FROM alarms WHERE alarm_time = ?), ?)", (alarm_time_snooze[0], datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
                    self.conn.commit()
                    item.setText(f"{new_alarm_time.toString()} (Snooze: {snooze_time} minutes, Created: {alarm_time_snooze[1].split(', Created: ')[1].split(', Updated: ')[0]}, Updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')})")
                    logging.info(f"Snoozed alarm: {new_alarm_time.toString()} (Snooze: {snooze_time} minutes)")
                except sqlite3.Error as e:
                    logging.error(f"Error snoozing alarm: {e}")
                    QMessageBox.critical(self, "Error", "Failed to snooze the alarm in the database.")

    def start_notification_timer(self):
        self.notification_timer = QTimer(self)
        self.notification_timer.setInterval(60000)  # Check for alarms every minute
        self.notification_timer.timeout.connect(self.check_and_notify_alarms)
        self.notification_timer.start()

    def check_and_notify_alarms(self):
        try:
            c = self.conn.cursor()
            c.execute("SELECT alarm_time, snooze_time FROM alarms WHERE alarm_time <= ?", (datetime.now().strftime("%Y-%m-%d %H:%M:%S"),))
            alarms = c.fetchall()
            for alarm_time, snooze_time in alarms:
                self.notify_alarm(alarm_time, snooze_time)
        except sqlite3.Error as e:
            logging.error(f"Error checking alarms: {e}")

    def notify_alarm(self, alarm_time, snooze_time):
        try:
            self.notification_manager.send_message_box_notification("Alarm", f"Alarm at {alarm_time} (Snooze: {snooze_time} minutes)")
            self.notification_manager.send_system_tray_notification("Alarm", f"Alarm at {alarm_time} (Snooze: {snooze_time} minutes)", "alarm_icon.png")
            self.notification_manager.send_webhook("Alarm", f"Alarm at {alarm_time} (Snooze: {snooze_time} minutes)")
            self.notification_manager.send_email("user@example.com", "Alarm Notification", f"Alarm at {alarm_time} (Snooze: {snooze_time} minutes)")
            self.notification_manager.send_api_notification("alarm", {"time": alarm_time, "snooze": snooze_time})
        except Exception as e:
            logging.error(f"Error sending notification: {e}")

class ReminderWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.initUI()
        self.initDB()
        self.loadReminders()

    def initUI(self):
        layout = QVBoxLayout(self)

        self.reminder_list = QListWidget()
        self.reminder_list.doubleClicked.connect(self.editReminder)
        layout.addWidget(self.reminder_list)

        controls_layout = QHBoxLayout()
        self.add_reminder_button = QPushButton("Add Reminder")
        self.add_reminder_button.clicked.connect(self.addReminder)
        self.delete_reminder_button = QPushButton("Delete Reminder")
        self.delete_reminder_button.clicked.connect(self.deleteReminder)
        self.repeat_reminder_button = QPushButton("Repeat Reminder")
        self.repeat_reminder_button.clicked.connect(self.repeatReminder)
        controls_layout.addWidget(self.add_reminder_button)
        controls_layout.addWidget(self.delete_reminder_button)
        controls_layout.addWidget(self.repeat_reminder_button)
        layout.addLayout(controls_layout)

    def initDB(self):
        try:
            self.conn = sqlite3.connect('reminders.db')
            c = self.conn.cursor()
            c.execute("""CREATE TABLE IF NOT EXISTS reminders (
                         id INTEGER PRIMARY KEY AUTOINCREMENT,
                         reminder_time TEXT,
                         description TEXT,
                         repeat_interval TEXT,
                         created_at TEXT,
                         updated_at TEXT)""")
            c.execute("""CREATE TABLE IF NOT EXISTS reminder_usage (
                         id INTEGER PRIMARY KEY AUTOINCREMENT,
                         reminder_id INTEGER,
                         used_at TEXT,
                         FOREIGN KEY (reminder_id) REFERENCES reminders(id))""")
            self.conn.commit()
        except sqlite3.Error as e:
            logging.error(f"Error initializing database: {e}")
            QMessageBox.critical(self, "Error", "Failed to initialize the database.")

    def loadReminders(self):
        try:
            c = self.conn.cursor()
            c.execute("SELECT * FROM reminders")
            reminders = c.fetchall()
            for reminder in reminders:
                if reminder[3]:
                    self.reminder_list.addItem(f"{reminder[1]} - {reminder[2]} (Repeat: {reminder[3]}, Created: {reminder[4]}, Updated: {reminder[5]})")
                else:
                    self.reminder_list.addItem(f"{reminder[1]} - {reminder[2]} (Created: {reminder[4]}, Updated: {reminder[5]})")
        except sqlite3.Error as e:
            logging.error(f"Error loading reminders: {e}")
            QMessageBox.critical(self, "Error", "Failed to load reminders from the database.")

    def addReminder(self):
        reminder_dialog = QDialog(self)
        reminder_dialog.setWindowTitle("Set Reminder")

        layout = QVBoxLayout(reminder_dialog)

        reminder_time_label = QLabel("Reminder Time:")
        reminder_time_edit = QDateTimeEdit()
        reminder_time_edit.setDateTime(QDateTime.currentDateTime())

        reminder_description_label = QLabel("Reminder Description:")
        reminder_description_edit = QLineEdit()

        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(reminder_dialog.accept)
        button_box.rejected.connect(reminder_dialog.reject)

        layout.addWidget(reminder_time_label)
        layout.addWidget(reminder_time_edit)
        layout.addWidget(reminder_description_label)
        layout.addWidget(reminder_description_edit)
        layout.addWidget(button_box)

        if reminder_dialog.exec_() == QDialog.Accepted:
            reminder_time = reminder_time_edit.dateTime().toString("yyyy-MM-dd HH:mm:ss")
            reminder_description = reminder_description_edit.text()
            try:
                now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                c = self.conn.cursor()
                c.execute("INSERT INTO reminders (reminder_time, description, repeat_interval, created_at, updated_at) VALUES (?, ?, '', ?, ?)",
                          (reminder_time, reminder_description, now, now))
                self.conn.commit()
                self.reminder_list.addItem(f"{reminder_time} - {reminder_description} (Created: {now}, Updated: {now})")
                logging.info(f"Added new reminder: {reminder_time} - {reminder_description}")
            except sqlite3.Error as e:
                logging.error(f"Error adding reminder: {e}")
                QMessageBox.critical(self, "Error", f"Failed to add the reminder to the database. {e}")
                        
    def editReminder(self, index):
        item = self.reminder_list.item(index.row())
        time_desc = item.text().split(" - ")
        reminder_time = QDateTime.fromString(time_desc[0])
        reminder_description = time_desc[1]
        if " (Repeat: " in item.text():
            repeat_interval = time_desc[1].split(" (Repeat: ")[1].split(", Created: ")[0]
            created_at = time_desc[1].split(", Created: ")[1].split(", Updated: ")[0]
            updated_at = time_desc[1].split(", Updated: ")[1][:-1]
        else:
            repeat_interval = ""
            created_at = time_desc[1].split(", Created: ")[1].split(", Updated: ")[0]
            updated_at = time_desc[1].split(", Updated: ")[1][:-1]
        new_reminder_time, ok = QInputDialog.getDateTime(self, "Edit Reminder", "Enter new reminder time:", reminder_time)
        if ok:
            new_reminder_description, ok = QInputDialog.getText(self, "Edit Reminder", "Enter new reminder description:", reminder_description)
            if ok:
                new_repeat_interval, ok = QInputDialog.getText(self, "Edit Reminder Repeat Interval", "Enter new repeat interval (e.g., 'daily', 'weekly', 'monthly'):", repeat_interval)
                if ok:
                    try:
                        c = self.conn.cursor()
                        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        c.execute("UPDATE reminders SET reminder_time = ?, description = ?, repeat_interval = ?, updated_at = ? WHERE reminder_time = ? AND description = ?", (new_reminder_time.toString(), new_reminder_description, new_repeat_interval, now, time_desc[0], time_desc[1]))
                        self.conn.commit()
                        if new_repeat_interval:
                            item.setText(f"{new_reminder_time.toString()} - {new_reminder_description} (Repeat: {new_repeat_interval}, Created: {created_at}, Updated: {now})")
                        else:
                            item.setText(f"{new_reminder_time.toString()} - {new_reminder_description} (Created: {created_at}, Updated: {now})")
                        logging.info(f"Edited reminder: {new_reminder_time.toString()} - {new_reminder_description} (Repeat: {new_repeat_interval})")
                    except sqlite3.Error as e:
                        logging.error(f"Error editing reminder: {e}")
                        QMessageBox.critical(self, "Error", "Failed to update the reminder in the database.")

    def deleteReminder(self):
        selected = self.reminder_list.selectedItems()
        if selected:
            for item in selected:
                time_desc = item.text().split(" - ")
                try:
                    c = self.conn.cursor()
                    c.execute("DELETE FROM reminders WHERE reminder_time = ? AND description = ?", (time_desc[0], time_desc[1]))
                    c.execute("DELETE FROM reminder_usage WHERE reminder_id = (SELECT id FROM reminders WHERE reminder_time = ? AND description = ?)", (time_desc[0], time_desc[1]))
                    self.conn.commit()
                    self.reminder_list.takeItem(self.reminder_list.row(item))
                    logging.info(f"Deleted reminder: {time_desc[0]} - {time_desc[1]}")
                except sqlite3.Error as e:
                    logging.error(f"Error deleting reminder: {e}")
                    QMessageBox.critical(self, "Error", "Failed to delete the reminder from the database.")

    def repeatReminder(self):
        selected = self.reminder_list.selectedItems()
        if selected:
            for item in selected:
                time_desc = item.text().split(" - ")
                if " (Repeat: " in item.text():
                    repeat_interval = time_desc[1].split(" (Repeat: ")[1].split(", Created: ")[0]
                    created_at = time_desc[1].split(", Created: ")[1].split(", Updated: ")[0]
                    updated_at = time_desc[1].split(", Updated: ")[1][:-1]
                else:
                    repeat_interval = ""
                    created_at = time_desc[1].split(", Created: ")[1].split(", Updated: ")[0]
                    updated_at = time_desc[1].split(", Updated: ")[1][:-1]
                reminder_time = QDateTime.fromString(time_desc[0])
                reminder_description = time_desc[1]
                if repeat_interval:
                    new_reminder_time = self.getNextReminderTime(reminder_time, repeat_interval)
                    try:
                        c = self.conn.cursor()
                        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        c.execute("INSERT INTO reminders (reminder_time, description, repeat_interval, created_at, updated_at) VALUES (?, ?, ?, ?, ?)", (new_reminder_time.toString(), reminder_description, repeat_interval, now, now))
                        c.execute("INSERT INTO reminder_usage (reminder_id, used_at) VALUES ((SELECT id FROM reminders WHERE reminder_time = ? AND description = ?), ?)", (time_desc[0], time_desc[1], now))
                        self.conn.commit()
                        self.reminder_list.addItem(f"{new_reminder_time.toString()} - {reminder_description} (Repeat: {repeat_interval}, Created: {now}, Updated: {now})")
                        logging.info(f"Repeated reminder: {new_reminder_time.toString()} - {reminder_description} (Repeat: {repeat_interval})")
                    except sqlite3.Error as e:
                        logging.error(f"Error repeating reminder: {e}")
                        QMessageBox.critical(self, "Error", "Failed to repeat the reminder in the database.")

    def getNextReminderTime(self, reminder_time, repeat_interval):
        if repeat_interval == "daily":
            return reminder_time.addDays(1)
        elif repeat_interval == "weekly":
            return reminder_time.addDays(7)
        elif repeat_interval == "monthly":
            return reminder_time.addMonths(1)
        else:
            return reminder_time

class TimerWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.initUI()
        self.initTimer()
        self.initDB()
        self.notification_manager = NotificationManager()

    def initUI(self):
        layout = QVBoxLayout(self)
        self.time_display = QLCDNumber()
        self.time_display.setDigitCount(8)
        layout.addWidget(self.time_display)

        controls_layout = QHBoxLayout()
        self.start_button = QPushButton("Start")
        self.start_button.clicked.connect(self.startTimer)
        self.stop_button = QPushButton("Stop")
        self.stop_button.clicked.connect(self.stopTimer)
        self.reset_button = QPushButton("Reset")
        self.reset_button.clicked.connect(self.resetTimer)
        self.countdown_button = QPushButton("Set Countdown")
        self.countdown_button.clicked.connect(self.setCountdown)
        self.lap_list = QListWidget()
        controls_layout.addWidget(self.start_button)
        controls_layout.addWidget(self.stop_button)
        controls_layout.addWidget(self.reset_button)
        controls_layout.addWidget(self.countdown_button)
        layout.addLayout(controls_layout)
        layout.addWidget(self.lap_list)

    def initTimer(self):
        self.timer = QTimer()
        self.timer.setInterval(10)
        self.timer.timeout.connect(self.updateTimer)
        self.elapsed_time = 0
        self.countdown_time = 0
        self.is_countdown = False

    def initDB(self):
        try:
            self.conn = sqlite3.connect('timers.db')
            c = self.conn.cursor()
            c.execute("""CREATE TABLE IF NOT EXISTS timer_usage
                         (id INTEGER PRIMARY KEY AUTOINCREMENT, start_time TEXT, stop_time TEXT, laps TEXT, created_at TEXT)""")
            self.conn.commit()
        except sqlite3.Error as e:
            logging.error(f"Error initializing database: {e}")
            QMessageBox.critical(self, "Error", "Failed to initialize the database.")

    def startTimer(self):
        if self.is_countdown:
            self.countdown_timer.start()
        else:
            self.timer.start()
            self.start_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
            logging.info(f"Timer started at {self.start_time}")

    def stopTimer(self):
        if self.is_countdown:
            self.countdown_timer.stop()
            self.sendNotifications()
        else:
            self.timer.stop()
            self.stop_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
            lap_times_str = ",".join(self.lap_times)
            try:
                c = self.conn.cursor()
                c.execute("INSERT INTO timer_usage (start_time, stop_time, laps, created_at) VALUES (?, ?, ?, ?)", (self.start_time, self.stop_time, lap_times_str, self.stop_time))
                self.conn.commit()
                logging.info(f"Timer stopped at {self.stop_time} with laps: {lap_times_str}")
            except sqlite3.Error as e:
                logging.error(f"Error saving timer usage: {e}")
                QMessageBox.critical(self, "Error", "Failed to save timer usage to the database.")
            self.elapsed_time = 0
            self.lap_times = []
            self.lap_list.clear()
            self.updateTimer()
            
    def setCountdown(self):
        countdown_time, ok = QInputDialog.getInt(self, "Set Countdown", "Enter countdown time (seconds):", 60, 1, 3600)
        if ok:
            self.countdown_time = countdown_time * 1000
            self.is_countdown = True
            self.countdown_timer = QTimer()
            self.countdown_timer.setInterval(10)
            self.countdown_timer.timeout.connect(self.updateCountdown)
            self.countdown_timer.start()

    def resetTimer(self):
        self.timer.stop()
        self.elapsed_time = 0
        self.lap_times = []
        self.lap_list.clear()
        self.updateTimer()
        logging.info("Timer reset")

    def recordLap(self):
        hours = self.elapsed_time // 3600000
        minutes = (self.elapsed_time % 3600000) // 60000
        seconds = (self.elapsed_time % 60000) // 1000
        milliseconds = self.elapsed_time % 1000
        lap_time = f"{hours:02d}:{minutes:02d}:{seconds:02d}.{milliseconds:03d}"
        self.lap_times.append(lap_time)
        self.lap_list.addItem(lap_time)
        logging.info(f"Lap time recorded: {lap_time}")

    def sendNotifications(self):
        self.notification_manager.send_message_box_notification("Timer", "Countdown timer has finished!")
        self.notification_manager.send_system_tray_notification("Timer", "Countdown timer has finished!", "timer_icon.png")
        self.notification_manager.send_webhook("Timer", "Countdown timer has finished!")
        self.notification_manager.send_email("user@example.com", "Timer Notification", "Countdown timer has finished!")
        self.notification_manager.send_api_notification("timer", {"time": self.countdown_time})

    def updateCountdown(self):
        self.countdown_time -= 10
        if self.countdown_time <= 0:
            self.countdown_timer.stop()
            self.sendNotifications()
        hours = self.countdown_time // 3600000
        minutes = (self.countdown_time % 3600000) // 60000
        seconds = (self.countdown_time % 60000) // 1000
        milliseconds = self.countdown_time % 1000
        self.time_display.display(f"{hours:02d}:{minutes:02d}:{seconds:02d}.{milliseconds:03d}")

    def updateTimer(self):
        self.elapsed_time += 10
        hours = self.elapsed_time // 3600000
        minutes = (self.elapsed_time % 3600000) // 60000
        seconds = (self.elapsed_time % 60000) // 1000
        milliseconds = self.elapsed_time % 1000
        self.time_display.display(f"{hours:02d}:{minutes:02d}:{seconds:02d}.{milliseconds:03d}")

class StopwatchWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.initUI()
        self.initStopwatch()
        self.initDB()

    def initUI(self):
        layout = QVBoxLayout(self)
        self.time_display = QLCDNumber()
        self.time_display.setDigitCount(8)
        layout.addWidget(self.time_display)

        controls_layout = QHBoxLayout()
        self.start_button = QPushButton("Start")
        self.start_button.clicked.connect(self.startStopwatch)
        self.stop_button = QPushButton("Stop")
        self.stop_button.clicked.connect(self.stopStopwatch)
        self.reset_button = QPushButton("Reset")
        self.reset_button.clicked.connect(self.resetStopwatch)
        self.lap_button = QPushButton("Lap")
        self.lap_button.clicked.connect(self.recordLap)
        self.lap_list = QListWidget()
        controls_layout.addWidget(self.start_button)
        controls_layout.addWidget(self.stop_button)
        controls_layout.addWidget(self.reset_button)
        controls_layout.addWidget(self.lap_button)
        layout.addLayout(controls_layout)
        layout.addWidget(self.lap_list)

    def initStopwatch(self):
        self.timer = QTimer()
        self.timer.setInterval(10)
        self.timer.timeout.connect(self.updateStopwatch)
        self.elapsed_time = 0
        self.lap_times = []

    def initDB(self):
        try:
            self.conn = sqlite3.connect('stopwatches.db')
            c = self.conn.cursor()
            c.execute("""CREATE TABLE IF NOT EXISTS stopwatch_usage
                         (id INTEGER PRIMARY KEY AUTOINCREMENT, start_time TEXT, stop_time TEXT, laps TEXT, created_at TEXT)""")
            self.conn.commit()
        except sqlite3.Error as e:
            logging.error(f"Error initializing database: {e}")
            QMessageBox.critical(self, "Error", "Failed to initialize the database.")

    def startStopwatch(self):
        self.timer.start()
        self.start_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
        logging.info(f"Stopwatch started at {self.start_time}")

    def stopStopwatch(self):
        self.timer.stop()
        self.stop_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
        lap_times_str = ",".join(self.lap_times)
        try:
            c = self.conn.cursor()
            c.execute("INSERT INTO stopwatch_usage (start_time, stop_time, laps, created_at) VALUES (?, ?, ?, ?)", (self.start_time, self.stop_time, lap_times_str, self.stop_time))
            self.conn.commit()
            logging.info(f"Stopwatch stopped at {self.stop_time} with laps: {lap_times_str}")
        except sqlite3.Error as e:
            logging.error(f"Error saving stopwatch usage: {e}")
            QMessageBox.critical(self, "Error", "Failed to save stopwatch usage to the database.")
        self.elapsed_time = 0
        self.lap_times = []
        self.lap_list.clear()
        self.updateStopwatch()

    def resetStopwatch(self):
        self.timer.stop()
        self.elapsed_time = 0
        self.lap_times = []
        self.lap_list.clear()
        self.updateStopwatch()
        logging.info("Stopwatch reset")

    def recordLap(self):
        hours = self.elapsed_time // 3600000
        minutes = (self.elapsed_time % 3600000) // 60000
        seconds = (self.elapsed_time % 60000) // 1000
        milliseconds = self.elapsed_time % 1000
        lap_time = f"{hours:02d}:{minutes:02d}:{seconds:02d}.{milliseconds:03d}"
        self.lap_times.append(lap_time)
        self.lap_list.addItem(lap_time)
        logging.info(f"Lap time recorded: {lap_time}")

    def updateStopwatch(self):
        self.elapsed_time += 10
        hours = self.elapsed_time // 3600000
        minutes = (self.elapsed_time % 3600000) // 60000
        seconds = (self.elapsed_time % 60000) // 1000
        milliseconds = self.elapsed_time % 1000
        self.time_display.display(f"{hours:02d}:{minutes:02d}:{seconds:02d}.{milliseconds:03d}")

class ReportWidget(QWidget):
    def init(self, parent=None):
        super().init(parent)
        self.parent = parent
        self.initUI()
        self.initDB()

    def initUI(self):
        layout = QVBoxLayout(self)

        self.alarm_report_button = QPushButton("Alarm Report")
        self.alarm_report_button.clicked.connect(self.showAlarmReport)
        layout.addWidget(self.alarm_report_button)

        self.reminder_report_button = QPushButton("Reminder Report")
        self.reminder_report_button.clicked.connect(self.showReminderReport)
        layout.addWidget(self.reminder_report_button)

        self.timer_report_button = QPushButton("Timer Report")
        self.timer_report_button.clicked.connect(self.showTimerReport)
        layout.addWidget(self.timer_report_button)

        self.stopwatch_report_button = QPushButton("Stopwatch Report")
        self.stopwatch_report_button.clicked.connect(self.showStopwatchReport)
        layout.addWidget(self.stopwatch_report_button)

        self.report_view = QTableWidget()
        self.report_view.setColumnCount(5)
        self.report_view.setHorizontalHeaderLabels(["Time", "Description", "Frequency", "Avg Duration", "Total Duration"])
        layout.addWidget(self.report_view)

    def initDB(self):
        try:
            self.alarm_conn = sqlite3.connect('alarms.db')
            self.reminder_conn = sqlite3.connect('reminders.db')
            self.timer_conn = sqlite3.connect('timers.db')
            self.stopwatch_conn = sqlite3.connect('stopwatches.db')
        except sqlite3.Error as e:
            logging.error(f"Error connecting to databases: {e}")
            QMessageBox.critical(self, "Error", "Failed to connect to the databases.")

    def showAlarmReport(self):
        try:
            c = self.alarm_conn.cursor()
            c.execute("""
                SELECT 
                    alarm_time,
                    COUNT(*) AS frequency,
                    AVG(CAST(SUBSTR(used_at, 15, 6) AS FLOAT) - CAST(SUBSTR(used_at, 1, 12) AS FLOAT)) AS avg_duration,
                    SUM(CAST(SUBSTR(used_at, 15, 6) AS FLOAT) - CAST(SUBSTR(used_at, 1, 12) AS FLOAT)) AS total_duration
                FROM alarms
                LEFT JOIN alarm_usage ON alarms.id = alarm_usage.alarm_id
                GROUP BY alarm_time
                ORDER BY frequency DESC;
            """)
            results = c.fetchall()
            self.populateReportView(results)
        except sqlite3.Error as e:
            logging.error(f"Error generating alarm report: {e}")
            QMessageBox.critical(self, "Error", "Failed to generate the alarm report.")

    def showReminderReport(self):
        try:
            c = self.reminder_conn.cursor()
            c.execute("""
                SELECT
                    reminder_time,
                    description,
                    COUNT(*) AS frequency,
                    AVG(CAST(SUBSTR(used_at, 15, 6) AS FLOAT) - CAST(SUBSTR(used_at, 1, 12) AS FLOAT)) AS avg_duration,
                    SUM(CAST(SUBSTR(used_at, 15, 6) AS FLOAT) - CAST(SUBSTR(used_at, 1, 12) AS FLOAT)) AS total_duration
                FROM reminders
                LEFT JOIN reminder_usage ON reminders.id = reminder_usage.reminder_id
                GROUP BY reminder_time, description
                ORDER BY frequency DESC;
            """)
            results = c.fetchall()
            self.populateReportView(results)
        except sqlite3.Error as e:
            logging.error(f"Error generating reminder report: {e}")
            QMessageBox.critical(self, "Error", "Failed to generate the reminder report.")

    def showTimerReport(self):
        try:
            c = self.timer_conn.cursor()
            c.execute("""
                SELECT
                    SUBSTR(start_time, 1, 19) AS start_time,
                    SUBSTR(stop_time, 1, 19) AS stop_time,
                    COUNT(*) AS frequency,
                    AVG(CAST(SUBSTR(stop_time, 15, 6) AS FLOAT) - CAST(SUBSTR(start_time, 15, 6) AS FLOAT)) AS avg_duration,
                    SUM(CAST(SUBSTR(stop_time, 15, 6) AS FLOAT) - CAST(SUBSTR(start_time, 15, 6) AS FLOAT)) AS total_duration
                FROM timer_usage
                GROUP BY start_time, stop_time
                ORDER BY frequency DESC;
            """)
            results = c.fetchall()
            self.populateReportView(results)
        except sqlite3.Error as e:
            logging.error(f"Error generating timer report: {e}")
            QMessageBox.critical(self, "Error", "Failed to generate the timer report.")

    def showStopwatchReport(self):
        try:
            c = self.stopwatch_conn.cursor()
            c.execute("""
                SELECT
                    SUBSTR(start_time, 1, 19) AS start_time,
                    SUBSTR(stop_time, 1, 19) AS stop_time,
                    COUNT(*) AS frequency,
                    AVG(CAST(SUBSTR(stop_time, 15, 6) AS FLOAT) - CAST(SUBSTR(start_time, 15, 6) AS FLOAT)) AS avg_duration,
                    SUM(CAST(SUBSTR(stop_time, 15, 6) AS FLOAT) - CAST(SUBSTR(start_time, 15, 6) AS FLOAT)) AS total_duration
                FROM stopwatch_usage
                GROUP BY start_time, stop_time
                ORDER BY frequency DESC;
            """)
            results = c.fetchall()
            self.populateReportView(results)
        except sqlite3.Error as e:
            logging.error(f"Error generating stopwatch report: {e}")
            QMessageBox.critical(self, "Error", "Failed to generate the stopwatch report.")

    def populateReportView(self, results):
        self.report_view.setRowCount(len(results))
        for row, result in enumerate(results):
            for col, value in enumerate(result):
                if col == 2:
                    item = QTableWidgetItem(str(int(value)))
                elif col == 3:
                    item = QTableWidgetItem(f"{value:.2f} s")
                elif col == 4:
                    item = QTableWidgetItem(f"{value:.2f} s")
                else:
                    item = QTableWidgetItem(str(value))
                self.report_view.setItem(row, col, item)
        self.report_view.resizeColumnsToContents()

class DigitalClockWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.time_format = '%H:%M:%S'  # Default to 24-hour mode
        self.initUI()
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_time)
        self.timer.start(1000)

    def initUI(self):
        self.setFixedSize(200, 50)
        self.time_label = QLabel()
        self.time_label.setAlignment(Qt.AlignCenter)
        self.time_label.setFont(QFont('Arial', 24))
        layout = QVBoxLayout(self)
        layout.addWidget(self.time_label)

    def update_time(self):
        current_time = datetime.now().strftime(self.time_format)
        self.time_label.setText(current_time)

    def set_time_format(self, time_format):
        self.time_format = time_format
        self.update_time()

class ClockCalendarWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)

        self.tabs = QTabWidget(self)
        self.alarm_widget = AlarmWidget(self)
        self.reminder_widget = ReminderWidget(self)
        self.timer_widget = TimerWidget(self)
        self.stopwatch_widget = StopwatchWidget(self)
        self.calendar_widget = QCalendarWidget(self)

        self.clock_layout = QHBoxLayout()
        self.digital_clock = DigitalClockWidget(self)
        self.clock_mode_button = QPushButton("24H Mode", self)
        self.clock_mode_button.setCheckable(True)
        self.clock_mode_button.toggled.connect(self.toggle_clock_mode)
        self.clock_layout.addWidget(self.digital_clock)
        self.clock_layout.addWidget(self.clock_mode_button)

        self.tabs.addTab(self.calendar_widget, "Calendar")
        self.tabs.addTab(self.reminder_widget, "Reminders")
        self.tabs.addTab(self.alarm_widget, "Alarms")
        self.tabs.addTab(self.timer_widget, "Timer")
        self.tabs.addTab(self.stopwatch_widget, "Stopwatch")

        layout.addWidget(self.tabs)
        layout.addLayout(self.clock_layout)

        self.digital_clock.show()
        self.clock_mode_button.show()

    def toggle_clock_mode(self, checked):
        if checked:
            self.digital_clock.set_time_format('%H:%M:%S')
            self.clock_mode_button.setText("24H Mode")
        else:
            self.digital_clock.set_time_format('%I:%M:%S %p')
            self.clock_mode_button.setText("AM/PM Mode")

    def show_reminders(self):
        selected_date = self.calendar_widget.selectedDate()
        reminders_display = ""
        try:
            c = self.reminder_widget.conn.cursor()
            c.execute("SELECT reminder_time, description, repeat_interval FROM reminders WHERE DATE(reminder_time) = ?", (selected_date.toString("yyyy-MM-dd"),))
            reminders = c.fetchall()

            for reminder in reminders:
                reminder_time, description, repeat_interval = reminder
                reminder_info = f"Time: {reminder_time}, Description: {description}"
                if repeat_interval:
                    reminder_info += f", Repeat: {repeat_interval}"
                reminders_display += reminder_info + "\n"

            if reminders_display:
                QMessageBox.information(self, "Reminders", f"Reminders for {selected_date.toString('yyyy-MM-dd')}:\n\n{reminders_display}")
            else:
                QMessageBox.information(self, "No Reminders", f"No reminders found for {selected_date.toString('yyyy-MM-dd')}.")

        except sqlite3.Error as e:
            logging.error(f"Error retrieving reminders: {e}")
            QMessageBox.critical(self, "Error", "Failed to retrieve reminders from the database.")

class DateTimeDialog(QDialog):
    def __init__(self, title, label, initial_date_time=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        layout = QVBoxLayout(self)

        label_widget = QLabel(label)
        layout.addWidget(label_widget)

        self.date_time_edit = QDateTimeEdit(initial_date_time or QDateTime.currentDateTime())
        self.date_time_edit.setCalendarPopup(True)
        layout.addWidget(self.date_time_edit)

        button_layout = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Cancel")
        button_layout.addWidget(self.ok_button)
        button_layout.addWidget(self.cancel_button)

        layout.addLayout(button_layout)

        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

    def getDateTime(self):
        return self.date_time_edit.dateTime()

class ToDoItemWindow(QWidget):
    def __init__(self, item_data, parent=None):
        super().__init__(parent)
        self.item_data = item_data
        self.parent = parent
        self.initUI()

    def initUI(self):
        self.setWindowTitle(self.item_data[2])
        self.setWindowFlags(Qt.Window)
        layout = QVBoxLayout(self)

        # Display Item Information
        self.info_section = QGroupBox("Item Information")
        info_layout = QVBoxLayout()
        item_info_label = QLabel(f"Item Information:\n{self.item_data[3]}")
        info_layout.addWidget(item_info_label)
        self.info_section.setLayout(info_layout)

        # Edit Options
        self.edit_section = QGroupBox("Edit Options")
        edit_layout = QVBoxLayout()

        self.itemNameEdit = QLineEdit(self.item_data[2])
        self.itemInfoEdit = QTextEdit(self.item_data[3])
        self.parentItemDropdown = QComboBox()
        parent_tab_name = self.item_data[1]
        self.updateParentItemDropdown(parent_tab_name)

        self.saveButton = QPushButton("Save Item")
        self.saveButton.clicked.connect(self.saveItem)

        self.markCompletedButton = QPushButton("Mark as Completed")
        self.markCompletedButton.clicked.connect(lambda: self.markItemAsCompleted(self.item_data[2]))

        self.newChildButton = QPushButton("Create New Child Task")
        self.newChildButton.clicked.connect(self.createNewChildTask)

        edit_layout.addWidget(QLabel("Item Name:"))
        edit_layout.addWidget(self.itemNameEdit)
        edit_layout.addWidget(QLabel("Item Information:"))
        edit_layout.addWidget(self.itemInfoEdit)
        edit_layout.addWidget(QLabel("Parent Item:"))
        edit_layout.addWidget(self.parentItemDropdown)
        edit_layout.addWidget(self.saveButton)
        edit_layout.addWidget(self.markCompletedButton)
        edit_layout.addWidget(self.newChildButton)
        self.edit_section.setLayout(edit_layout)

        # Child Tasks Section
        self.childTasksSection = QGroupBox("Child Tasks")
        child_layout = QVBoxLayout()
        self.childTasksList = QListWidget()
        self.loadChildTasks()
        child_layout.addWidget(self.childTasksList)
        self.childTasksSection.setLayout(child_layout)

        layout.addWidget(self.info_section)
        layout.addWidget(self.edit_section)
        layout.addWidget(self.childTasksSection)

        self.setLayout(layout)

    def updateParentItemDropdown(self, tab_name):
        cursor = self.parent.dbConnection.cursor()
        cursor.execute('SELECT item_name FROM todo_items WHERE parent_item IS NULL AND tab_name = ?', (tab_name,))
        parent_items = cursor.fetchall()
        self.parentItemDropdown.clear()
        self.parentItemDropdown.addItem("None")
        for item in parent_items:
            self.parentItemDropdown.addItem(item[0])

    def loadChildTasks(self):
        cursor = self.parent.dbConnection.cursor()
        cursor.execute('SELECT * FROM todo_items WHERE parent_item = ?', (self.item_data[2],))
        child_items = cursor.fetchall()
        self.childTasksList.clear()
        for item in child_items:
            list_item = QListWidgetItem(item[2])
            list_item.setData(Qt.UserRole, item)
            self.childTasksList.addItem(list_item)

    def saveItem(self):
        new_name = self.itemNameEdit.text()
        new_info = self.itemInfoEdit.toPlainText()
        parent_item = self.parentItemDropdown.currentText()
        if parent_item == "None":
            parent_item = None
        self.parent.editItem(self.item_data[2], new_name, new_info, parent_item)
        self.close()

    def markItemAsCompleted(self, item_name):
        self.parent.markItemAsCompleted(item_name)
        self.close()

    def createNewChildTask(self):
        new_name, ok = QInputDialog.getText(self, "New Child Task", "Enter task name:")
        if ok and new_name:
            new_info, ok = QInputDialog.getText(self, "New Child Task", "Enter task information:")
            if ok:
                tab_name = self.item_data[1]
                self.parent.addItem(tab_name, new_name, new_info, self.item_data[2])
                self.loadChildTasks()
                
class ToDoWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.dbConnection = sqlite3.connect('to-do.db')
        self.notification_manager = NotificationManager()
        self.initDB()
        self.initUI()
        self.loadTabsFromDatabase()

    def initDB(self):
        cursor = self.dbConnection.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS todo_items (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                tab_name TEXT,
                item_name TEXT,
                item_info TEXT,
                parent_item TEXT,
                completed BOOLEAN DEFAULT 0
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS todo_tabs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                tab_name TEXT
            )
        ''')
        # Ensure a default parent item named "Parent" exists for each tab
        cursor.execute('''
            INSERT OR IGNORE INTO todo_items (tab_name, item_name, parent_item, completed)
            VALUES ('default', 'Parent', NULL, 0)
        ''')
        self.dbConnection.commit()

    def loadTabsFromDatabase(self):
        cursor = self.dbConnection.cursor()
        cursor.execute('SELECT DISTINCT tab_name FROM todo_tabs')
        tabs = cursor.fetchall()
        for tab in tabs:
            tab_name = tab[0]
            if not self.getTabWidgetByName(tab_name):
                tab_widget = self.createTab(tab_name)
                self.todoTabs.addTab(tab_widget, tab_name)
                self.loadToDoItems(tab_name)

    def initUI(self):
        self.layout = QVBoxLayout(self)
        self.subTabs = QTabWidget(self)

        self.todoTabs = QTabWidget(self)
        self.todoTabs.setTabsClosable(True)
        self.todoTabs.tabCloseRequested.connect(self.closeTab)
        self.todoTabs.tabBarDoubleClicked.connect(self.renameTab)
        self.layout.addWidget(self.todoTabs)

        buttonLayout1 = QHBoxLayout()
        self.newTabButton = QPushButton("New Tab")
        self.newTabButton.clicked.connect(self.createNewTab)
        buttonLayout1.addWidget(self.newTabButton)

        self.deselectAllButton = QPushButton("Deselect")
        self.deselectAllButton.clicked.connect(self.deselectAll)
        buttonLayout1.addWidget(self.deselectAllButton)

        self.saveTabButton = QPushButton("Save Tab")
        self.saveTabButton.clicked.connect(self.saveCurrentTab)
        buttonLayout1.addWidget(self.saveTabButton)

        self.importTasksButton = QPushButton("Import Tasks")
        self.importTasksButton.clicked.connect(self.importTasks)
        buttonLayout1.addWidget(self.importTasksButton)

        self.layout.addLayout(buttonLayout1)

    def handleReturnPressed(self, tab_name, itemNameEdit):
        tab_widget = self.getTabWidgetByName(tab_name)
        itemInfoEdit = tab_widget.findChild(QTextEdit, "itemInfoEdit")
        parentItemDropdown = tab_widget.findChild(QComboBox, "parentItemDropdown")
        addButton = tab_widget.findChild(QPushButton, "addButton")
    
        if addButton.text() == "Add":
            self.addItem(tab_name, itemNameEdit.text(), itemInfoEdit.toPlainText(), parentItemDropdown.currentText())
        else:
            self.editItem(tab_name, itemNameEdit.text(), itemInfoEdit.toPlainText(), parentItemDropdown.currentText())

    def eventFilter(self, source, event):
        if event.type() == QEvent.KeyPress and event.key() == Qt.Key_Return:
            if isinstance(source, QTextEdit):
                tab_widget = source.parent()
                itemNameEdit = tab_widget.findChild(QLineEdit, "itemNameEdit")
                self.handleReturnPressed(self.todoTabs.tabText(self.todoTabs.currentIndex()), itemNameEdit)
                return True
        return super().eventFilter(source, event)

    def createTab(self, tab_name):
        widget = QWidget()
        layout = QVBoxLayout(widget)

        inputLayout = QHBoxLayout()
        itemNameEdit = QLineEdit()
        itemNameEdit.setPlaceholderText("Item Name")
        itemNameEdit.setObjectName("itemNameEdit")
        itemNameEdit.returnPressed.connect(lambda: self.handleReturnPressed(tab_name, itemNameEdit))
        inputLayout.addWidget(itemNameEdit)

        parentItemDropdown = QComboBox()
        parentItemDropdown.setObjectName("parentItemDropdown")
        self.updateParentItemDropdown(tab_name)
        inputLayout.addWidget(parentItemDropdown)

        layout.addLayout(inputLayout)

        itemInfoEdit = QTextEdit()
        itemInfoEdit.setPlaceholderText("Item Information")
        itemInfoEdit.setObjectName("itemInfoEdit")
        itemInfoEdit.installEventFilter(self)
        layout.addWidget(itemInfoEdit)

        buttonLayout2 = QHBoxLayout()
        addButton = QPushButton("Add")
        addButton.setObjectName("addButton")
        addButton.clicked.connect(lambda: self.addItem(tab_name, itemNameEdit.text(), itemInfoEdit.toPlainText(), parentItemDropdown.currentText()))
        buttonLayout2.addWidget(addButton)

        editButton = QPushButton("Edit")
        editButton.setObjectName("editButton")
        editButton.clicked.connect(self.openItemInWindow)
        editButton.setEnabled(False)
        buttonLayout2.addWidget(editButton)

        markCompletedButton = QPushButton("Complete")
        markCompletedButton.setObjectName("markCompletedButton")
        markCompletedButton.clicked.connect(self.markItemAsCompleted)
        markCompletedButton.setEnabled(False)
        buttonLayout2.addWidget(markCompletedButton)

        layout.addLayout(buttonLayout2)

        itemList = QListWidget()
        itemList.setObjectName("itemList")
        itemList.itemChanged.connect(self.handleItemChecked)
        itemList.itemClicked.connect(lambda item: self.populateItemDetails(item, itemNameEdit, itemInfoEdit, parentItemDropdown, addButton, editButton, markCompletedButton))
        itemList.itemDoubleClicked.connect(self.openItemInWindow)
        layout.addWidget(itemList)

        widget.setLayout(layout)
        return widget

    def addItem(self, tab_name, item_name=None, item_info=None, parent_item=None):
        tab_widget = self.getTabWidgetByName(tab_name)
        itemNameEdit = tab_widget.findChild(QLineEdit, "itemNameEdit")
        itemInfoEdit = tab_widget.findChild(QTextEdit, "itemInfoEdit")
        parentItemDropdown = tab_widget.findChild(QComboBox, "parentItemDropdown")
        addButton = tab_widget.findChild(QPushButton, "addButton")

        item_name = item_name or itemNameEdit.text()
        item_info = item_info or itemInfoEdit.toPlainText()
        parent_item = parent_item or parentItemDropdown.currentText()

        if not item_name:
            QMessageBox.warning(self, "Warning", "Item Name cannot be empty")
            return

        if parent_item == "None":
            parent_item = None

        cursor = self.dbConnection.cursor()
        cursor.execute('''
            INSERT INTO todo_items (tab_name, item_name, item_info, parent_item)
            VALUES (?, ?, ?, ?)
        ''', (tab_name, item_name, item_info, parent_item))
        self.dbConnection.commit()
        self.loadToDoItems(tab_name)
        self.updateParentItemDropdown(tab_name)

        itemNameEdit.clear()
        itemInfoEdit.clear()
        addButton.setText("Add")

    def loadToDoItems(self, tab_name):
        cursor = self.dbConnection.cursor()
        cursor.execute('SELECT * FROM todo_items WHERE tab_name = ?', (tab_name,))
        items = cursor.fetchall()

        tab_widget = self.getTabWidgetByName(tab_name)
        if tab_widget is None:
            return
        item_list = tab_widget.findChild(QListWidget, "itemList")
        item_list.clear()

        for item in items:
            item_name, item_info, parent_item, completed = item[2], item[3], item[4], item[5]
            list_item = QListWidgetItem(item_name)
            list_item.setCheckState(Qt.Unchecked if completed else Qt.Checked)
            list_item.setData(Qt.UserRole, item)
            if parent_item:
                indent_level = self.getIndentLevel(item[2])
                list_item.setText(f"{' ' * (indent_level * 2)}{item_name}")
            item_list.addItem(list_item)

            if completed:
                self.addUndoRemoveButtons(list_item)

    def updateParentItemDropdown(self, tab_name):
        tab_widget = self.getTabWidgetByName(tab_name)
        if tab_widget is None:
            return

        cursor = self.dbConnection.cursor()
        cursor.execute('SELECT item_name FROM todo_items WHERE tab_name = ? AND parent_item IS NULL', (tab_name,))
        parent_items = cursor.fetchall()

        dropdown = tab_widget.findChild(QComboBox, "parentItemDropdown")
        dropdown.clear()
        dropdown.addItem("None")
        for item in parent_items:
            dropdown.addItem(item[0])

    def handleItemChecked(self, item):
        if item.checkState() == Qt.Unchecked:
            self.confirmRemoveItem(item.text())

    def getIndentLevel(self, item_name):
        cursor = self.dbConnection.cursor()
        cursor.execute('SELECT parent_item FROM todo_items WHERE item_name = ?', (item_name,))
        parent = cursor.fetchone()
        if parent and parent[0]:
            return 1 + self.getIndentLevel(parent[0])
        return 0

    def getTabWidgetByName(self, tab_name):
        for i in range(self.todoTabs.count()):
            if self.todoTabs.tabText(i) == tab_name:
                return self.todoTabs.widget(i)
        return None

    def removeItem(self, item_name):
        cursor = self.dbConnection.cursor()
        cursor.execute('DELETE FROM todo_items WHERE item_name = ?', (item_name,))
        self.dbConnection.commit()
        tab_name = self.todoTabs.tabText(self.todoTabs.currentIndex())
        self.loadToDoItems(tab_name)

    def editItem(self, tab_name, new_item_name, new_item_info, parent_item):
        cursor = self.dbConnection.cursor()
        cursor.execute('''
            UPDATE todo_items
            SET item_name = ?, item_info = ?, parent_item = ?
            WHERE item_name = ?
        ''', (new_item_name, new_item_info, parent_item, new_item_name))
        self.dbConnection.commit()
        self.loadToDoItems(tab_name)
        self.updateParentItemDropdown(tab_name)

    def createNewTab(self):
        tab_name, ok = QInputDialog.getText(self, "New Tab", "Enter tab name:")
        if ok and tab_name:
            cursor = self.dbConnection.cursor()
            cursor.execute('''
                INSERT INTO todo_tabs (tab_name)
                VALUES (?)
            ''', (tab_name,))
            self.dbConnection.commit()
            tab = self.createTab(tab_name)
            self.todoTabs.addTab(tab, tab_name)
            self.todoTabs.setCurrentWidget(tab)

    def closeTab(self, index):
        tab_name = self.todoTabs.tabText(index)
        self.todoTabs.removeTab(index)
        cursor = self.dbConnection.cursor()
        cursor.execute('DELETE FROM todo_tabs WHERE tab_name = ?', (tab_name,))
        self.dbConnection.commit()

    def renameTab(self, index):
        current_tab_name = self.todoTabs.tabText(index)
        new_tab_name, ok = QInputDialog.getText(self, "Rename Tab", "Enter new name:", QLineEdit.Normal, current_tab_name)
        if ok and new_tab_name:
            cursor = self.dbConnection.cursor()
            cursor.execute('''
                UPDATE todo_tabs
                SET tab_name = ?
                WHERE tab_name = ?
            ''', (new_tab_name, current_tab_name))
            self.dbConnection.commit()
            self.todoTabs.setTabText(index, new_tab_name)

    def confirmRemoveItem(self, item_name):
        cursor = self.dbConnection.cursor()
        cursor.execute('SELECT * FROM todo_items WHERE parent_item = ?', (item_name,))
        child_items = cursor.fetchall()

        message = f"Are you sure you want to mark '{item_name}' as completed?\n"
        if child_items:
            message += "This item has child items:\n"
            for child in child_items:
                message += f"  - [Child] {child[2]}: {child[3]}\n"

        reply = QMessageBox.question(self, "Confirm Completion", message, QMessageBox.Yes | QMessageBox.No)
        if reply == QMessageBox.Yes:
            self.markItemAsCompleted(item_name)
            for child in child_items:
                self.markItemAsCompleted(child[2])

    def markItemAsCompleted(self, item_name):
        cursor = self.dbConnection.cursor()
        cursor.execute('UPDATE todo_items SET completed = 1 WHERE item_name = ?', (item_name,))
        self.dbConnection.commit()
        tab_name = self.todoTabs.tabText(self.todoTabs.currentIndex())
        self.loadToDoItems(tab_name)

    def undoCompletion(self, item_name):
        cursor = self.dbConnection.cursor()
        cursor.execute('UPDATE todo_items SET completed = 0 WHERE item_name = ?', (item_name,))
        self.dbConnection.commit()
        tab_name = self.todoTabs.tabText(self.todoTabs.currentIndex())
        self.loadToDoItems(tab_name)

    def populateItemDetails(self, item, itemNameEdit, itemInfoEdit, parentItemDropdown, addButton, editButton, markCompletedButton):
        item_data = item.data(Qt.UserRole)
        itemNameEdit.setText(item_data[2])
        itemInfoEdit.setText(item_data[3])
        parent_item = item_data[4]
        if parent_item:
            index = parentItemDropdown.findText(parent_item)
            if index != -1:
                parentItemDropdown.setCurrentIndex(index)
        else:
            parentItemDropdown.setCurrentIndex(0)
        addButton.setText("Save")
        addButton.clicked.disconnect()
        addButton.clicked.connect(lambda: self.editItem(self.todoTabs.tabText(self.todoTabs.currentIndex()), itemNameEdit.text(), itemInfoEdit.toPlainText(), parentItemDropdown.currentText()))
        editButton.setEnabled(True)
        markCompletedButton.setEnabled(True)

    def openItemInWindow(self, item):
        item_data = item.data(Qt.UserRole)
        item_window = ToDoItemWindow(item_data, self)
        item_window.show()

    def saveTasksToFile(self, tab_name, file_path):
        cursor = self.dbConnection.cursor()
        cursor.execute('SELECT * FROM todo_items WHERE tab_name = ?', (tab_name,))
        items = cursor.fetchall()

        tasks = []
        for item in items:
            task = {
                "item_name": item[2],
                "item_info": item[3],
                "parent_item": item[4],
                "completed": item[5]
            }
            tasks.append(task)

        with open(file_path, 'w') as file:
            json.dump(tasks, file, indent=4)

    def importTasksFromFile(self, file_path, tab_name):
        with open(file_path, 'r') as file:
            tasks = json.load(file)

        for task in tasks:
            cursor = self.dbConnection.cursor()
            cursor.execute('''
                INSERT INTO todo_items (tab_name, item_name, item_info, parent_item, completed)
                VALUES (?, ?, ?, ?, ?)
            ''', (tab_name, task['item_name'], task['item_info'], task['parent_item'], task['completed']))
            self.dbConnection.commit()
        self.loadToDoItems(tab_name)
        self.updateParentItemDropdown(tab_name)

    def loadSavedTabsAndTasks(self):
        directory = 'C:\\TSTP\\OmniOmega\\notes\\tasks\\'
        if not os.path.exists(directory):
            os.makedirs(directory)
        saved_files = [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]
        self.savedTabsDropdown.clear()
        for file in saved_files:
            self.savedTabsDropdown.addItem(file)

    def saveCurrentTab(self):
        tab_name = self.todoTabs.tabText(self.todoTabs.currentIndex())
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getSaveFileName(self, "Save Tasks", "", "JSON Files (*.json);;All Files (*)", options=options)
        if file_path:
            self.saveTasksToFile(tab_name, file_path)

    def importTasks(self):
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getOpenFileName(self, "Import Tasks", "", "JSON Files (*.json);;All Files (*)", options=options)
        if file_path:
            tab_name = self.todoTabs.tabText(self.todoTabs.currentIndex())
            self.importTasksFromFile(file_path, tab_name)

    def deselectAll(self):
        tab_widget = self.todoTabs.currentWidget()
        itemNameEdit = tab_widget.findChild(QLineEdit, "itemNameEdit")
        itemInfoEdit = tab_widget.findChild(QTextEdit, "itemInfoEdit")
        parentItemDropdown = tab_widget.findChild(QComboBox, "parentItemDropdown")
        addButton = tab_widget.findChild(QPushButton, "addButton")
        editButton = tab_widget.findChild(QPushButton, "editButton")
        markCompletedButton = tab_widget.findChild(QPushButton, "markCompletedButton")

        itemNameEdit.clear()
        itemInfoEdit.clear()
        parentItemDropdown.setCurrentIndex(0)
        addButton.setText("Add")
        addButton.clicked.disconnect()
        addButton.clicked.connect(lambda: self.addItem(self.todoTabs.tabText(self.todoTabs.currentIndex())))
        editButton.setEnabled(False)
        markCompletedButton.setEnabled(False)

    def addUndoRemoveButtons(self, list_item):
        undo_button = QPushButton("Undo")
        undo_button.clicked.connect(lambda: self.undoCompletion(list_item.text()))

        remove_button = QPushButton("Remove")
        remove_button.clicked.connect(lambda: self.removeItem(list_item.text()))

        item_widget = QWidget()
        item_layout = QHBoxLayout(item_widget)
        item_layout.addWidget(QLabel(list_item.text()))
        item_layout.addWidget(undo_button)
        item_layout.addWidget(remove_button)
        item_layout.addStretch()
        item_widget.setLayout(item_layout)

        list_item_widget = QListWidgetItem(list_item.text())
        list_item_widget.setSizeHint(item_widget.sizeHint())

        tab_widget = self.getTabWidgetByName(self.todoTabs.tabText(self.todoTabs.currentIndex()))
        item_list = tab_widget.findChild(QListWidget, "itemList")
        item_list.addItem(list_item_widget)
        item_list.setItemWidget(list_item_widget, item_widget)

### ADDITIONAL NOTES WIDGETS END ###            
        
### HELPER FUNCTION/WINDOWS START ###
class ApprovalDialog(QDialog):
    def __init__(self, note_html, save_behavior, notes_directory, notebook, auto_save_note_folder, parent=None):
        super(ApprovalDialog, self).__init__(parent)
        self.note_html = note_html
        self.save_behavior = save_behavior
        self.notes_directory = notes_directory
        self.auto_save_note_folder = auto_save_note_folder
        self.notebook = notebook
        self.parent = parent  # Ensure parent is set correctly
        self.original_note_html = note_html  # Store the original note HTML
        self.init_ui()

    def init_ui(self):
        self.setWindowTitle("Approve Note Text")
        layout = QVBoxLayout()
        self.setWindowIcon(QIcon(resource_path("app_icon.ico")))

        # Text area for displaying the note
        self.text_area = QTextEdit()
        self.text_area.setReadOnly(True)
        self.text_area.setTextInteractionFlags(Qt.NoTextInteraction)  # Disable text interaction
        self.text_area.setHtml(self.note_html)
        layout.addWidget(QLabel("Note Text:"))
        layout.addWidget(self.text_area)

        # Input area for replacing #TEXT#
        self.input_line = QLineEdit()
        self.submit_button = QPushButton("Submit")
        self.submit_button.clicked.connect(self.replace_text)
        input_layout = QHBoxLayout()
        input_layout.addWidget(QLabel("Replace Text:"))
        input_layout.addWidget(self.input_line)
        input_layout.addWidget(self.submit_button)
        layout.addLayout(input_layout)

        # Approve, Cancel, and Reset buttons
        self.approve_button = QPushButton("Approve")
        self.cancel_button = QPushButton("Cancel")
        self.reset_button = QPushButton("Reset")
        self.approve_button.clicked.connect(self.approve)
        self.cancel_button.clicked.connect(self.reject)
        self.reset_button.clicked.connect(self.reset)
        button_layout = QHBoxLayout()
        button_layout.addWidget(self.approve_button)
        button_layout.addWidget(self.cancel_button)
        button_layout.addWidget(self.reset_button)
        layout.addLayout(button_layout)

        self.setLayout(layout)
        self.update_approve_button_state()  # Check the initial state of the Approve button
        self.highlight_next_text_tag()

    def update_approve_button_state(self):
        # Check if there are any #TEXT# tags in the note HTML
        has_text_tags = "#TEXT#" in self.text_area.toPlainText()
        self.approve_button.setEnabled(not has_text_tags)

    def highlight_next_text_tag(self):
        cursor = self.text_area.textCursor()
        format = QTextCharFormat()
        format.setBackground(Qt.yellow)
        format.setForeground(Qt.black)
        regex = QRegularExpression("#TEXT#")
        cursor = self.text_area.document().find(regex, cursor)
        if cursor.hasSelection():
            cursor.mergeCharFormat(format)
            self.text_area.setTextCursor(cursor)
        else:
            self.update_approve_button_state()  # Update the Approve button state

    def replace_text(self):
        replacement = self.input_line.text()
        cursor = self.text_area.textCursor()
        if cursor.selectedText() == "#TEXT#":
            cursor.insertText(replacement)
            self.input_line.clear()
            format = QTextCharFormat()
            format.setBackground(Qt.green)
            format.setForeground(Qt.black)
            cursor.mergeCharFormat(format)
            self.highlight_next_text_tag()
            self.update_approve_button_state()  # Update the Approve button state after replacing text

    def reset(self):
        self.note_html = self.original_note_html  # Reset the note HTML to the original
        self.text_area.setHtml(self.note_html)
        self.update_approve_button_state()  # Update the Approve button state after resetting
        self.highlight_next_text_tag()

    def approve(self):
        try:
            cursor = self.parent.dbConnection.cursor()
            settings = cursor.execute('SELECT save_behavior, timestamp_filenames FROM settings WHERE id = 1').fetchone()
            save_behavior, timestamp = settings

            note_content = self.text_area.toPlainText()

            # Determine the filename based on timestamp setting
            if timestamp:
                filename = datetime.now().strftime("Notes_%d-%m-%y_%H-%M-%S") + '.txt'
            else:
                base_filename = 'Note.txt'
                filename = base_filename
                counter = 1
                while os.path.exists(os.path.join(self.auto_save_note_folder, filename)):
                    filename = f"Note_{counter}.txt"
                    counter += 1

            filepath = os.path.join(self.auto_save_note_folder, filename)
            os.makedirs(self.auto_save_note_folder, exist_ok=True)

            # Save the note to file if save behavior is 'File' or 'Both'
            if 'File' in save_behavior or 'Both' in save_behavior:
                with open(filepath, 'w', encoding='utf-8') as file:
                    file.write(note_content)

            # Copy the note to clipboard if save behavior is 'Clipboard' or 'Both'
            if 'Clipboard' in save_behavior or 'Both' in save_behavior:
                clipboard = QApplication.clipboard()
                clipboard.setText(note_content)

            # Log the file save operation
            self.log_file_save(filename, note_content, self.auto_save_note_folder)
            self.accept()

        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred: {str(e)}")
            self.reject()
            logging.error(f"Failed to save the file: {str(e)}")

    def log_file_save(self, filename, content, note_folder_used):
        try:
            current_datetime = datetime.now()
            date_str = current_datetime.strftime("%Y-%m-%d")
            time_str = current_datetime.strftime("%H:%M:%S")
            cursor = self.parent.dbConnection.cursor()
            cursor.execute("INSERT INTO file_log (date, time, filename, content, note_folder_used) VALUES (?, ?, ?, ?, ?)",
                           (date_str, time_str, filename, content, note_folder_used))
            self.parent.dbConnection.commit()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to log file save: {str(e)}")

    def reject(self):
        super().reject()
        
class SettingsDialog(QDialog):
    def __init__(self, parent=None):
        super(SettingsDialog, self).__init__(parent)
        self.parent = parent
        self.initUI()
        self.loadSettings()
        self.setGeometry(300, 300, 300, 400)
        self.setFixedSize(self.size())

    def initUI(self):
        layout = QVBoxLayout(self)
        self.setWindowIcon(QIcon(resource_path("app_icon.ico")))

        self.timestampCheckbox = QCheckBox("Timestamp Filename", self)
        layout.addWidget(self.timestampCheckbox)

        self.noteFolderEdit = QLineEdit(self)
        self.noteFolderButton = QPushButton('Select Note Folder', self)
        self.noteFolderButton.clicked.connect(lambda: self.selectFolder(self.noteFolderEdit))

        self.defaultNoteFolderEdit = QLineEdit(self)
        self.defaultNoteFolderButton = QPushButton('Select Default Note Folder', self)
        self.defaultNoteFolderButton.clicked.connect(lambda: self.selectFolder(self.defaultNoteFolderEdit))

        # New UI elements for the auto-save feature
        layout.addWidget(QLabel('Auto-Save Note Folder:'))
        self.autoSaveNoteFolderEdit = QLineEdit(self)
        self.autoSaveNoteFolderButton = QPushButton('Select Folder', self)
        self.autoSaveNoteFolderButton.clicked.connect(lambda: self.selectFolder(self.autoSaveNoteFolderEdit))
        layout.addWidget(self.autoSaveNoteFolderEdit)
        layout.addWidget(self.autoSaveNoteFolderButton)

        layout.addWidget(QLabel('Note Folder:'))
        layout.addWidget(self.noteFolderEdit)
        layout.addWidget(self.noteFolderButton)

        layout.addWidget(QLabel('Default Note Folder:'))
        layout.addWidget(self.defaultNoteFolderEdit)
        layout.addWidget(self.defaultNoteFolderButton)

        self.saveOptions = QComboBox(self)
        self.saveOptions.addItems(['File', 'Clipboard', 'Both'])
        layout.addWidget(QLabel('Save Options:'))
        layout.addWidget(self.saveOptions)

        saveBtn = QPushButton('Save', self)
        saveBtn.clicked.connect(self.saveSettings)
        layout.addWidget(saveBtn)

    def selectFolder(self, lineEdit):
        folder = QFileDialog.getExistingDirectory(self, "Select Folder")
        if folder:
            lineEdit.setText(folder)

    def loadSettings(self):
        try:
            cursor = self.parent.dbConnection.cursor()
            # Adjust the SELECT statement to include auto_save_note_folder and timestamp_filenames
            cursor.execute('SELECT note_folder, default_note_folder, save_behavior, auto_save_note_folder, timestamp_filenames FROM settings WHERE id = 1')
            data = cursor.fetchone()

            if data:
                self.noteFolderEdit.setText(data[0])
                self.defaultNoteFolderEdit.setText(data[1])
                self.autoSaveNoteFolderEdit.setText(data[3])  # Set auto-save folder
                self.timestampCheckbox.setChecked(data[4])  # Set timestamp filenames
                
                # Set save behavior
                save_behavior_index = self.saveOptions.findText(data[2])
                if save_behavior_index != -1:
                    self.saveOptions.setCurrentIndex(save_behavior_index)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while loading settings: {str(e)}")

    def saveSettings(self):
        try:
            save_option = self.saveOptions.currentText()
            auto_save_folder = self.autoSaveNoteFolderEdit.text()
            timestamp_filenames = self.timestampCheckbox.isChecked()

            cursor = self.parent.dbConnection.cursor()
            # Adjust the UPDATE statement to include auto_save_note_folder and timestamp_filenames
            cursor.execute('UPDATE settings SET note_folder = ?, default_note_folder = ?, save_behavior = ?, auto_save_note_folder = ?, timestamp_filenames = ? WHERE id = 1',
                           (self.noteFolderEdit.text(), self.defaultNoteFolderEdit.text(), save_option, auto_save_folder, timestamp_filenames))
            
            self.parent.dbConnection.commit()
            QMessageBox.information(self, "Success", "Settings saved successfully.")
            self.close()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while saving settings: {str(e)}")
            
class AdditionalInfoWindow(QDialog):
    def __init__(self, tags_found, password, parent=None):
        super().__init__(parent)
        self.tags_found = tags_found
        self.password = password
        self.parent = parent
        self.initUI()
        self.generate_password_link()

    def initUI(self):
        layout = QVBoxLayout()
        self.setWindowTitle("Additional Information")
        self.setMinimumWidth(600)

        label_width = 150

        # Row 1: Username Pattern, E-Mail Pattern
        row1_layout = QGridLayout()
        self.username_label = QLabel("Username Pattern:")
        self.username_label.setFixedWidth(label_width)
        self.username_dropdown = QComboBox()
        self.username_dropdown.addItems([
            "FirstName",
            "LastName",
            "Last_First",
            "FirstName.LastName",
            "FirstInitial.LastName",
            "FirstName_LastName",
            "FirstNameLastName",
            "FirstName.LastInitial",
            "FirstInitialLastName",
            "FirstName.MiddleInitial.LastName",
            "FirstInitial.MiddleInitial.LastName",
            "First_LastInitial",
            "Last_FirstNameInitial"
        ])
        self.username_dropdown.currentIndexChanged.connect(self.update_username_preview)
        self.username_dropdown.currentIndexChanged.connect(self.update_email_pattern)

        self.email_label = QLabel("E-Mail Pattern:")
        self.email_label.setFixedWidth(label_width)
        self.email_dropdown = QComboBox()
        self.email_dropdown.addItems([
            "FirstName",
            "LastName",
            "Last_First",
            "FirstName.LastName",
            "FirstInitial.LastName",
            "FirstName_LastName",
            "FirstNameLastName",
            "FirstName.LastInitial",
            "FirstInitialLastName",
            "LastName.FirstName",
            "LastNameFirstInitial",
            "LastNameFirstName",
            "FirstName.MiddleInitial.LastName",
            "FirstInitial.MiddleInitial.LastName",
            "First_LastInitial",
            "Last_FirstNameInitial",
            "Manually Enter E-Mail"
        ])
        self.email_dropdown.currentIndexChanged.connect(self.toggle_email_input)
        self.email_dropdown.currentIndexChanged.connect(self.update_button_visibility)
        self.email_copy_button = QPushButton(">")  # Add the email_copy_button attribute
        self.email_copy_button.setFixedWidth(30)
        self.email_copy_button.setFocusPolicy(Qt.NoFocus)
        self.email_copy_button.clicked.connect(lambda: QApplication.clipboard().setText(self.email_preview_edit.text()))

        row1_layout.addWidget(self.username_label, 0, 0)
        row1_layout.addWidget(self.username_dropdown, 0, 1)
        row1_layout.addWidget(self.email_label, 1, 0)
        row1_layout.addWidget(self.email_dropdown, 1, 1)
        row1_layout.addWidget(self.email_copy_button, 1, 2)  # Add the email_copy_button to the layout
        row1_layout.setColumnStretch(1, 1)
        layout.addLayout(row1_layout)

        # Row 2: First Name, Middle Name, Last Name
        row2_layout = QGridLayout()
        self.first_name_label = QLabel("First Name:")
        self.first_name_label.setFixedWidth(label_width)
        self.first_name_edit = QLineEdit()
        self.first_name_edit.textChanged.connect(self.update_full_name_preview)
        self.first_name_edit.textChanged.connect(self.update_button_visibility)
        self.first_name_copy_button = QPushButton(">")
        self.first_name_copy_button.setFixedWidth(30)
        self.first_name_copy_button.setFocusPolicy(Qt.NoFocus)
        self.first_name_copy_button.clicked.connect(lambda: QApplication.clipboard().setText(self.first_name_edit.text()))

        self.middle_name_label = QLabel("Middle Name (Optional):")
        self.middle_name_label.setFixedWidth(label_width)
        self.middle_name_edit = QLineEdit()
        self.middle_name_edit.textChanged.connect(self.update_full_name_preview)
        self.middle_name_edit.textChanged.connect(self.update_button_visibility)
        self.middle_name_copy_button = QPushButton(">")
        self.middle_name_copy_button.setFixedWidth(30)
        self.middle_name_copy_button.setFocusPolicy(Qt.NoFocus)
        self.middle_name_copy_button.clicked.connect(lambda: QApplication.clipboard().setText(self.middle_name_edit.text()))

        self.last_name_label = QLabel("Last Name:")
        self.last_name_label.setFixedWidth(label_width)
        self.last_name_edit = QLineEdit()
        self.last_name_edit.textChanged.connect(self.update_full_name_preview)
        self.last_name_edit.textChanged.connect(self.update_button_visibility)
        self.last_name_copy_button = QPushButton(">")
        self.last_name_copy_button.setFixedWidth(30)
        self.last_name_copy_button.setFocusPolicy(Qt.NoFocus)
        self.last_name_copy_button.clicked.connect(lambda: QApplication.clipboard().setText(self.last_name_edit.text()))

        row2_layout.addWidget(self.first_name_label, 0, 0)
        row2_layout.addWidget(self.first_name_edit, 0, 1)
        row2_layout.addWidget(self.first_name_copy_button, 0, 2)
        row2_layout.addWidget(self.middle_name_label, 1, 0)
        row2_layout.addWidget(self.middle_name_edit, 1, 1)
        row2_layout.addWidget(self.middle_name_copy_button, 1, 2)
        row2_layout.addWidget(self.last_name_label, 2, 0)
        row2_layout.addWidget(self.last_name_edit, 2, 1)
        row2_layout.addWidget(self.last_name_copy_button, 2, 2)
        row2_layout.setColumnStretch(1, 1)
        layout.addLayout(row2_layout)

        # Row 3: Full Name Preview
        row3_layout = QHBoxLayout()
        self.full_name_preview_label = QLabel("Full Name Preview:")
        self.full_name_preview_label.setFixedWidth(label_width)
        self.full_name_preview_edit = QLineEdit()
        self.full_name_preview_edit.setReadOnly(True)
        self.full_name_preview_copy_button = QPushButton(">")
        self.full_name_preview_copy_button.setFixedWidth(30)
        self.full_name_preview_copy_button.setFocusPolicy(Qt.NoFocus)
        self.full_name_preview_copy_button.clicked.connect(lambda: QApplication.clipboard().setText(self.full_name_preview_edit.text()))

        row3_layout.addWidget(self.full_name_preview_label)
        row3_layout.addWidget(self.full_name_preview_edit)
        row3_layout.addWidget(self.full_name_preview_copy_button)
        layout.addLayout(row3_layout)

        # Row 4: Username Preview
        row4_layout = QHBoxLayout()
        self.username_preview_label = QLabel("Username Preview:")
        self.username_preview_label.setFixedWidth(label_width)
        self.username_preview_edit = QLineEdit()
        self.username_preview_edit.setReadOnly(True)
        self.username_preview_copy_button = QPushButton(">")
        self.username_preview_copy_button.setFixedWidth(30)
        self.username_preview_copy_button.setFocusPolicy(Qt.NoFocus)
        self.username_preview_copy_button.clicked.connect(lambda: QApplication.clipboard().setText(self.username_preview_edit.text()))

        row4_layout.addWidget(self.username_preview_label)
        row4_layout.addWidget(self.username_preview_edit)
        row4_layout.addWidget(self.username_preview_copy_button)
        layout.addLayout(row4_layout)

        # Row 5: E-Mail Domain, E-Mail Preview
        row5_layout = QGridLayout()
        self.email_domain_label = QLabel("E-Mail Domain:")
        self.email_domain_label.setFixedWidth(label_width)
        self.email_domain_edit = QComboBox()
        self.email_domain_edit.setEditable(True)
        self.email_domain_edit.setInsertPolicy(QComboBox.NoInsert)
        self.email_domain_edit.setCompleter(QCompleter([]))
        self.email_domain_line_edit = FocusLineEdit()
        self.email_domain_edit.setLineEdit(self.email_domain_line_edit)
        self.email_domain_edit.lineEdit().setPlaceholderText("Enter domain")
        self.load_domains()
        self.email_domain_edit.lineEdit().textChanged.connect(self.update_email_preview)
        self.email_domain_edit.lineEdit().textChanged.connect(self.update_button_visibility)
        self.email_domain_edit.currentIndexChanged.connect(self.update_email_preview)
        self.email_domain_line_edit.focusOut.connect(self.save_domain_on_focus_out)

        self.email_preview_label = QLabel("E-Mail Preview:")
        self.email_preview_label.setFixedWidth(label_width)
        self.email_preview_edit = QLineEdit()
        self.email_preview_edit.setReadOnly(True)
        self.email_preview_copy_button = QPushButton(">")
        self.email_preview_copy_button.setFixedWidth(30)
        self.email_preview_copy_button.setFocusPolicy(Qt.NoFocus)
        self.email_preview_copy_button.clicked.connect(lambda: QApplication.clipboard().setText(self.email_preview_edit.text()))

        row5_layout.addWidget(self.email_domain_label, 0, 0)
        row5_layout.addWidget(self.email_domain_edit, 0, 1)
        row5_layout.addWidget(self.email_preview_label, 1, 0)
        row5_layout.addWidget(self.email_preview_edit, 1, 1)
        row5_layout.addWidget(self.email_preview_copy_button, 1, 2)
        row5_layout.setColumnStretch(1, 1)
        layout.addLayout(row5_layout)

        # Row 6: Password, Password Link
        row6_layout = QGridLayout()
        self.password_label = QLabel("Password:")
        self.password_label.setFixedWidth(label_width)
        self.password_edit = QLineEdit(self.password)
        self.password_edit.setReadOnly(True)
        self.password_copy_button = QPushButton(">")
        self.password_copy_button.setFixedWidth(30)
        self.password_copy_button.setFocusPolicy(Qt.NoFocus)
        self.password_copy_button.clicked.connect(lambda: QApplication.clipboard().setText(self.password_edit.text()))

        self.password_link_label = QLabel("Password Link:")
        self.password_link_label.setFixedWidth(label_width)
        self.password_link_edit = QLineEdit(self.parent.passwordTextEdit.text())
        self.password_link_edit.setReadOnly(True)
        self.password_link_copy_button = QPushButton(">")
        self.password_link_copy_button.setFixedWidth(30)
        self.password_link_copy_button.setFocusPolicy(Qt.NoFocus)
        self.password_link_copy_button.clicked.connect(lambda: QApplication.clipboard().setText(self.password_link_edit.text()))

        row6_layout.addWidget(self.password_label, 0, 0)
        row6_layout.addWidget(self.password_edit, 0, 1)
        row6_layout.addWidget(self.password_copy_button, 0, 2)
        row6_layout.addWidget(self.password_link_label, 1, 0)
        row6_layout.addWidget(self.password_link_edit, 1, 1)
        row6_layout.addWidget(self.password_link_copy_button, 1, 2)
        row6_layout.setColumnStretch(1, 1)
        layout.addLayout(row6_layout)

        # Row 7: Checkboxes for saving/sending information
        row7_layout = QHBoxLayout()
        self.first_name_checkbox = QCheckBox("First Name")
        self.middle_name_checkbox = QCheckBox("Middle Name")
        self.last_name_checkbox = QCheckBox("Last Name")
        self.full_name_checkbox = QCheckBox("Full Name")
        self.username_checkbox = QCheckBox("Username")
        self.email_checkbox = QCheckBox("E-Mail")
        self.password_checkbox = QCheckBox("Password")
        self.password_link_checkbox = QCheckBox("Password Link")

        # Set all checkboxes to be checked by default
        self.first_name_checkbox.setChecked(True)
        self.middle_name_checkbox.setChecked(True)
        self.last_name_checkbox.setChecked(True)
        self.full_name_checkbox.setChecked(True)
        self.username_checkbox.setChecked(True)
        self.email_checkbox.setChecked(True)
        self.password_checkbox.setChecked(True)
        self.password_link_checkbox.setChecked(True)

        row7_layout.addWidget(self.first_name_checkbox)
        row7_layout.addWidget(self.middle_name_checkbox)
        row7_layout.addWidget(self.last_name_checkbox)
        row7_layout.addWidget(self.full_name_checkbox)
        row7_layout.addWidget(self.username_checkbox)
        row7_layout.addWidget(self.email_checkbox)
        row7_layout.addWidget(self.password_checkbox)
        row7_layout.addWidget(self.password_link_checkbox)
        layout.addLayout(row7_layout)

        # Row 8: Save, Clear, Generate New buttons
        button_layout = QHBoxLayout()
        self.save_button = QPushButton("Save")
        self.save_button.clicked.connect(self.save_information)
        self.clear_button = QPushButton("Clear")
        self.clear_button.clicked.connect(self.clear_fields)
        self.generate_button = QPushButton("Generate New")
        self.generate_button.clicked.connect(self.generate_new_password_link)
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.clear_button)
        button_layout.addWidget(self.generate_button)
        layout.addLayout(button_layout)

        self.setLayout(layout)
        self.update_button_visibility()
        
    def update_button_visibility(self):
        self.first_name_copy_button.setVisible(bool(self.first_name_edit.text()))
        self.middle_name_copy_button.setVisible(bool(self.middle_name_edit.text()))
        self.last_name_copy_button.setVisible(bool(self.last_name_edit.text()))
        self.full_name_preview_copy_button.setVisible(bool(self.full_name_preview_edit.text()))
        self.username_preview_copy_button.setVisible(bool(self.username_preview_edit.text()))
        self.email_copy_button.setVisible(bool(self.email_dropdown.currentText() == "Manually Enter E-Mail" or self.email_domain_edit.currentText()))
        self.password_copy_button.setVisible(bool(self.password_edit.text()))
        self.password_link_copy_button.setVisible(bool(self.password_link_edit.text()))

    def toggle_email_input(self, index):
        try:
            if self.email_dropdown.itemText(index) == "Manually Enter E-Mail":
                self.email_label.setVisible(False)
                self.email_dropdown.setVisible(False)
                self.email_domain_label.setText("E-Mail:")
                self.email_domain_edit.setPlaceholderText("Enter full email address")
            else:
                self.email_label.setVisible(True)
                self.email_dropdown.setVisible(True)
                self.email_domain_label.setText("E-Mail Domain:")
                self.email_domain_edit.setPlaceholderText("Enter domain")
            self.update_email_preview()
            self.update_button_visibility()
        except Exception as e:
            print(f"An error occurred in toggle_email_input: {str(e)}")

    def update_full_name_preview(self):
        first_name = self.first_name_edit.text()
        middle_name = self.middle_name_edit.text()
        last_name = self.last_name_edit.text()
    
        # Create the full name, omitting the middle name if it is not present
        full_name = f"{first_name} {middle_name} {last_name}".replace("  ", " ").strip()
        self.full_name_preview_edit.setText(full_name)
    
        self.update_username_preview()
        self.update_email_preview()
        self.update_button_visibility()

    def update_email_preview(self):
        try:
            first_name = self.first_name_edit.text()
            middle_name = self.middle_name_edit.text()
            last_name = self.last_name_edit.text()
            email_pattern = self.email_dropdown.currentText()
            domain = self.email_domain_edit.currentText()
            if email_pattern == "Manually Enter E-Mail":
                email = domain
            else:
                email = self.generate_email(email_pattern, first_name, middle_name, last_name, domain)
            self.email_preview_edit.setText(email)
            self.update_button_visibility()
        except Exception as e:
            print(f"An error occurred in update_email_preview: {str(e)}")
            self.email_preview_edit.clear()
            self.update_button_visibility()

    def update_username_preview(self):
        try:
            first_name = self.first_name_edit.text()
            middle_name = self.middle_name_edit.text()
            last_name = self.last_name_edit.text()
            username_pattern = self.username_dropdown.currentText()
            username = self.generate_username(username_pattern, first_name, middle_name, last_name)
            self.username_preview_edit.setText(username)
            self.update_button_visibility()
        except Exception as e:
            print(f"An error occurred in update_username_preview: {str(e)}")
            self.username_preview_edit.clear()
            self.update_button_visibility()

    def update_email_pattern(self, index):
        self.email_dropdown.setCurrentIndex(index)
        self.update_email_preview()

    def load_domains(self):
        self.domains_file_path = r'C:\TSTP\TSTP-Omni_Omega\Notes\domains.txt'
        try:
            with open(self.domains_file_path, 'r') as file:
                domains = file.read().splitlines()
                self.email_domain_edit.addItems(domains)
        except FileNotFoundError:
            os.makedirs(os.path.dirname(self.domains_file_path), exist_ok=True)
            open(self.domains_file_path, 'w').close()

    def save_domain(self, domain):
        with open(self.domains_file_path, 'a') as file:
            file.write(domain + '\n')

    def save_domain_on_focus_out(self):
        domain = self.email_domain_edit.currentText()
        if domain and domain not in [self.email_domain_edit.itemText(i) for i in range(self.email_domain_edit.count())]:
            self.email_domain_edit.addItem(domain)
            self.save_domain(domain)
        
    def generate_email(self, pattern, first_name, middle_name, last_name, domain):
        try:
            if not first_name or not last_name or not domain:
                return ""
            if pattern == "FirstName":
                return f"{first_name}@{domain}"
            elif pattern == "LastName":
                return f"{last_name}@{domain}"
            elif pattern == "Last_First":
                return f"{last_name}_{first_name}@{domain}"
            elif pattern == "FirstName.LastName":
                return f"{first_name}.{last_name}@{domain}"
            elif pattern == "FirstInitial.LastName":
                return f"{first_name[0]}.{last_name}@{domain}"
            elif pattern == "FirstName_LastName":
                return f"{first_name}_{last_name}@{domain}"
            elif pattern == "FirstNameLastName":
                return f"{first_name}{last_name}@{domain}"
            elif pattern == "FirstName.LastInitial":
                return f"{first_name}.{last_name[0]}@{domain}"
            elif pattern == "FirstInitialLastName":
                return f"{first_name[0]}{last_name}@{domain}"
            elif pattern == "LastName.FirstName":
                return f"{last_name}.{first_name}@{domain}"
            elif pattern == "LastNameFirstInitial":
                return f"{last_name}{first_name[0]}@{domain}"
            elif pattern == "LastNameFirstName":
                return f"{last_name}{first_name}@{domain}"
            elif pattern == "FirstName.MiddleInitial.LastName":
                return f"{first_name}.{middle_name[0]}.{last_name}@{domain}" if middle_name else f"{first_name}.{last_name}@{domain}"
            elif pattern == "FirstInitial.MiddleInitial.LastName":
                return f"{first_name[0]}.{middle_name[0]}.{last_name}@{domain}" if middle_name else f"{first_name[0]}.{last_name}@{domain}"
            elif pattern == "First_LastInitial":
                return f"{first_name}_{last_name[0]}@{domain}"
            elif pattern == "Last_FirstNameInitial":
                return f"{last_name}_{first_name[0]}@{domain}"
            else:
                return ""
        except Exception as e:
            print(f"An error occurred in generate_email: {str(e)}")
            return ""

    def generate_username(self, pattern, first_name, middle_name, last_name):
        try:
            if not first_name or not last_name:
                return ""
            if pattern == "FirstName":
                return first_name
            elif pattern == "LastName":
                return last_name
            elif pattern == "Last_First":
                return f"{last_name}_{first_name}"
            elif pattern == "FirstName.LastName":
                return f"{first_name}.{last_name}"
            elif pattern == "FirstInitial.LastName":
                return f"{first_name[0]}.{last_name}"
            elif pattern == "FirstName_LastName":
                return f"{first_name}_{last_name}"
            elif pattern == "FirstNameLastName":
                return f"{first_name}{last_name}"
            elif pattern == "FirstName.LastInitial":
                return f"{first_name}.{last_name[0]}"
            elif pattern == "FirstInitialLastName":
                return f"{first_name[0]}{last_name}"
            elif pattern == "FirstName.MiddleInitial.LastName":
                return f"{first_name}.{middle_name[0]}.{last_name}" if middle_name else f"{first_name}.{last_name}"
            elif pattern == "FirstInitial.MiddleInitial.LastName":
                return f"{first_name[0]}.{middle_name[0]}.{last_name}" if middle_name else f"{first_name[0]}.{last_name}"
            elif pattern == "First_LastInitial":
                return f"{first_name}_{last_name[0]}"
            elif pattern == "Last_FirstNameInitial":
                return f"{last_name}_{first_name[0]}"
            else:
                return ""
        except Exception as e:
            print(f"An error occurred in generate_username: {str(e)}")
            return ""

    def clear_fields(self):
        self.first_name_edit.clear()
        self.middle_name_edit.clear()
        self.last_name_edit.clear()
        self.username_dropdown.setCurrentIndex(0)
        self.email_dropdown.setCurrentIndex(0)
        self.email_domain_edit.clear()
        self.full_name_preview_edit.clear()
        self.username_preview_edit.clear()
        self.email_preview_edit.clear()
            
    def generate_password_link(self):
        # Use PWPush to obtain a password link
        url = 'https://pwpush.com/p.json'
        data = {
            'password': {
                'payload': self.password,
                'expire_after_days': 30,
                'expire_after_views': 11,
                'note': 'Reference Note. Encrypted & Visible Only to You.',
                'retrieval_step': True,
                'deletable_by_viewer': True
            }
        }

        try:
            response = requests.post(url, json=data)
            response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code

            # Get the 'url_token' from the response, if available
            password_link_token = response.json().get('url_token')
            if password_link_token:
                password_link = f"https://pwpush.com/p/{password_link_token}"
                self.password_link_edit.setText(password_link)  # Update the password link display in the dialog
                self.parent.updateTextInTextEdit(self.password, password_link)  # Ensure to add data to text edit if empty
            else:
                QMessageBox.critical(self, 'Error', 'Failed to obtain the password link from the response.')
        except requests.exceptions.HTTPError as http_err:
            QMessageBox.critical(self, 'Error', f'HTTP error occurred: {http_err}')
        except Exception as err:
            QMessageBox.critical(self, 'Error', f'An error occurred: {err}')

    def save_information(self):
        user_info = {}
        if self.first_name_checkbox.isChecked():
            user_info['first_name'] = self.first_name_edit.text()
        if self.middle_name_checkbox.isChecked():
            user_info['middle_name'] = self.middle_name_edit.text()
        if self.last_name_checkbox.isChecked():
            user_info['last_name'] = self.last_name_edit.text()
        if self.full_name_checkbox.isChecked():
            user_info['full_name'] = self.full_name_preview_edit.text()
        if self.username_checkbox.isChecked():
            user_info['username'] = self.username_preview_edit.text()
        if self.email_checkbox.isChecked():
            user_info['email'] = self.email_preview_edit.text()

        checkbox_states = {
            'first_name_checked': self.first_name_checkbox.isChecked(),
            'middle_name_checked': self.middle_name_checkbox.isChecked(),
            'last_name_checked': self.last_name_checkbox.isChecked(),
            'full_name_checked': self.full_name_checkbox.isChecked(),
            'username_checked': self.username_checkbox.isChecked(),
            'email_checked': self.email_checkbox.isChecked(),
            'password_checked': self.password_checkbox.isChecked(),
            'password_link_checked': self.password_link_checkbox.isChecked()
        }

        self.parent.updateTextInTextEdit(self.password, self.password_link_edit.text(), user_info, checkbox_states)
        self.close()

    def generate_new_password_link(self):
        self.parent.generatePassword()  # Generate a new password
        self.password = self.parent.passwordTextEdit.text()  # Update the password in the dialog
        self.password_edit.setText(self.password)  # Update the password display in the dialog
        self.generate_password_link()

class ReportWindow(QWidget):
    def __init__(self, omni_omega, db_path='omni_omega.db', theme=None):
        super().__init__()
        self.omni_omega = omni_omega
        self.db_path = db_path
        self.initDBConnection()
        self.initUI()
        self.sortDescending = False  # Initialize sortDescending here
        self.currentSortKey = 'Date'
        self.applyTheme(theme)
        
        self.omni_omega.themeChanged.connect(self.applyTheme)

    def initUI(self):
        try:
            self.setWindowTitle("Notes Report")
            self.setGeometry(100, 100, 1000, 600)
            layout = QVBoxLayout()
            self.setWindowIcon(QIcon(resource_path("app_icon.ico")))

            self.tabs = QTabWidget()
            self.reportTab = QWidget()
            self.statsTab = QWidget()

            self.setupReportTab()
            self.setupStatsTab()

            self.tabs.addTab(self.reportTab, "Report")
            self.tabs.addTab(self.statsTab, "Statistics")

            layout.addWidget(self.tabs)
            self.setLayout(layout)
        except Exception as e:
            QMessageBox.critical(self, "Initialization Error", f"An error occurred during UI initialization: {str(e)}")
            logging.error(f"Initialization Error: {e}")
            
    def applyTheme(self, theme):
        if theme:
            self.setStyleSheet(theme)
            self.reportTab.setStyleSheet(theme)
            self.statsTab.setStyleSheet(theme)

    def initDBConnection(self):
        try:
            self.db_connection = sqlite3.connect(self.db_path)
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Database Connection Error", f"Failed to connect to database: {e}")
            self.db_connection = None

    def create_connection(self):
        try:
            connection = sqlite3.connect(self.db_path)
            return connection
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Database Connection Error", f"Failed to connect to database: {e}")
            return None

    def fetchData(self):
        if not self.db_connection:
            QMessageBox.warning(self, "Database Error", "No database connection.")
            return []
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("SELECT date, time, filename, content FROM file_log")
            return cursor.fetchall()
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Data Fetch Error", f"Failed to retrieve data: {e}")
            return []

    def setupReportTab(self):
        reportLayout = QVBoxLayout()
        self.viewToggleCheckbox = QCheckBox("Use Styled View")
        self.viewToggleCheckbox.stateChanged.connect(self.toggleView)

        # Traditional table view setup
        self.tableView = self.setupTableView()
        
        # Styled list view setup (hidden by default)
        self.styledView = self.setupStyledView()
        self.styledView.hide()

        btnLayout = QHBoxLayout()
        for header in ["Date", "Time", "Filename", "Content"]:
            btn = QPushButton(f"Sort by {header}")
            btn.setStyleSheet("""
                QPushButton {
                    padding: 8px 16px;
                    border-radius: 4px;
                    font-size: 14px;
                }
            """)
            btn.clicked.connect(lambda ch, key=header: self.sortNotes(key, self.tableView))
            btnLayout.addWidget(btn)

        reportLayout.addWidget(self.viewToggleCheckbox)
        reportLayout.addLayout(btnLayout)
        reportLayout.addWidget(self.tableView)
        reportLayout.addWidget(self.styledView)
        self.reportTab.setLayout(reportLayout)
        self.tableView.setWordWrap(True)
        self.tableView.resizeRowsToContents()

    def toggleView(self, state):
        if state == Qt.Checked:
            self.tableView.hide()
            self.styledView.show()
        else:
            self.tableView.show()
            self.styledView.hide()
            
    def setupStyledView(self):
        styledWidget = QWidget()
        styledLayout = QVBoxLayout(styledWidget)

        # Add collapse/expand all button
        collapseExpandButton = QPushButton("Collapse All")
        collapseExpandButton.clicked.connect(self.collapseExpandAllNotes)
        styledLayout.addWidget(collapseExpandButton)

        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
    
        content_widget = QWidget()
        self.styledLayout = QVBoxLayout(content_widget)

        # Group notes by day
        notes_by_day = {}
        for note in self.getNotesData():
            date = note['date']
            if date not in notes_by_day:
                notes_by_day[date] = []
            notes_by_day[date].append(note)

        # Create note widgets grouped by day
        for date, notes in notes_by_day.items():
            dateLabel = QLabel(f"Date: {date}")
            dateLabel.setStyleSheet("font-weight: bold; font-size: 16px; margin-top: 10px;")
            self.styledLayout.addWidget(dateLabel)

            for note in notes:
                noteWidget = self.createNoteWidget(note)
                self.styledLayout.addWidget(noteWidget)

        scroll_area.setWidget(content_widget)
        styledLayout.addWidget(scroll_area)

        styledWidget.setLayout(styledLayout)
        return styledWidget

    def collapseExpandAllNotes(self):
        button = self.sender()
        if button.text() == "Collapse All":
            self.setNoteContentVisibility(False)
            button.setText("Expand All")
        else:
            self.setNoteContentVisibility(True)
            button.setText("Collapse All")

    def setNoteContentVisibility(self, visible):
        for noteWidget in self.styledLayout.parentWidget().findChildren(QWidget):
            contentLabel = noteWidget.findChild(QLabel, "note-content")
            toggleButton = noteWidget.findChild(QPushButton)
            if contentLabel:
                contentLabel.setVisible(visible)
                toggleButton.setText("-" if visible else "+")

    def toggleSortOrder(self):
        # Call this method to toggle the sort order
        self.sortDescending = not self.sortDescending
        self.sortNotes(self.currentSortKey, self.tableView if self.tableView.isVisible() else self.styledView)

    def updateStyledView(self, sorted_notes):
        # Clear the current layout
        while self.styledLayout.count():
            child = self.styledLayout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        
        # Add sorted notes to the styled layout
        for note in sorted_notes:
            noteWidget = self.createNoteWidget(note)
            self.styledLayout.addWidget(noteWidget)

    def createNoteWidget(self, note):
        noteWidget = QWidget()
        noteLayout = QVBoxLayout(noteWidget)
        noteWidget.setStyleSheet("""
            QWidget {
                border: 1px solid #e0e0e0;
                border-radius: 6px;
                margin: 5px;
                padding: 10px;
            }
            QLabel {
                font-size: 14px;
            }
            .note-header {
                font-weight: bold;
                margin-bottom: 5px;
            }
            .note-content {
                white-space: pre-wrap;
                word-wrap: break-word;
                padding: 10px;
                border-radius: 4px;
            }
            .note-separator {
                border: none;
                border-top: 1px solid #e0e0e0;
                margin: 10px 0;
            }
            QPushButton {
                padding: 5px;
                border-radius: 4px;
                border: 1px solid #ccc;
            }
            QPushButton:hover {
            }
        """)

        headerWidget = QWidget()
        headerLayout = QHBoxLayout(headerWidget)
        headerLayout.setContentsMargins(0, 0, 0, 0)
        headerLayout.setSpacing(5)

        toggleButton = QPushButton("▼")
        toggleButton.setFixedSize(30, 30)
        toggleButton.clicked.connect(lambda: self.toggleNoteContent(noteWidget))

        dateLabel = QLabel(f"Date: {note['date']}")
        dateLabel.setObjectName("note-header")
        timeLabel = QLabel(f"Time: {note['time']}")
        timeLabel.setObjectName("note-header")
        filenameLabel = QLabel(f"Filename: {note['filename']}")
        filenameLabel.setObjectName("note-header")

        copyButton = QPushButton("Copy")
        copyButton.clicked.connect(lambda: self.copyNoteToClipboard(note))

        deleteButton = QPushButton("Delete")
        deleteButton.clicked.connect(lambda: self.deleteNoteFromDatabase(note))

        headerLayout.addWidget(toggleButton)
        headerLayout.addWidget(dateLabel)
        headerLayout.addWidget(timeLabel)
        headerLayout.addWidget(filenameLabel)
        headerLayout.addStretch()
        headerLayout.addWidget(copyButton)
        headerLayout.addWidget(deleteButton)

        contentLabel = QLabel(note['content'])
        contentLabel.setObjectName("note-content")
        contentLabel.setWordWrap(True)

        noteLayout.addWidget(headerWidget)
        noteLayout.addWidget(contentLabel)

        separator = QFrame()
        separator.setObjectName("note-separator")
        noteLayout.addWidget(separator)

        return noteWidget

    def toggleNoteContent(self, noteWidget):
        contentLabel = noteWidget.findChild(QLabel, "note-content")
        toggleButton = noteWidget.findChild(QPushButton)

        if contentLabel.isVisible():
            contentLabel.setVisible(False)
            toggleButton.setText("▶")
        else:
            contentLabel.setVisible(True)
            toggleButton.setText("▼")

    def copyNoteToClipboard(self, note):
        clipboard = QApplication.clipboard()
        clipboard.setText(note['content'])

    def deleteNoteFromDatabase(self, note):
        reply = QMessageBox.question(self, "Delete Note", "Are you sure you want to delete this note?",
                                     QMessageBox.Yes | QMessageBox.No)
        if reply == QMessageBox.Yes:
            try:
                cursor = self.db_connection.cursor()
                cursor.execute("DELETE FROM file_log WHERE date = ? AND time = ? AND filename = ?",
                               (note['date'], note['time'], note['filename']))
                self.db_connection.commit()
                self.refreshStyledView()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"An error occurred while deleting the note: {str(e)}")

    def refreshStyledView(self):
        self.styledLayout.parentWidget().deleteLater()
        self.styledView = self.setupStyledView()
        self.tabs.widget(1).layout().addWidget(self.styledView)

    def setupTableView(self):
        # Create the table widget with four columns
        tableWidget = QTableWidget()
        tableWidget.setColumnCount(4)  # Date, Time, Filename, Content
        tableWidget.setHorizontalHeaderLabels(["Date", "Time", "Filename", "Content"])
        tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        tableWidget.verticalHeader().setVisible(False)
        tableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers)
        tableWidget.setSelectionBehavior(QAbstractItemView.SelectRows)
        tableWidget.setSortingEnabled(True)

        # Style the table widget
        tableWidget.setStyleSheet("""
            QTableWidget {
                font-size: 14px;
                border: none;
            }
            QTableWidget::item {
                padding: 5px;
            }
            QHeaderView::section {
                padding: 5px;
                border: 1px solid #d3d3d3;
                font-size: 14px;
            }
            QTableCornerButton::section {
                border: 1px solid #d3d3d3;
            }
        """)

        # Fetch and load data
        self.loadNotesData(tableWidget)

        return tableWidget

    def setupStatsTab(self):
        layout = QVBoxLayout()

        # Add collapse/expand all button
        collapseExpandButton = QPushButton("Collapse All")
        collapseExpandButton.clicked.connect(self.collapseExpandAllStats)
        layout.addWidget(collapseExpandButton)

        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        
        stats_widget = QWidget()
        self.statsLayout = QVBoxLayout(stats_widget)
        scroll_area.setWidget(stats_widget)

        stats_data = self.getStatsData()
        
        stats_widget.setStyleSheet("""
            QWidget {
                border-radius: 6px;
                padding: 10px;
            }
            QLabel {
                font-size: 16px;
                padding: 8px;
                border-radius: 4px;
            }
            .title {
                font-size: 18px;
                font-weight: bold;
                margin-bottom: 4px;
            }
            .content {
                margin-bottom: 8px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
            }
            QPushButton {
                padding: 5px;
                border-radius: 4px;
                border: 1px solid #ccc;
            }
        """)

        # Create a title label for the statistics
        title_label = QLabel("Note Statistics")
        title_label.setStyleSheet("""
            font-size: 24px;
            font-weight: bold;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
        """)
        title_label.setAlignment(Qt.AlignCenter)
        self.statsLayout.addWidget(title_label)

        data = self.fetchData()
        today = datetime.now().date()
        week_start = today - timedelta(days=today.weekday())
        month_start = today.replace(day=1)
        year_start = today.replace(month=1, day=1)

        total_notes = len(data)
        today_notes = len([note for note in data if note[0] == str(today)])
        week_notes = len([note for note in data if week_start <= datetime.strptime(note[0], "%Y-%m-%d").date() <= today])
        month_notes = len([note for note in data if month_start <= datetime.strptime(note[0], "%Y-%m-%d").date() <= today])
        year_notes = len([note for note in data if year_start <= datetime.strptime(note[0], "%Y-%m-%d").date() <= today])

        most_common_lines = Counter([note[3] for note in data]).most_common(5)
        most_active_day = self.most_active_day(data)
        most_active_week = self.most_active_week(data, week_start, today)
        most_active_month = self.most_active_month(data, month_start, today)
        day_of_week_analysis = self.day_of_week_analysis(data)
        average_note_length = self.average_note_length(data)
        shortest_note_length = min([len(note[3]) for note in data]) if data else 0
        longest_note_length = max([len(note[3]) for note in data]) if data else 0
        today_average_note_length = self.average_note_length([note for note in data if note[0] == str(today)])

        font = QFont("Arial", 14)
        font_bold = QFont("Arial", 14, QFont.Bold)

        # Total Notes
        total_notes_label = QLabel(f"Total Notes: {total_notes}")
        total_notes_label.setFont(font_bold)
        total_notes_widget = self.createStatWidget("Total Notes", total_notes)
        self.statsLayout.addWidget(total_notes_widget)

        # Today's Notes
        today_notes_label = QLabel(f"Today's Notes: {today_notes}")
        today_notes_label.setFont(font)
        today_notes_widget = self.createStatWidget("Today's Notes", today_notes)
        self.statsLayout.addWidget(today_notes_widget)

        # This Week's Notes
        week_notes_label = QLabel(f"This Week's Notes: {week_notes}")
        week_notes_label.setFont(font)
        week_notes_widget = self.createStatWidget("This Week's Notes", week_notes)
        self.statsLayout.addWidget(week_notes_widget)

        # This Month's Notes
        month_notes_label = QLabel(f"This Month's Notes: {month_notes}")
        month_notes_label.setFont(font)
        month_notes_widget = self.createStatWidget("This Month's Notes", month_notes)
        self.statsLayout.addWidget(month_notes_widget)

        # This Year's Notes
        year_notes_label = QLabel(f"This Year's Notes: {year_notes}")
        year_notes_label.setFont(font)
        year_notes_widget = self.createStatWidget("This Year's Notes", year_notes)
        self.statsLayout.addWidget(year_notes_widget)

        # Most Common Lines
        most_common_lines_label = QLabel("Most Common Lines:")
        most_common_lines_label.setFont(font_bold)
        most_common_lines_widget = self.createStatWidget("Most Common Lines", "")
        for i, (line, count) in enumerate(most_common_lines, start=1):
            line_label = QLabel(f"{i}. '{line}' - {count} times")
            line_label.setFont(font)
            line_widget = QWidget()
            line_layout = QVBoxLayout(line_widget)
            line_layout.addWidget(line_label)
            most_common_lines_widget.layout().addWidget(line_widget)
        self.statsLayout.addWidget(most_common_lines_widget)

        # Most Active
        most_active_day_label = QLabel(f"Most Active Day: {most_active_day[0]} ({most_active_day[1]} notes)")
        most_active_day_label.setFont(font_bold)
        most_active_week_label = QLabel(f"Most Active Week: {most_active_week[0]} ({most_active_week[1]} notes)")
        most_active_week_label.setFont(font_bold)
        most_active_month_label = QLabel(f"Most Active Month: {most_active_month[0]} ({most_active_month[1]} notes)")
        most_active_month_label.setFont(font_bold)

        most_active_widget = self.createStatWidget("Most Active", "")
        most_active_widget.layout().addWidget(most_active_day_label)
        most_active_widget.layout().addWidget(most_active_week_label)
        most_active_widget.layout().addWidget(most_active_month_label)
        self.statsLayout.addWidget(most_active_widget)

        # Day of the Week Analysis
        day_of_week_analysis_label = QLabel("Day of the Week Analysis:")
        day_of_week_analysis_label.setFont(font_bold)
        day_of_week_analysis_widget = self.createStatWidget("Day of the Week Analysis", "")
        for i, (weekday, count) in enumerate(day_of_week_analysis.items(), start=1):
            weekday_label = QLabel(f"{['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'][weekday]}: {count} notes")
            weekday_label.setFont(font)
            weekday_widget = QWidget()
            weekday_layout = QVBoxLayout(weekday_widget)
            weekday_layout.addWidget(weekday_label)
            day_of_week_analysis_widget.layout().addWidget(weekday_widget)
        self.statsLayout.addWidget(day_of_week_analysis_widget)

        # Note Length
        average_note_length_label = QLabel(f"Average Note Length: {average_note_length:.2f}")
        average_note_length_label.setFont(font)
        shortest_note_length_label = QLabel(f"Shortest Note Length: {shortest_note_length}")
        shortest_note_length_label.setFont(font)
        longest_note_length_label = QLabel(f"Longest Note Length: {longest_note_length}")
        longest_note_length_label.setFont(font)
        today_average_note_length_label = QLabel(f"Today's Average Note Length: {today_average_note_length:.2f}")
        today_average_note_length_label.setFont(font)

        note_length_widget = self.createStatWidget("Note Length", "")
        note_length_widget.layout().addWidget(average_note_length_label)
        note_length_widget.layout().addWidget(shortest_note_length_label)
        note_length_widget.layout().addWidget(longest_note_length_label)
        note_length_widget.layout().addWidget(today_average_note_length_label)
        self.statsLayout.addWidget(note_length_widget)

        layout.addWidget(scroll_area)
        self.statsTab.setLayout(layout)

    def createStatWidget(self, title, value):
        statWidget = QWidget()
        statLayout = QVBoxLayout(statWidget)
        statWidget.setStyleSheet("""
            QWidget {
                border: 1px solid #e0e0e0;
                border-radius: 6px;
                margin: 5px;
                padding: 10px;
            }
            QLabel {
                font-size: 14px;
            }
            .stat-header {
                font-weight: bold;
                margin-bottom: 5px;
            }
            .stat-content {
                white-space: pre-wrap;
                word-wrap: break-word;
                padding: 10px;
                border-radius: 4px;
            }
            .stat-separator {
                border: none;
                border-top: 1px solid #e0e0e0;
                margin: 10px 0;
            }
            QPushButton {
                padding: 5px;
                border-radius: 4px;
                border: 1px solid #ccc;
            }
        """)

        headerWidget = QWidget()
        headerLayout = QHBoxLayout(headerWidget)
        headerLayout.setContentsMargins(0, 0, 0, 0)
        headerLayout.setSpacing(5)

        toggleButton = QPushButton("▼")
        toggleButton.setFixedSize(30, 30)
        toggleButton.clicked.connect(lambda: self.toggleStatContent(statWidget))

        titleLabel = QLabel(title)
        titleLabel.setObjectName("stat-header")

        headerLayout.addWidget(toggleButton)
        headerLayout.addWidget(titleLabel)
        headerLayout.addStretch()

        contentLabel = QLabel(str(value))
        contentLabel.setObjectName("stat-content")
        contentLabel.setWordWrap(True)

        statLayout.addWidget(headerWidget)
        statLayout.addWidget(contentLabel)

        separator = QFrame()
        separator.setObjectName("stat-separator")
        statLayout.addWidget(separator)

        return statWidget
    
    def toggleStatContent(self, statWidget):
        contentLabel = statWidget.findChild(QLabel, "stat-content")
        toggleButton = statWidget.findChild(QPushButton)

        if contentLabel.isVisible():
            contentLabel.setVisible(False)
            toggleButton.setText("▶")
        else:
            contentLabel.setVisible(True)
            toggleButton.setText("▼")

    def collapseExpandAllStats(self):
        button = self.sender()
        if button.text() == "Collapse All":
            self.setStatContentVisibility(False)
            button.setText("Expand All")
        else:
            self.setStatContentVisibility(True)
            button.setText("Collapse All")

    def setStatContentVisibility(self, visible):
        for statWidget in self.statsLayout.parentWidget().findChildren(QWidget):
            contentLabel = statWidget.findChild(QLabel, "stat-content")
            toggleButton = statWidget.findChild(QPushButton)
            if contentLabel:
                contentLabel.setVisible(visible)
                toggleButton.setText("▼" if visible else "▶")

    def createFeedItem(self, content):
        if isinstance(content, list):
            widget = QWidget()
            layout = QVBoxLayout()
            for item in content:
                layout.addWidget(item)
            widget.setLayout(layout)
        else:
            widget = QWidget()
            layout = QVBoxLayout()
            layout.addWidget(content)
            widget.setLayout(layout)

        widget.setStyleSheet("""
            QWidget {
                background-color: #0f0f0f;
                border-radius: 8px;
                padding: 10px;
                margin-bottom: 10px;
            }
            QLabel {
                font-size: 14px;
            }
            QLabel[font="bold"] {
                font-weight: bold;
            }
        """)
        return widget

    def most_common_line(self, data):
        lines = [note[3] for note in data]
        return Counter(lines).most_common(1)[0] if lines else ("None", 0)

    def most_active_day(self, data):
        dates = [note[0] for note in data]
        return Counter(dates).most_common(1)[0] if dates else ("None", 0)

    def most_active_week(self, data, week_start, today):
        dates = [note[0] for note in data if week_start <= datetime.strptime(note[0], "%Y-%m-%d").date() <= today]
        return Counter(dates).most_common(1)[0] if dates else ("None", 0)

    def most_active_month(self, data, month_start, today):
        dates = [note[0] for note in data if month_start <= datetime.strptime(note[0], "%Y-%m-%d").date() <= today]
        return Counter(dates).most_common(1)[0] if dates else ("None", 0)

    def day_of_week_analysis(self, data):
        weekdays = [datetime.strptime(note[0], "%Y-%m-%d").weekday() for note in data if note[0]]
        return dict(sorted(Counter(weekdays).items()))

    def average_note_length(self, data):
        lengths = [len(note[3]) for note in data]
        return sum(lengths) / len(lengths) if lengths else 0
    
    def getStatsData(self):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("SELECT date, content FROM file_log")
            data = cursor.fetchall()

            # Implement logic to calculate statistics from the data
            total_notes = len(data)
            today = datetime.now().strftime("%Y-%m-%d")
            notes_today = sum(1 for date, _ in data if date == today)
            common_lines = Counter(content for _, content in data).most_common(5)
            common_lines_formatted = '\n'.join(f"{line} - {count} times" for line, count in common_lines)

            stats = {
                "Total Notes": total_notes,
                "Notes Today": notes_today,
                "Most Common Lines": common_lines_formatted,  # Now a single string
                # Add additional statistics here
            }
            return stats
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while calculating stats: {str(e)}")
            return {}
    
    def getNotesData(self):
        # Data list initialization
        data_list = []
    
        # Attempt to connect to the database and fetch data
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("SELECT date, time, filename, content FROM file_log ORDER BY date DESC, time DESC")
            rows = cursor.fetchall()
        
            # Loop through each row and create a dictionary of note data
            for row in rows:
                note_data = {
                    'date': row[0],
                    'time': row[1],
                    'filename': row[2],
                    'content': row[3]
                }
                data_list.append(note_data)
            
        except Exception as e:
            # Error handling
            QMessageBox.critical(self, "Database Error", f"An error occurred while fetching notes data: {str(e)}")
        
        return data_list

    def loadNotesData(self, tableWidget):
        # Connect to the database and query for the notes
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("SELECT date, time, filename, content FROM file_log")
            data = cursor.fetchall()
        
            tableWidget.setRowCount(len(data))
            for row_index, row_data in enumerate(data):
                for column_index, cell_data in enumerate(row_data):
                    tableWidget.setItem(row_index, column_index, QTableWidgetItem(str(cell_data)))

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load data from database: {str(e)}")

    def sortNotes(self, key, widget):
        self.currentSortKey = key  # Update the current sort key
        self.sortDescending = not self.sortDescending  # Toggle the sort order each time it's called

        if widget is self.tableView:
            # Sort the table view
            column_map = {"Date": 0, "Time": 1, "Filename": 2, "Content": 3}
            column = column_map.get(key, 0)
            self.tableView.sortItems(column, Qt.DescendingOrder if self.sortDescending else Qt.AscendingOrder)
        else:
            # Sort the styled view and update it
            sorted_notes = sorted(self.getNotesData(), key=lambda x: x[key.lower()], reverse=self.sortDescending)
            self.updateStyledView(sorted_notes)
            
class TutorialWindow(QDialog):
    def __init__(self, parent=None):
        super(TutorialWindow, self).__init__(parent)
        self.setWindowTitle("Interactive Tutorial")
        self.setGeometry(100, 100, 800, 600)
        self.setWindowModality(Qt.ApplicationModal)

        self.layout = QVBoxLayout()

        self.webView = QWebEngineView()
        self.layout.addWidget(self.webView)

        self.navigation_layout = QHBoxLayout()

        self.home_button = QPushButton("Home")
        self.home_button.clicked.connect(self.go_to_home_page)
        self.navigation_layout.addWidget(self.home_button)

        self.back_button = QPushButton("Previous")
        self.back_button.clicked.connect(self.go_to_previous_page)
        self.navigation_layout.addWidget(self.back_button)

        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.navigation_layout.addWidget(self.progress_bar)

        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.go_to_next_page)
        self.navigation_layout.addWidget(self.next_button)

        self.start_button = QPushButton("Start Using App")
        self.start_button.clicked.connect(self.close)
        self.navigation_layout.addWidget(self.start_button)

        self.layout.addLayout(self.navigation_layout)
        self.setLayout(self.layout)

        self.current_page_index = 0
        self.page_history = [self.current_page_index]
        self.tutorial_pages = [
            self.create_index_page(),
            self.create_welcome_page(),
            self.create_main_window_page(),
            self.create_system_tray_icon_page(),
            self.create_productivity_widget_page(),
            self.create_additional_notes_page(),
            self.create_datetime_display_page(),
            self.create_calculator_page(),
            self.create_file_folder_viewer_page(),
            self.create_games_page(),
            self.create_todo_list_page(),
            self.create_special_features_widget_page(),
            self.create_webhook_integration_page(),
            self.create_database_viewer_page(),
            self.create_ai_chat_page(),
            self.create_launcher_widget_page(),
            self.create_screen_tool_page(),
            self.create_file_sorter_page(),
            self.create_utility_tools_page(),
            self.create_duplicate_remover_page(),
            self.create_user_scanner_page(),
            self.create_shortcuts_page(),
            self.create_theme_page(),
            self.create_about_page(),
        ]

        self.load_tutorial_page(self.current_page_index)

        self.channel = QWebChannel()
        self.webView.page().setWebChannel(self.channel)
        self.channel.registerObject("qt", self)

    @pyqtSlot()
    def on_load_finished(self):
        self.webView.page().runJavaScript("""
            new QWebChannel(qt.webChannelTransport, function(channel) {
                window.tutorial = channel.objects.qt;
            });
        """)

    @pyqtSlot(int)
    def jupyterloadPage(self, index):
        try:
            self.load_tutorial_page(index)
        except Exception as e:
            self.log_error(f"Error loading tutorial page {index}: " + str(e))

    def load_tutorial_page(self, index):
        try:
            self.log_debug(f"Loading tutorial page {index}")
            self.current_page_index = index
            self.webView.setHtml(self.tutorial_pages[index])
            self.progress_bar.setValue(int((index + 1) / len(self.tutorial_pages) * 100))
        except Exception as e:
            self.log_error(f"Error loading tutorial page {index}: " + str(e))

    def go_to_home_page(self):
        try:
            self.load_tutorial_page(0)
            self.page_history = [0]
        except Exception as e:
            self.log_error("Error navigating to home page: " + str(e))

    def go_to_previous_page(self):
        try:
            if len(self.page_history) > 1:
                self.page_history.pop()  # Remove current page from history
                previous_page = self.page_history.pop()  # Get previous page
                self.load_tutorial_page(previous_page)
                self.page_history.append(previous_page)  # Re-add previous page
        except Exception as e:
            self.log_error("Error navigating to previous page: " + str(e))

    def go_to_next_page(self):
        try:
            if self.current_page_index < len(self.tutorial_pages) - 1:
                next_page = self.current_page_index + 1
                self.load_tutorial_page(next_page)
                self.page_history.append(next_page)
        except Exception as e:
            self.log_error("Error navigating to next page: " + str(e))

    def next_page(self):
        logging.debug("Next button clicked.")
        try:
            # Implement the logic for the next page
            logging.debug("Next page logic executed.")
        except Exception as e:
            logging.error(f"Error in next page logic: {e}")
            raise

    def log_error(self, message):
        if debug_mode:
            print("ERROR: " + message)

    def log_debug(self, message):
        if debug_mode:
            print("DEBUG: " + message)

    def create_index_page(self):
        try:
            return """
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; }
                    h1 { color: #333; }
                    p { font-size: 14px; }
                    .button-container {
                        display: flex;
                        flex-direction: column;
                        align-items: flex-start;
                    }
                    .tutorial-button {
                        margin: 5px 0;
                        padding: 10px;
                        background-color: #007BFF;
                        color: white;
                        border: none;
                        cursor: pointer;
                        width: 100%;
                        text-align: left;
                        box-sizing: border-box;
                    }
                    .tutorial-button:hover {
                        background-color: #0056b3;
                    }
                </style>
                <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
                <script>
                    document.addEventListener("DOMContentLoaded", function() {
                        new QWebChannel(qt.webChannelTransport, function(channel) {
                            window.tutorial = {
                                loadPage: function(index) {
                                    channel.objects.qt.jupyterloadPage(index);
                                }
                            };
                        });
                    });
                </script>
            </head>
            <body>
                <h1>OmniOmega Interactive Tutorial</h1>
                <p>Welcome to the OmniOmega Interactive Tutorial! Click on any of the sections below to learn more about specific features.</p>
                <div class="button-container">
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(1)">Welcome</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(2)">Main Window</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(3)">System Tray Icon</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(4)">Productivity Widget</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(5)">Additional Notes</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(6)">Date/Time Display</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(7)">Calculator</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(8)">File/Folder Viewer</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(9)">Games</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(10)">To-Do List</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(11)">Special Features Widget</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(12)">Webhook Integration</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(13)">Database Viewer</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(14)">AI Chat</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(15)">Launcher Widget</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(16)">Screen Tool</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(17)">File Sorter</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(18)">Utility Tools</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(19)">Duplicate Remover</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(20)">User Scanner</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(21)">Keyboard Shortcuts</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(22)">Themes</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(23)">About TSTP, LLC</button>
                </div>
            </body>
            </html>
            """
        except Exception as e:
            self.log_error("Error creating index page: " + str(e))
            return ""

    def create_welcome_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h1>Welcome to the OmniOmega Interactive Tutorial</h1>
            <p>In this tutorial, you will learn how to use the key features of the OmniOmega application.</p>
            <p>Let's get started!</p>
        </body>
        </html>
        """

    def create_main_window_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Main Window Overview</h2>
            <p>The Main Window is your central hub for managing notes and performing text editing tasks. Here, you can select note types, categories, and specific notes through dropdown menus. The main text area allows for rich text editing with options for formatting, adding timestamps, and organizing notes with tags and notebooks. You can perform actions such as adding, saving, clearing, and refreshing notes, as well as searching through existing notes for quick retrieval.</p>
            
            <h3>Note Type Dropdown</h3>
            <p>Select different types of notes (e.g., Simple Notes, Default Notes, Specific Notes). This filters the available notes accordingly, helping in organizing and managing different kinds of notes efficiently.</p>

            <h3>Category Dropdown</h3>
            <p>Displays categories of notes when Simple Notes are selected. Select a category to filter the notes displayed in the notes dropdown, enhancing note organization by categorizing them into specific groups.</p>

            <h3>Notes Dropdown</h3>
            <p>Lists specific notes based on the selected note type and category. Select a specific note to load its content into the text area, allowing quick access to individual notes for viewing and editing.</p>

            <h3>Text Area</h3>
            <p>A rich text editor where you can write, edit, and format your notes. Type or paste text, apply formatting (bold, italic, font size), and organize content. This provides a flexible and powerful editing environment for creating detailed and well-formatted notes.</p>

            <h3>Toggle Button</h3>
            <p>Toggles between different modes for notes (e.g., append mode). Switch modes to control how new notes are added to the text area, increasing flexibility in how notes are managed and edited.</p>

            <h3>Add Button</h3>
            <p>Add a new note to the text area. Click this button to insert the content of the selected note into the text area, simplifying the process of adding notes.</p>

            <h3>Save Button</h3>
            <p>Save the current note. Click this button to save the edited note, ensuring that changes made to notes are preserved.</p>

            <h3>Clear Button</h3>
            <p>Clear the text area. Click this button to remove all content from the text area, providing a quick way to start fresh or discard unwanted text.</p>

            <h3>Refresh Button</h3>
            <p>Refresh the list of notes. Click this button to reload the notes based on the current selections, ensuring that the latest notes are displayed.</p>

            <h3>Search Bar</h3>
            <p>Allows you to search through notes. Type a keyword or phrase to filter the notes displayed in the dropdowns, enhancing note retrieval by enabling quick searches.</p>

            <h3>Formatting Options</h3>
            <p>Includes options such as font selection, font size adjustment, bold, and italic formatting. Provides customization options for text appearance, allowing you to create detailed and well-formatted notes.</p>

            <h3>Tags Option</h3>
            <p>Enter tags associated with the note. Type tags separated by commas to categorize the note, facilitating better organization and searchability of notes through tagging.</p>

            <h3>Notebooks Dropdown</h3>
            <p>Select a notebook to categorize notes. Choose a notebook from the list to organize your notes, providing a higher level of organization for managing multiple notes within different notebooks.</p>

            <h3>Timestamp Button</h3>
            <p>Add a timestamp to the note. Click this button to insert the current date and time into the text area, helping in tracking when notes were created or modified.</p>
        </body>
        </html>
        """

    def create_system_tray_icon_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>System Tray Icon Overview</h2>
            <p>The System Tray Icon provides quick access to essential features of the OmniOmega application without the need to keep the main window open. It includes the following functionalities:</p>
            
            <h3>Actions</h3>
            <ul>
                <li><b>Always On Top:</b> Keeps the OmniOmega window on top of other applications. Enable this option to ensure the window remains visible, helping in multitasking.</li>
                <li><b>Close to Tray:</b> Minimizes the application to the system tray instead of closing it. Enable this option to keep the application running in the background, saving screen space while keeping the application readily accessible.</li>
            </ul>

            <h3>OmniOmega Submenu</h3>
            <ul>
                <li><b>Clock In/Out:</b> Logs time entries for tracking work hours. Click to clock in or out, helping in productivity monitoring.</li>
                <li><b>Reports:</b> Opens the report window. Access this to view and generate reports, providing insights into productivity and usage patterns.</li>
                <li><b>Settings:</b> Opens the settings window. Adjust application settings, allowing customization of application behavior and appearance.</li>
                <li><b>About:</b> Displays information about the application. Access this to learn more about OmniOmega, providing details about the application’s purpose and developers.</li>
                <li><b>Donate:</b> Opens the donation page. Click to support the developers, encouraging user support for ongoing development.</li>
            </ul>

            <h3>Themes Submenu</h3>
            <p>Allows you to switch between different visual themes. Select a theme from the list, enhancing the user experience by providing customization options for the application’s appearance.</p>

            <h3>Screen Tool Submenu</h3>
            <ul>
                <li><b>Capture Screenshot:</b> Takes a quick screenshot. Click to capture the current screen, facilitating quick and easy screen captures for documentation or sharing.</li>
                <li><b>Delayed Capture Screenshot:</b> Takes a screenshot after a delay. Click to capture the screen after a specified time, providing flexibility in capturing timed screenshots.</li>
                <li><b>Snip:</b> Allows snipping of a specific area of the screen. Click to snip and capture a portion of the screen, enabling precise screen captures.</li>
                <li><b>Capture Section:</b> Captures a specific section of the screen. Click to select and capture a screen section, facilitating targeted screen captures.</li>
                <li><b>Record Screen:</b> Records screen activities. Click to start recording your screen, useful for creating tutorials and documenting processes.</li>
                <li><b>Create GIF:</b> Creates a GIF from a series of screenshots. Click to start creating a GIF, providing a way to create animated visuals for documentation or sharing.</li>
                <li><b>Select Window:</b> Captures a specific window. Click to select and capture a window, allowing focused captures of application windows.</li>
                <li><b>Settings:</b> Opens the screen tool settings. Adjust settings related to screen captures and recordings, providing customization options for screen management.</li>
                <li><b>About:</b> Displays information about the screen tool. Access this to learn more about the tool, providing details about the tool’s capabilities.</li>
                <li><b>Donate:</b> Opens the donation page. Click to support the developers, encouraging user support for ongoing development.</li>
            </ul>
        </body>
        </html>
        """

    def create_productivity_widget_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Productivity Widget Overview</h2>
            <p>The Productivity Widget enhances user productivity by offering a suite of tools:</p>
            
            <h3>Additional Notes</h3>
            <p>Provides a section for managing extra notes. You can add, edit, and organize additional notes separately from the main text area, helping in organizing supplementary information without cluttering the primary workspace.</p>

            <h3>Date/Time Display</h3>
            <p>Shows the current date and time. View the current date and time at a glance, providing quick access to date and time information, aiding in time management.</p>

            <h3>Calculator</h3>
            <p>A basic calculator for performing calculations. Perform arithmetic operations directly within the application, eliminating the need to switch to a separate calculator app, enhancing workflow efficiency.</p>

            <h3>File/Folder Viewer</h3>
            <p>Allows you to browse and manage files and folders. View, open, and organize files and folders, providing a built-in file management tool, streamlining file organization.</p>

            <h3>Games</h3>
            <p>Provides access to integrated games. Play games for entertainment and breaks, offering a way to relax and take breaks, improving overall productivity and well-being.</p>

            <h3>To-Do List</h3>
            <p>Manages tasks and to-dos. Add, edit, and track tasks, helping in organizing and prioritizing tasks, improving task management and productivity.</p>
        </body>
        </html>
        """

    def create_additional_notes_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Additional Notes Overview</h2>
            <p>The Additional Notes section within the Productivity Widget allows you to manage supplementary notes that are separate from the main text area:</p>
            
            <h3>Manage Supplementary Notes</h3>
            <p>Add, edit, and organize additional notes. This section helps you organize extra information without cluttering the primary workspace, enhancing overall productivity.</p>
        </body>
        </html>
        """

    def create_datetime_display_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Date/Time Display Overview</h2>
            <p>The Date/Time Display within the Productivity Widget shows the current date and time:</p>
            
            <h3>View Date and Time</h3>
            <p>Provides quick access to the current date and time, aiding in time management and scheduling tasks effectively.</p>
        </body>
        </html>
        """

    def create_calculator_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Calculator Overview</h2>
            <p>The Calculator within the Productivity Widget allows you to perform basic arithmetic calculations:</p>
            
            <h3>Perform Calculations</h3>
            <p>Use the calculator to perform arithmetic operations directly within the application, enhancing workflow efficiency by eliminating the need to switch to a separate calculator app.</p>
        </body>
        </html>
        """

    def create_file_folder_viewer_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>File/Folder Viewer Overview</h2>
            <p>The File/Folder Viewer within the Productivity Widget allows you to browse and manage files and folders:</p>
            
            <h3>Browse and Manage Files/Folders</h3>
            <p>View, open, and organize files and folders directly within the application. This tool provides a built-in file management solution, streamlining file organization and access.</p>
        </body>
        </html>
        """

    def create_games_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { margin-left: 20px; }
            </style>
        </head>
        <body>
            <h2>Games Overview</h2>
            <p>The Games section within the Productivity Widget provides access to integrated games for entertainment and breaks. These games are designed to help you unwind and recharge, improving your overall productivity and well-being.</p>
        
            <h3>Available Games</h3>
            <ul>
                <li><strong>Tic-Tac-Toe:</strong> A classic two-player game with AI integration for different difficulty levels. Features include score tracking, undo move, game statistics, and a pop-out window option.</li>
                <li><strong>Tetris:</strong> A timeless puzzle game where you arrange falling blocks to clear lines. Includes score tracking, game pausing, pop-out window option, and an interactive tutorial.</li>
                <li><strong>Breakout:</strong> A game where you control a paddle to break bricks with a ball. Features include multiple levels, score tracking, lives system, increasing difficulty, and a pop-out window option.</li>
            </ul>
        
            <h3>Tic-Tac-Toe Details</h3>
            <p>Engage in a classic Tic-Tac-Toe game against the AI. Adjust the difficulty from easy to hard and keep track of your wins, losses, and ties. Features include:</p>
            <ul>
                <li>Adjustable AI difficulty</li>
                <li>Player and AI score tracking</li>
                <li>Undo move functionality</li>
                <li>Game statistics display</li>
                <li>Pop-out window for a larger game view</li>
            </ul>
        
            <h3>Tetris Details</h3>
            <p>Play Tetris by arranging falling blocks to clear lines. The game increases in speed and difficulty as you progress. Features include:</p>
            <ul>
                <li>Score tracking</li>
                <li>Game pausing and resuming</li>
                <li>Pop-out window for full-screen gameplay</li>
                <li>Interactive tutorial for new players</li>
            </ul>
        
            <h3>Breakout Details</h3>
            <p>Control a paddle to break bricks with a ball in this classic game. As you advance through levels, the game becomes more challenging. Features include:</p>
            <ul>
                <li>Score tracking</li>
                <li>Lives system to keep you in the game</li>
                <li>Multiple levels with increasing difficulty</li>
                <li>Pop-out window for an immersive experience</li>
            </ul>
        
            <p>Explore these games and more within the Productivity Widget. Enjoy your breaks and come back to work refreshed and ready to tackle new challenges!</p>
        </body>
        </html>
        """

    def create_todo_list_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>To-Do List Overview</h2>
            <p>The To-Do List within the Productivity Widget helps you manage tasks and to-dos:</p>
            
            <h3>Manage Tasks and To-Dos</h3>
            <p>Add, edit, and track tasks. This tool helps in organizing and prioritizing tasks, improving task management and productivity.</p>
        </body>
        </html>
        """

    def create_special_features_widget_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Special Features Widget Overview</h2>
            <p>The Special Features Widget includes advanced tools and functionalities:</p>
            
            <h3>Webhook Integration</h3>
            <p>Integrates with webhooks for real-time updates. Set up webhooks to receive real-time notifications and updates, providing real-time data integration, enhancing responsiveness and automation.</p>

            <h3>Database Viewer</h3>
            <p>Allows viewing and managing database entries. Access and manipulate database records directly within the application, simplifying database management, making it more accessible and efficient.</p>

            <h3>AI Chat</h3>
            <p>Provides an AI-powered chat interface using models like OpenAI's GPT-3.5 and GPT-4, Claude, Google Gemini, and Inflection Pi. Interact with the AI for assistance, information, and conversations, enhancing user interaction with intelligent responses and assistance, making the application more versatile and user-friendly.</p>

            <h3>Cloud Integration (Placeholder)</h3>
            <p>Placeholder for future cloud integration features. Indicates upcoming enhancements for cloud-based features.</p>

            <h3>Email Sharing (Placeholder)</h3>
            <p>Placeholder for future email sharing features. Indicates upcoming enhancements for email-based sharing.</p>
        </body>
        </html>
        """

    def create_webhook_integration_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Webhook Integration Overview</h2>
            <p>The Webhook Integration within the Special Features Widget allows you to set up webhooks for real-time updates and notifications:</p>
            
            <h3>Setup Webhooks</h3>
            <p>Configure webhooks to receive real-time notifications and updates. This feature provides real-time data integration, enhancing responsiveness and automation by allowing external systems to push data into OmniOmega.</p>
        </body>
        </html>
        """

    def create_database_viewer_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; background-color: #f9f9f9; margin: 0; padding: 20px; color: #333; }
                h2 { color: #2c3e50; }
                p { font-size: 16px; line-height: 1.6; }
                h3 { color: #3498db; }
                ul { list-style-type: none; padding: 0; }
                li { margin-bottom: 10px; }
                code { background-color: #e8e8e8; padding: 2px 4px; border-radius: 4px; }
            </style>
        </head>
        <body>
            <h2>Database Viewer Overview</h2>
            <p>The Database Viewer within the Special Features Widget provides a user-friendly interface for viewing and managing database entries.</p>
        
            <h3>Features</h3>
            <ul>
                <li><b>Query Execution:</b> Execute SQL queries directly within the application. Enter your query in the provided text area and view the results below.</li>
                <li><b>Database Connection:</b> Connect to various types of databases including SQLite, MySQL, PostgreSQL, and database files. Configure connection settings such as host, port, database name, username, and password.</li>
                <li><b>Table Management:</b> View, add, edit, and delete database entries. Select a table to display its data and perform CRUD (Create, Read, Update, Delete) operations.</li>
            </ul>
        
            <h3>Using the Database Viewer</h3>
            <p>To use the Database Viewer, follow these steps:</p>
            <ol>
                <li><b>Connect to a Database:</b> 
                    <ol>
                        <li>Select the database type from the dropdown menu.</li>
                        <li>Fill in the required connection details such as host, port, database name, username, and password.</li>
                        <li>If you are using a database file, browse and select the file.</li>
                        <li>Click the "Connect" button to establish a connection.</li>
                    </ol>
                </li>
                <li><b>Execute a Query:</b>
                    <ol>
                        <li>Navigate to the "Query" tab.</li>
                        <li>Enter your SQL query in the text area.</li>
                        <li>Click the "Execute Query" button to run the query and view the results in the table below.</li>
                    </ol>
                </li>
                <li><b>Manage Table Data:</b>
                    <ol>
                        <li>Navigate to the "Database Viewer" tab.</li>
                        <li>Select a table from the dropdown menu to view its data.</li>
                        <li>Use the "Create," "Update," and "Delete" buttons to manage the table entries.</li>
                    </ol>
                </li>
            </ol>
        
            <h3>Database Connection Settings</h3>
            <p>The Database Viewer supports different types of databases:</p>
            <ul>
                <li><b>SQLite:</b> Requires a database file.</li>
                <li><b>MySQL:</b> Requires host, port, database name, username, and password.</li>
                <li><b>PostgreSQL:</b> Requires host, port, database name, username, and password.</li>
                <li><b>File:</b> Requires a database file.</li>
            </ul>

            <h3>Query Execution</h3>
            <p>Enter your SQL query in the text area and click "Execute Query" to run the query. The results will be displayed in the table below. This feature allows you to perform various SQL operations such as SELECT, INSERT, UPDATE, and DELETE directly within the application.</p>

            <h3>Table Management</h3>
            <p>After connecting to a database, you can manage the table data:</p>
            <ul>
                <li><b>View Table Data:</b> Select a table from the dropdown menu to view its data in a tabular format.</li>
                <li><b>Create Record:</b> Click the "Create" button to add a new record to the selected table. Fill in the required fields and save the record.</li>
                <li><b>Update Record:</b> Select a record from the table and click the "Update" button to edit the record. Make the necessary changes and save the record.</li>
                <li><b>Delete Record:</b> Select a record from the table and click the "Delete" button to remove the record from the database.</li>
            </ul>
        
            <h3>Connecting to a Database File</h3>
            <p>If you select "File" as the database type, you will need to browse and select the database file. Once the file is selected, click "Connect" to establish the connection and start managing your database entries.</p>

        </body>
        </html>
        """

    def create_ai_chat_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { margin-left: 20px; }
                .section { margin-bottom: 20px; }
            </style>
        </head>
        <body>
            <h2>AI Chat Overview</h2>
            <div class="section">
                <h3>Introduction</h3>
                <p>The AI Chat functionality integrates advanced AI models such as OpenAI's GPT-3.5 and GPT-4, Claude, Google Gemini, and Inflection Pi. This feature allows users to interact with state-of-the-art AI for various purposes, including information retrieval, task automation, and more.</p>
            </div>
        
            <div class="section">
                <h3>Key Features</h3>
                <ul>
                    <li><strong>Intelligent Interaction:</strong> Provides smart and interactive responses, making it a significant selling point for the application. Assist with various tasks, provide information, and engage in meaningful conversations, enhancing user interaction with the software.</li>
                    <li><strong>Support for Multiple AI Models:</strong> Users can choose from various AI models, including GPT-3.5, GPT-4, Claude, Google Gemini, and Inflection Pi, allowing flexibility and access to different capabilities.</li>
                    <li><strong>API Key Management:</strong> Save, delete, and switch between different API keys directly within the application for ease of use and security.</li>
                    <li><strong>Token Usage Tracking:</strong> Monitor the number of tokens used during interactions to keep track of usage and costs.</li>
                    <li><strong>Image Generation:</strong> Use models like DALL-E to generate images from textual descriptions, expanding the possibilities of AI interaction.</li>
                </ul>
            </div>

            <div class="section">
                <h3>Using AI Chat</h3>
                <p>To use the AI Chat, follow these steps:</p>
                <ul>
                    <li><strong>Select API Type:</strong> Choose the desired API type from the dropdown menu (e.g., OpenAI, Claude, Google Gemini, Inflection Pi).</li>
                    <li><strong>Choose a Model:</strong> Select an AI model that you want to interact with from the available options.</li>
                    <li><strong>Enter API Key:</strong> Enter your API key in the provided field. You can save and manage multiple API keys for different services.</li>
                    <li><strong>Type Your Query:</strong> In the chat input area, type your query or command.</li>
                    <li><strong>Send the Query:</strong> Click the "Send" button or press Enter to send your query to the AI model. The AI will process your input and provide a relevant response.</li>
                </ul>
            </div>

            <div class="section">
                <h3>Components</h3>
                <p>The AI Chat feature consists of the following components:</p>
                <ul>
                    <li><strong>Settings Area:</strong> Contains options for API key management, model selection, and token usage display. This area is collapsible for better user experience.</li>
                    <li><strong>Chat Area:</strong> Displays the conversation with the AI, including messages from both the user and the AI assistant. Messages are presented in a clear, readable format with support for text and images.</li>
                    <li><strong>Input Area:</strong> Where users type their queries. It includes a text input field and a send button for submitting queries to the AI.</li>
                    <li><strong>Typing Indicator:</strong> Displays when the AI assistant is generating a response, providing a more interactive experience.</li>
                </ul>
            </div>

            <div class="section">
                <h3>Error Handling</h3>
                <p>The AI Chat feature includes robust error handling to ensure smooth operation:</p>
                <ul>
                    <li>API key validation and management to prevent unauthorized access.</li>
                    <li>Connection error detection to handle network issues gracefully.</li>
                    <li>Response error handling to manage unexpected or malformed responses from the AI service.</li>
                </ul>
            </div>

            <div class="section">
                <h3>Benefits</h3>
                <p>The AI Chat feature enhances user experience by offering intelligent and responsive interaction. It can help with productivity by providing quick answers and performing tasks, making the application more versatile and user-friendly. Specific benefits include:</p>
                <ul>
                    <li>Increased efficiency in retrieving information and completing tasks.</li>
                    <li>Enhanced user engagement through interactive and meaningful conversations.</li>
                    <li>Flexible integration with multiple AI models to suit various needs.</li>
                    <li>Comprehensive token usage tracking to manage costs effectively.</li>
                </ul>
            </div>
        </body>
        </html>
        """

    def create_launcher_widget_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Launcher Widget Overview</h2>
            <p>The Launcher Widget is designed to streamline the user's workflow by providing quick access to frequently used tools and applications:</p>
            
            <h3>Quick Launch Access</h3>
            <p>Allows you to quickly launch essential tools and applications. Click on icons or links to open frequently used tools, saving time and enhancing efficiency by providing immediate access to important tools.</p>

            <h3>Usage</h3>
            <p>To use the Launcher Widget, simply click on the icon or link of the tool or application you wish to open. This feature eliminates the need to navigate through multiple menus or windows, improving workflow efficiency.</p>

            <h3>Benefits</h3>
            <p>The Launcher Widget helps streamline workflow by reducing the time and effort required to access essential tools and applications. This enhances productivity by providing quick and easy access to frequently used features.</p>
        </body>
        </html>
        """

    def create_screen_tool_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Screen Tool Overview</h2>
            <p>The Screen Tool offers a comprehensive set of screen management capabilities:</p>
            
            <h3>Capture Screenshot</h3>
            <p>Takes a quick screenshot. Click to capture the current screen, facilitating quick and easy screen captures for documentation or sharing.</p>

            <h3>Delayed Capture Screenshot</h3>
            <p>Takes a screenshot after a delay. Click to capture the screen after a specified time, providing flexibility in capturing timed screenshots.</p>

            <h3>Snip</h3>
            <p>Allows snipping of a specific area of the screen. Click to snip and capture a portion of the screen, enabling precise screen captures.</p>

            <h3>Capture Section</h3>
            <p>Captures a specific section of the screen. Click to select and capture a screen section, facilitating targeted screen captures.</p>

            <h3>Record Screen</h3>
            <p>Records screen activities. Click to start recording your screen, useful for creating tutorials and documenting processes.</p>

            <h3>Create GIF</h3>
            <p>Creates a GIF from a series of screenshots. Click to start creating a GIF, providing a way to create animated visuals for documentation or sharing.</p>

            <h3>Select Window</h3>
            <p>Captures a specific window. Click to select and capture a window, allowing focused captures of application windows.</p>

            <h3>Settings</h3>
            <p>Opens the screen tool settings. Adjust settings related to screen captures and recordings, providing customization options for screen management.</p>

            <h3>About</h3>
            <p>Displays information about the screen tool. Access this to learn more about the tool, providing details about the tool’s capabilities.</p>

            <h3>Donate</h3>
            <p>Opens the donation page. Click to support the developers, encouraging user support for ongoing development.</p>

            <h3>Usage</h3>
            <p>To use the Screen Tool, select the desired option from the menu (e.g., Capture Screenshot, Record Screen). Follow the on-screen instructions to capture or record the screen.</p>

            <h3>Benefits</h3>
            <p>The Screen Tool enhances productivity by providing comprehensive capabilities for screen capture and recording. This is useful for creating visual documentation, tutorials, and sharing screen activities.</p>
        </body>
        </html>
        """

    def create_file_sorter_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { margin-left: 20px; }
            </style>
        </head>
        <body>
            <h2>File Sorter Overview</h2>
            <p>The File Sorter automates the organization of files into predefined categories based on user-defined rules. This tool helps maintain an organized workspace by reducing clutter and enhancing file management efficiency.</p>
        
            <h3>Automated Sorting</h3>
            <p>Automatically sorts files into specific folders based on set rules. Define rules for sorting files, and the tool will automatically organize files accordingly. This improves efficiency by keeping files organized without manual intervention.</p>
        
            <h3>Usage</h3>
            <p>To use the File Sorter, define sorting rules within the application. The tool will then automatically sort files into the appropriate folders based on these rules.</p>
            <p>Follow these steps:</p>
            <ul>
                <li>Open the File Sorter application.</li>
                <li>Navigate to the 'Rules' tab to define or edit sorting rules.</li>
                <li>Set up the rules by specifying keywords, file types, sources, and destinations.</li>
                <li>Enable the sorting feature to let the application sort files as per the defined rules.</li>
            </ul>
        
            <h3>Key Features</h3>
            <ul>
                <li>Customizable sorting rules based on keywords, file types, and destinations.</li>
                <li>Real-time sorting with an option to run rules on demand.</li>
                <li>Detailed logs for tracking file movements and sorting activities.</li>
                <li>Import and export functionality for rules and logs.</li>
                <li>Integration with a system tray for quick access and control.</li>
            </ul>

            <h3>Benefits</h3>
            <p>The File Sorter helps maintain an organized workspace by automating the process of sorting files into appropriate categories. This reduces clutter and enhances file management efficiency, allowing you to focus on more important tasks.</p>
        </body>
        </html>
        """

    def create_utility_tools_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Utility Tools Overview</h2>
            <p>The Utility Tools section includes features such as a Duplicate Remover and User Scanner:</p>
            
            <h3>Duplicate Remover</h3>
            <p>Primarily focuses on identifying and eliminating duplicate text within files or general text. Helps maintain clean and concise documents, improving the quality of the text and saving space by reducing redundancy.</p>

            <h3>User Scanner</h3>
            <p>Scans and manages user data. Provides insights and helps maintain data integrity, ensuring that user data is organized and accurate.</p>
        </body>
        </html>
        """

    def create_duplicate_remover_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Duplicate Remover Overview</h2>
            <p>The Duplicate Remover is designed to identify and eliminate duplicate text within files or general text:</p>
            
            <h3>Identify and Eliminate Duplicates</h3>
            <p>The Duplicate Remover scans files or text for duplicate content and provides options to remove or consolidate these duplicates. This helps maintain clean and concise documents by reducing redundancy.</p>

            <h3>Usage</h3>
            <p>To use the Duplicate Remover, select the files or text you want to scan for duplicates. The tool will identify duplicate content and provide options for removal or consolidation.</p>

            <h3>Benefits</h3>
            <p>The Duplicate Remover improves document quality by eliminating redundant content, making documents more concise and saving storage space.</p>
        </body>
        </html>
        """

    def create_user_scanner_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>User Scanner Overview</h2>
            <p>The User Scanner is a tool designed to scan and manage user data:</p>
            
            <h3>Scan and Manage User Data</h3>
            <p>The User Scanner provides insights into user data, helping maintain data integrity by ensuring that user data is organized and accurate.</p>

            <h3>Usage</h3>
            <p>To use the User Scanner, initiate a scan of user data within the application. The tool will analyze the data and provide insights and options for managing it.</p>

            <h3>Benefits</h3>
            <p>The User Scanner helps ensure data integrity by organizing and verifying user data, making it easier to manage and analyze.</p>
        </body>
        </html>
        """

    def create_shortcuts_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Keyboard Shortcuts</h2>
            <p>Use these keyboard shortcuts to improve efficiency:</p>
            <ul>
                <li><b>Ctrl + S:</b> Save note.</li>
                <li><b>Ctrl + R:</b> Open report window.</li>
                <li><b>Ctrl + N:</b> New note.</li>
                <li><b>Ctrl + P:</b> Open settings.</li>
                <li><b>Ctrl + Z:</b> Undo.</li>
                <li><b>Ctrl + Y:</b> Redo.</li>
                <li><b>Ctrl + /:</b> Minimize window.</li>
                <li><b>Alt + 1:</b> Toggle productivity widget.</li>
                <li><b>Alt + 2:</b> Toggle launcher widget.</li>
                <li><b>Alt + 3:</b> Toggle special features widget.</li>
            </ul>
        </body>
        </html>
        """

    def create_theme_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Themes</h2>
            <p>Customize the appearance of OmniOmega with various themes:</p>
            <ul>
                <li><b>Select Theme:</b> Choose a theme from the menu.</li>
                <li><b>Next Theme:</b> Ctrl + = to switch to the next theme.</li>
                <li><b>Previous Theme:</b> Ctrl + - to switch to the previous theme.</li>
            </ul>
        </body>
        </html>
        """

    def create_about_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; background-color: #f9f9f9; margin: 0; padding: 20px; color: #333; }
                h2 { color: #2c3e50; }
                p { font-size: 16px; line-height: 1.6; }
                ul { list-style-type: none; padding: 0; }
                li { margin-bottom: 10px; }
                a { text-decoration: none; color: #3498db; }
                a:hover { text-decoration: underline; }
                .container { max-width: 800px; margin: 0 auto; padding: 20px; background: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.1); border-radius: 8px; }
            </style>
        </head>
        <body>
            <div class="container">
                <h2>About The Solutions To Problems, LLC</h2>
                <p>At <strong>The Solutions To Problems, LLC (TSTP)</strong>, we’re not just about developing software; we’re about creating solutions. Our foundation is built on the belief that the best innovations arise from addressing real, tangible problems. This philosophy has led us to develop a range of products that are as diverse as they are functional, each born from a need, a frustration, or a gap in existing technological offerings. Our mission is simple yet profound: to eliminate productivity issues across all aspects of computer usage, transforming challenges into opportunities for efficiency and ease.</p>
                <p>We believe in the power of technology to solve problems and improve lives. Our team is dedicated to listening to user feedback and continuously improving our products to meet your needs. Whether you’re an individual looking for a better way to manage your tasks or a business seeking to streamline operations, TSTP has a solution for you.</p>
                <p>Our product portfolio includes tools for note-taking, file organization, productivity enhancement, and much more. Each product is designed with the user in mind, ensuring intuitive interfaces and powerful functionalities that make your daily tasks easier and more efficient.</p>
                <p>Follow us on our social media to stay updated with our latest innovations and join our community:</p>
                <ul>
                    <li><a href="https://www.linkedin.com/company/thesolutions-toproblems/" target="_blank">LinkedIn</a></li>
                    <li><a href="https://www.facebook.com/profile.php?id=61557162643039" target="_blank">Facebook</a></li>
                    <li><a href="https://twitter.com/TSTP_LLC" target="_blank">Twitter</a></li>
                    <li><a href="https://www.youtube.com/@yourpststudios/" target="_blank">YouTube</a></li>
                    <li><a href="https://github.com/TSTP-Enterprises" target="_blank">GitHub</a></li>
                </ul>
            </div>
        </body>
        </html>
        """
            
class NotificationSettingsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Notification Settings")
        self.setModal(True)

        layout = QVBoxLayout(self)

        self.notification_settings = []

        self.table = QTableWidget(self)
        self.table.setColumnCount(5)
        self.table.setHorizontalHeaderLabels(["Notification Type", "Title", "Message", "Notification Methods", "Settings"])
        self.table.verticalHeader().setVisible(False)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        layout.addWidget(self.table)

        button_layout = QHBoxLayout()
        self.add_button = QPushButton("Add")
        self.add_button.clicked.connect(self.add_notification_setting)
        self.remove_button = QPushButton("Remove")
        self.remove_button.clicked.connect(self.remove_notification_setting)
        self.save_button = QPushButton("Save")
        self.save_button.clicked.connect(self.save_notification_settings)
        button_layout.addWidget(self.add_button)
        button_layout.addWidget(self.remove_button)
        button_layout.addWidget(self.save_button)
        layout.addLayout(button_layout)

        self.load_notification_settings()

    def add_notification_setting(self):
        try:
            row = self.table.rowCount()
            self.table.insertRow(row)
            self.table.setItem(row, 0, QTableWidgetItem())
            self.table.setItem(row, 1, QTableWidgetItem())
            self.table.setItem(row, 2, QTableWidgetItem())

            methods_combo = QComboBox()
            methods_combo.addItems(["Webhook", "Email", "System Tray", "Message Box", "API"])
            methods_combo.setEditable(True)
            self.table.setCellWidget(row, 3, methods_combo)

            settings_button = QPushButton("Settings")
            settings_button.clicked.connect(lambda: self.open_notification_method_settings(row))
            self.table.setCellWidget(row, 4, settings_button)
        except Exception as e:
            logging.error(f"Error adding notification setting: {e}")
            QMessageBox.critical(self, "Error", "An error occurred while adding a notification setting.")

    def open_notification_method_settings(self, row):
        try:
            notification_method = self.table.cellWidget(row, 3).currentText()
            if notification_method == "Webhook":
                self.open_webhook_settings(row)
            elif notification_method == "Email":
                self.open_email_settings(row)
            # Add more elif conditions for other notification methods
        except Exception as e:
            logging.error(f"Error opening notification method settings: {e}")
            QMessageBox.critical(self, "Error", "An error occurred while opening notification method settings.")

    def open_webhook_settings(self, row):
        try:
            webhook_dialog = QDialog(self)
            webhook_dialog.setWindowTitle("Webhook Settings")
            webhook_dialog.setModal(True)

            layout = QVBoxLayout(webhook_dialog)

            url_label = QLabel("Webhook URL:")
            url_input = QLineEdit()
            layout.addWidget(url_label)
            layout.addWidget(url_input)

            button_layout = QHBoxLayout()
            save_button = QPushButton("Save")
            save_button.clicked.connect(lambda: self.save_webhook_settings(row, url_input.text()))
            cancel_button = QPushButton("Cancel")
            cancel_button.clicked.connect(webhook_dialog.reject)
            button_layout.addWidget(save_button)
            button_layout.addWidget(cancel_button)
            layout.addLayout(button_layout)

            webhook_dialog.exec_()
        except Exception as e:
            logging.error(f"Error opening webhook settings: {e}")
            QMessageBox.critical(self, "Error", "An error occurred while opening webhook settings.")

    def save_webhook_settings(self, row, webhook_url):
        try:
            notification_type = self.table.item(row, 0).text()
            conn = sqlite3.connect('notifications.db')
            c = conn.cursor()
            c.execute("INSERT OR REPLACE INTO webhook_settings (notification_type, url) VALUES (?, ?)", (notification_type, webhook_url))
            conn.commit()
            conn.close()
        except sqlite3.Error as e:
            logging.error(f"Error saving webhook settings: {e}")
            QMessageBox.critical(self, "Error", "An error occurred while saving webhook settings.")

    def open_email_settings(self, row):
        try:
            email_dialog = QDialog(self)
            email_dialog.setWindowTitle("Email Settings")
            email_dialog.setModal(True)

            layout = QVBoxLayout(email_dialog)

            email_label = QLabel("Email Address:")
            email_input = QLineEdit()
            layout.addWidget(email_label)
            layout.addWidget(email_input)

            smtp_server_label = QLabel("SMTP Server:")
            smtp_server_input = QLineEdit()
            layout.addWidget(smtp_server_label)
            layout.addWidget(smtp_server_input)

            smtp_port_label = QLabel("SMTP Port:")
            smtp_port_input = QLineEdit()
            layout.addWidget(smtp_port_label)
            layout.addWidget(smtp_port_input)

            username_label = QLabel("Username:")
            username_input = QLineEdit()
            layout.addWidget(username_label)
            layout.addWidget(username_input)

            password_label = QLabel("Password:")
            password_input = QLineEdit()
            password_input.setEchoMode(QLineEdit.Password)
            layout.addWidget(password_label)
            layout.addWidget(password_input)

            button_layout = QHBoxLayout()
            save_button = QPushButton("Save")
            save_button.clicked.connect(lambda: self.save_email_settings(row, email_input.text(), smtp_server_input.text(),
                                                                         smtp_port_input.text(), username_input.text(),
                                                                         password_input.text()))
            cancel_button = QPushButton("Cancel")
            cancel_button.clicked.connect(email_dialog.reject)
            button_layout.addWidget(save_button)
            button_layout.addWidget(cancel_button)
            layout.addLayout(button_layout)

            email_dialog.exec_()
        except Exception as e:
            logging.error(f"Error opening email settings: {e}")
            QMessageBox.critical(self, "Error", "An error occurred while opening email settings.")

    def save_email_settings(self, row, email, smtp_server, smtp_port, username, password):
        try:
            notification_type = self.table.item(row, 0).text()
            conn = sqlite3.connect('notifications.db')
            c = conn.cursor()
            c.execute("INSERT OR REPLACE INTO email_settings (notification_type, email, smtp_server, smtp_port, username, password) VALUES (?, ?, ?, ?, ?, ?)",
                      (notification_type, email, smtp_server, smtp_port, username, password))
            conn.commit()
            conn.close()
        except sqlite3.Error as e:
            logging.error(f"Error saving email settings: {e}")
            QMessageBox.critical(self, "Error", "An error occurred while saving email settings.")

    def remove_notification_setting(self):
        try:
            selected_rows = self.table.selectionModel().selectedRows()
            for row in reversed(selected_rows):
                self.table.removeRow(row.row())
        except Exception as e:
            logging.error(f"Error removing notification setting: {e}")
            QMessageBox.critical(self, "Error", "An error occurred while removing a notification setting.")

    def save_notification_settings(self):
        try:
            self.notification_settings.clear()
            for row in range(self.table.rowCount()):
                notification_type = self.table.item(row, 0).text()
                title = self.table.item(row, 1).text()
                message = self.table.item(row, 2).text()
                notification_methods = self.table.cellWidget(row, 3).currentText().split(",")
                self.notification_settings.append((notification_type, title, message, notification_methods))
            self.accept()
        except Exception as e:
            logging.error(f"Error saving notification settings: {e}")
            QMessageBox.critical(self, "Error", "An error occurred while saving notification settings.")

    def load_notification_settings(self):
        try:
            conn = sqlite3.connect('notifications.db')
            c = conn.cursor()
            c.execute("SELECT * FROM notification_settings")
            self.notification_settings = c.fetchall()
            for notification_type, title, message, notification_methods in self.notification_settings:
                row = self.table.rowCount()
                self.table.insertRow(row)
                self.table.setItem(row, 0, QTableWidgetItem(notification_type))
                self.table.setItem(row, 1, QTableWidgetItem(title))
                self.table.setItem(row, 2, QTableWidgetItem(message))
                methods_combo = QComboBox()
                methods_combo.addItems(["Webhook", "Email", "System Tray", "Message Box", "API"])
                methods_combo.setEditable(True)
                methods_combo.setCurrentText(",".join(notification_methods))
                self.table.setCellWidget(row, 3, methods_combo)
                settings_button = QPushButton("Settings")
                settings_button.clicked.connect(lambda _, row=row: self.open_notification_method_settings(row))
                self.table.setCellWidget(row, 4, settings_button)
            conn.close()
        except sqlite3.Error as e:
            logging.error(f"Error loading notification settings: {e}")
            QMessageBox.critical(self, "Error", "An error occurred while loading notification settings.")
            
class NotificationManager:
   def __init__(self):
       self.webhook_conn = sqlite3.connect('webhooks.db')
       self.notification_conn = sqlite3.connect('notifications.db')
       self.create_notification_table()
       self.create_email_settings_table()
       self.create_notification_settings_table()
       self.create_notification_history_table()

   def log_error(self, message, notify=False):
       # Log the error to a file or console
       logging.error(message)
       # Optionally send a notification if required
       if notify:
           self.send_system_tray_notification("Error", message)

   def create_notification_table(self):
       try:
           c = self.notification_conn.cursor()
           c.execute("""
               CREATE TABLE IF NOT EXISTS notifications (
                   id INTEGER PRIMARY KEY AUTOINCREMENT,
                   notification_type TEXT,
                   title TEXT,
                   message TEXT,
                   timestamp TEXT
               )
           """)
           self.notification_conn.commit()
       except sqlite3.Error as e:
           logging.error(f"Error creating notifications table: {e}")

   def create_email_settings_table(self):
       try:
           c = self.notification_conn.cursor()
           c.execute("""
               CREATE TABLE IF NOT EXISTS email_settings (
                   id INTEGER PRIMARY KEY AUTOINCREMENT,
                   email TEXT,
                   subject TEXT,
                   body TEXT,
                   smtp_server TEXT,
                   smtp_port INTEGER,
                   smtp_username TEXT,
                   smtp_password TEXT
               )
           """)
           self.notification_conn.commit()
       except sqlite3.Error as e:
           logging.error(f"Error creating email settings table: {e}")

   def create_notification_settings_table(self):
       try:
           c = self.notification_conn.cursor()
           c.execute("""
               CREATE TABLE IF NOT EXISTS notification_settings (
                   id INTEGER PRIMARY KEY AUTOINCREMENT,
                   notification_type TEXT,
                   title TEXT,
                   message TEXT,
                   notification_methods TEXT
               )
           """)
           self.notification_conn.commit()
       except sqlite3.Error as e:
           logging.error(f"Error creating notification settings table: {e}")

   def create_notification_history_table(self):
       try:
           c = self.notification_conn.cursor()
           c.execute("""
               CREATE TABLE IF NOT EXISTS notification_history (
                   id INTEGER PRIMARY KEY AUTOINCREMENT,
                   notification_type TEXT,
                   title TEXT,
                   message TEXT,
                   timestamp TEXT,
                   source TEXT
               )
           """)
           self.notification_conn.commit()
       except sqlite3.Error as e:
           logging.error(f"Error creating notification history table: {e}")

   def send_webhook(self, event, message):
       try:
           c = self.webhook_conn.cursor()
           c.execute("SELECT url FROM webhooks WHERE event = ?", (event,))
           webhooks = c.fetchall()
           for webhook_url, in webhooks:
               data = {
                   "event": event,
                   "message": message
               }
               response = requests.post(webhook_url, json=data, timeout=10)
               if response.status_code not in [200, 202]:
                   logging.error(f"Failed to send webhook to {webhook_url}. Server responded with status code: {response.status_code}")
           self.save_notification("Webhook", event, message)
       except sqlite3.Error as e:
           logging.error(f"Error sending webhook: {e}")

   def send_email(self, to, subject, message):
       try:
           email_settings = self.get_email_settings()
           for email, email_subject, email_body, smtp_server, smtp_port, smtp_username, smtp_password in email_settings:
               msg = EmailMessage()
               msg["Subject"] = email_subject
               msg["From"] = email
               msg["To"] = to
               msg.set_content(email_body)
               with smtplib.SMTP(smtp_server, smtp_port) as smtp:
                   smtp.starttls()
                   smtp.login(smtp_username, smtp_password)
                   smtp.send_message(msg)
           self.save_notification("Email", subject, message)
       except Exception as e:
           logging.error(f"Error sending email: {e}")

   def send_system_tray_notification(self, title, message, icon=None):
       try:
           tray_icon = QSystemTrayIcon(QIcon(icon) if icon else QIcon(), self)
           tray_icon.setToolTip(title)
           tray_icon.showMessage(title, message, QSystemTrayIcon.Information, 5000)
           self.save_notification("System Tray", title, message)
       except Exception as e:
           logging.error(f"Error sending system tray notification: {e}")

   def send_message_box_notification(self, title, message, icon=QMessageBox.Information):
       try:
           if icon == QMessageBox.Information:
               QMessageBox.information(self, title, message)
           elif icon == QMessageBox.Warning:
               QMessageBox.warning(self, title, message)
           elif icon == QMessageBox.Critical:
               QMessageBox.critical(self, title, message)
           self.save_notification("Message Box", title, message)
       except Exception as e:
           logging.error(f"Error sending message box notification: {e}")

   def send_api_notification(self, notification_type, data):
       try:
           # Implement sending API notification
           self.save_notification(notification_type, "API Notification", str(data))
       except Exception as e:
           logging.error(f"Error sending API notification: {e}")

   def save_notification(self, notification_type, title, message, source=None):
       try:
           c = self.notification_conn.cursor()
           c.execute("INSERT INTO notifications (notification_type, title, message, timestamp) VALUES (?, ?, ?, ?)", (
               notification_type,
               title,
               message,
               datetime.now().strftime("%Y-%m-%d %H:%M:%S")
           ))
           self.notification_conn.commit()
           self.save_notification_history(notification_type, title, message, source)
       except sqlite3.Error as e:
           logging.error(f"Error saving notification: {e}")

   def save_notification_history(self, notification_type, title, message, source=None):
       try:
           c = self.notification_conn.cursor()
           c.execute("INSERT INTO notification_history (notification_type, title, message, timestamp, source) VALUES (?, ?, ?, ?, ?)", (
               notification_type,
               title,
               message,
               datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
               source
           ))
           self.notification_conn.commit()
       except sqlite3.Error as e:
           logging.error(f"Error saving notification history: {e}")

   def get_notifications(self):
       try:
           c = self.notification_conn.cursor()
           c.execute("SELECT * FROM notifications ORDER BY timestamp DESC")
           return c.fetchall()
       except sqlite3.Error as e:
           logging.error(f"Error retrieving notifications: {e}")
           return []

   def get_notification_history(self, notification_type=None, start_date=None, end_date=None, source=None):
       try:
           c = self.notification_conn.cursor()
           query = "SELECT * FROM notification_history"
           conditions = []
           if notification_type:
               conditions.append("notification_type = ?")
           if start_date:
               conditions.append("timestamp >= ?")
           if end_date:
               conditions.append("timestamp <= ?")
           if source:
               conditions.append("source = ?")
           if conditions:
               query += " WHERE " + " AND ".join(conditions)
           query += " ORDER BY timestamp DESC"
           params = [param for param in (notification_type, start_date, end_date, source) if param]
           c.execute(query, params)
           return c.fetchall()
       except sqlite3.Error as e:
           logging.error(f"Error retrieving notification history: {e}")
           return []

   def clear_notifications(self):
       try:
           c = self.notification_conn.cursor()
           c.execute("DELETE FROM notifications")
           self.notification_conn.commit()
       except sqlite3.Error as e:
           logging.error(f"Error clearing notifications: {e}")

   def get_email_settings(self):
       try:
           c = self.notification_conn.cursor()
           c.execute("SELECT email, subject, body, smtp_server, smtp_port, smtp_username, smtp_password FROM email_settings")
           return c.fetchall()
       except sqlite3.Error as e:
           logging.error(f"Error retrieving email settings: {e}")
           return []

   def save_email_settings(self, email_settings):
       try:
           c = self.notification_conn.cursor()
           c.execute("DELETE FROM email_settings")
           for email, subject, body, smtp_server, smtp_port, smtp_username, smtp_password in email_settings:
               c.execute("INSERT INTO email_settings (email, subject, body, smtp_server, smtp_port, smtp_username, smtp_password) VALUES (?, ?, ?, ?, ?, ?, ?)", (
                   email, subject, body, smtp_server, smtp_port, smtp_username, smtp_password
               ))
           self.notification_conn.commit()
       except sqlite3.Error as e:
           logging.error(f"Error saving email settings: {e}")

   def get_notification_settings(self):
       try:
           c = self.notification_conn.cursor()
           c.execute("SELECT * FROM notification_settings")
           return c.fetchall()
       except sqlite3.Error as e:
           logging.error(f"Error retrieving notification settings: {e}")
           return []

   def save_notification_settings(self, notification_settings):
       try:
           c = self.notification_conn.cursor()
           c.execute("DELETE FROM notification_settings")
           for notification_type, title, message, notification_methods in notification_settings:
               c.execute("INSERT INTO notification_settings (notification_type, title, message, notification_methods) VALUES (?, ?, ?, ?)", (
                   notification_type, title, message, ",".join(notification_methods)
               ))
           self.notification_conn.commit()
       except sqlite3.Error as e:
           logging.error(f"Error saving notification settings: {e}")

   def open_notification_settings_dialog(self, parent=None):
       dialog = NotificationSettingsDialog(parent)
       if dialog.exec_() == QDialog.Accepted:
           self.save_notification_settings(dialog.notification_settings)

   def send_custom_notification(self, notification_type, title, message, notification_methods, source=None):
       try:
           for method in notification_methods:
               if method == "Webhook":
                   self.send_webhook(notification_type, message)
               elif method == "Email":
                   self.send_email("user@example.com", title, message)
               elif method == "System Tray":
                   self.send_system_tray_notification(title, message)
               elif method == "Message Box":
                   self.send_message_box_notification(title, message)
               elif method == "API":
                   self.send_api_notification(notification_type, {"title": title, "message": message})
           self.save_notification(notification_type, title, message, source)
       except Exception as e:
           logging.error(f"Error sending custom notification: {e}")

   def update_notification_routing(self, notification_type, notification_methods):
       try:
           c = self.notification_conn.cursor()
           c.execute("UPDATE notification_settings SET notification_methods = ? WHERE notification_type = ?", (
               ",".join(notification_methods), notification_type
           ))
           self.notification_conn.commit()
       except sqlite3.Error as e:
           logging.error(f"Error updating notification routing: {e}")

   def open_notification_manager(self):
       self.open_notification_settings_dialog()
       
class RecordDialog(QDialog):
    def __init__(self, parent, title, column_names, current_values=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setModal(True)

        layout = QVBoxLayout(self)
        self.input_fields = []

        for column_name in column_names:
            label = QLabel(column_name)
            input_field = QLineEdit()
            if current_values:
                input_field.setText(current_values[column_names.index(column_name)])
            layout.addWidget(label)
            layout.addWidget(input_field)
            self.input_fields.append(input_field)

        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

    def get_values(self):
        return [input_field.text() for input_field in self.input_fields]
### HELPER FUNCTION/WINDOWS END ###

### CUSTOM CONTROLS START ###
class EnterLineEdit(QLineEdit):
    def __init__(self, parent=None):
        super().__init__(parent)

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Return:
            self.parent().addNoteToTextArea(from_button=True)  # Pass True for from_button
            self.parent().searchBar.clear()
        super().keyPressEvent(event)
        
class EnterComboBox(QComboBox):
    def __init__(self, parent=None):
        super().__init__(parent)

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Return:
            self.parent().addNoteToTextArea(from_button=True)
        super().keyPressEvent(event)
        
class DraggableMenuBar(QMenuBar):
    def __init__(self, parent=None):
        super(DraggableMenuBar, self).__init__(parent)
        self.dragging = False
        self.drag_position = QPoint()

    def mousePressEvent(self, event):
        # Check if the mouse press is on the fillerAction
        action = self.actionAt(event.pos())
        if action and action.text().strip() == '':
            self.dragging = True
            self.drag_position = event.globalPos() - self.parent().frameGeometry().topLeft()
            event.accept()
        else:
            super(DraggableMenuBar, self).mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self.dragging:
            self.parent().move(event.globalPos() - self.drag_position)
            event.accept()
        else:
            super(DraggableMenuBar, self).mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        self.dragging = False
        super(DraggableMenuBar, self).mouseReleaseEvent(event)

class FocusLineEdit(QLineEdit):
    focusOut = pyqtSignal()

    def focusOutEvent(self, event):
        super().focusOutEvent(event)
        self.focusOut.emit()

class CustomTextEdit(QTextEdit):
    def __init__(self, parent=None):
        super().__init__(parent)

    def insertFromMimeData(self, source):
        if source.hasText():
            text = source.text()
            self.insertPlainText(text)
        else:
            super().insertFromMimeData(source)
### CUSTOM CONTROLS END ###            
            
### SPECIALFEATUREWIDGET START ###
class SpecialFeaturesWidget(QWidget):
    def __init__(self, parent=None, note_maker_instance=None):
        super().__init__(parent)
        self.note_maker_instance = note_maker_instance
        self.initUI()

    def initUI(self):
        self.setLayout(QVBoxLayout(self))
        self.tabs = QTabWidget(self)
        self.webhooks_widget = WebhooksWidget(self)
        self.email_widget = EmailSharingWidget(self)
        self.database_viewer_widget = DatabaseViewerWidget(self)
        self.cloud_widget = CloudIntegrationWidget(self)
        self.chat_widget = ChatWidget(self)
        self.cmd_widget = CommandPromptWidget(self)
        self.ssh_widget = SSHToolMainWidget(self)

        # Reserved For New Widgets
        # self.other_widget = OtherOptionsWidget(self)
        self.tabs.addTab(self.chat_widget, "AI Chat")
        self.tabs.addTab(self.cmd_widget, "Terminal")
        self.tabs.addTab(self.ssh_widget, "SSH")
        self.tabs.addTab(self.database_viewer_widget, "DB Viewer")
        self.tabs.addTab(self.webhooks_widget, "Webhooks")
        self.tabs.addTab(self.email_widget, "E-Mail")
        self.tabs.addTab(self.cloud_widget, "Cloud")

        # Reserved For New Widgets
        # self.tabs.addTab(self.other_widget, "Other Options")

        self.layout().addWidget(self.tabs)

    def on_api_type_changed(self, api_type_dropdown, model_dropdown):
        api_type = api_type_dropdown.currentText()
        model_dropdown.clear()
        if api_type in ACTIVE_MODELS:
            model_dropdown.addItems(ACTIVE_MODELS[api_type])

class WebhooksWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.initWebhooksDB()
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout()

        # Row 1: Webhook Name, Webhook URL
        row1Layout = QHBoxLayout()
        self.webhookNameEdit = QLineEdit()
        self.webhookNameEdit.setPlaceholderText("Enter Webhook Name")
        self.webhookUrlEdit = QLineEdit()
        self.webhookUrlEdit.setPlaceholderText("Enter Webhook URL")
        row1Layout.addWidget(QLabel("Webhook Name:"))
        row1Layout.addWidget(self.webhookNameEdit)
        row1Layout.addWidget(QLabel("Webhook URL:"))
        row1Layout.addWidget(self.webhookUrlEdit)
        layout.addLayout(row1Layout)

        # Row 2: Select Event, Select Webhook (Dropdown)
        row2Layout = QHBoxLayout()
        self.webhookEventDropdown = QComboBox()
        self.webhookEventDropdown.addItems(["Note Added", "Note Deleted", "Note Updated"])
        self.webhookDropdown = QComboBox()
        self.loadWebhooks()
        row2Layout.addWidget(QLabel("Select Event:"))
        row2Layout.addWidget(self.webhookEventDropdown)
        row2Layout.addWidget(QLabel("Select Webhook:"))
        row2Layout.addWidget(self.webhookDropdown)
        layout.addLayout(row2Layout)

        # Row 3: Message Text Area (Collapse/Expand functionality)
        self.messageTextEdit = QTextEdit()
        self.messageTextEdit.setPlaceholderText("Enter message")
        self.messageTextEdit.setMaximumHeight(100)
        self.messageTextEdit.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        layout.addWidget(QLabel("Message:"))
        layout.addWidget(self.messageTextEdit)

        # Row 4: Register Webhook (Button), Send Webhook (Button)
        row4Layout = QHBoxLayout()
        self.registerWebhookButton = QPushButton("Register Webhook")
        self.registerWebhookButton.clicked.connect(self.registerWebhook)
        self.sendWebhookButton = QPushButton("Send Webhook")
        self.sendWebhookButton.clicked.connect(self.sendWebhook)
        self.openSenderDialogButton = QPushButton("Open Sender Dialog")
        if super_debug_mode:
            self.openSenderDialogButton.clicked.connect(self.parent.check_toggle_mode)
        else:
            self.openSenderDialogButton.clicked.connect(self.openWebhookSenderDialog)
        row4Layout.addWidget(self.openSenderDialogButton)
        row4Layout.addWidget(self.registerWebhookButton)
        row4Layout.addWidget(self.sendWebhookButton)
        layout.addLayout(row4Layout)
        self.setLayout(layout)

    def initWebhooksDB(self):
        try:
            self.webhookdbConnection = sqlite3.connect('webhooks.db')
            cursor = self.webhookdbConnection.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='webhooks'")
            table_exists = cursor.fetchone()

            if not table_exists:
                self.createDatabase()
            else:
                self.updateDatabase()

            if debug_mode:
                print("Database initialized successfully.")
        except Exception as e:
            print(f"Error initializing the webhooks database: {str(e)}")
            QMessageBox.critical(self, "Database Error", f"An error occurred while initializing the database: {str(e)}")

    def createDatabase(self):
        try:
            cursor = self.webhookdbConnection.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS webhooks (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT,
                    url TEXT,
                    event TEXT
                )
            ''')
            self.webhookdbConnection.commit()
            if debug_mode:
                print("Webhooks table created successfully.")
        except sqlite3.Error as e:
            print(f"SQLite error: {str(e)}")
            QMessageBox.critical(self, "Database Error", f"SQLite error: {str(e)}")
        except Exception as e:
            print(f"Error creating the webhooks table: {str(e)}")
            QMessageBox.critical(self, "Database Error", f"An error occurred while creating the webhooks table: {str(e)}")

    def updateDatabase(self):
        try:
            cursor = self.webhookdbConnection.cursor()
            cursor.execute("PRAGMA table_info(webhooks)")
            columns = [column[1] for column in cursor.fetchall()]

            if 'name' not in columns or 'url' not in columns or 'event' not in columns:
                # Backup the existing database
                backup_db_path = 'webhooks_backup.db'
                
                # Using `shutil.copyfile` to create a backup
                import shutil
                shutil.copyfile('webhooks.db', backup_db_path)

                # Create a new database with the updated schema
                self.createDatabase()

                # Copy data from the backup database to the new database
                backup_connection = sqlite3.connect(backup_db_path)
                backup_cursor = backup_connection.cursor()
                backup_cursor.execute("SELECT * FROM webhooks")
                data = backup_cursor.fetchall()

                cursor.executemany("INSERT INTO webhooks (id, name, url, event) VALUES (?, ?, ?, ?)", data)
                self.webhookdbConnection.commit()

                backup_connection.close()
                os.remove(backup_db_path)
                if debug_mode:
                    print("Webhooks table updated successfully.")
            else:
                if debug_mode:
                    print("Webhooks table is already up to date.")
        except sqlite3.Error as e:
            print(f"SQLite error: {str(e)}")
            QMessageBox.critical(self, "Database Error", f"SQLite error: {str(e)}")
        except Exception as e:
            print(f"Error updating the webhooks table: {str(e)}")
            QMessageBox.critical(self, "Database Error", f"An error occurred while updating the webhooks table: {str(e)}")

    def loadWebhooks(self):
        try:
            self.webhookDropdown.clear()
            cursor = self.webhookdbConnection.cursor()
            cursor.execute("SELECT name FROM webhooks")
            webhooks = cursor.fetchall()
            for webhook in webhooks:
                self.webhookDropdown.addItem(webhook[0])
        except Exception as e:
            print(f"Error loading webhooks: {str(e)}")
            QMessageBox.critical(self, "Load Webhooks Error", f"An error occurred while loading the webhooks: {str(e)}")

    def registerWebhook(self):
        name = self.webhookNameEdit.text().strip()
        url = self.webhookUrlEdit.text().strip()
        event = self.webhookEventDropdown.currentText()

        if not name or not url:
            QMessageBox.warning(self, "Webhook Error", "Please enter a webhook name and URL.")
            return

        try:
            cursor = self.webhookdbConnection.cursor()
            cursor.execute("INSERT INTO webhooks (name, url, event) VALUES (?, ?, ?)", (name, url, event))
            self.webhookdbConnection.commit()
            self.loadWebhooks()
            QMessageBox.information(self, "Webhook", "Webhook registered successfully.")
        except sqlite3.Error as e:
            print(f"SQLite error: {str(e)}")
            QMessageBox.critical(self, "Database Error", f"SQLite error: {str(e)}")
        except Exception as e:
            print(f"Error registering webhook: {str(e)}")
            QMessageBox.critical(self, "Webhook Error", f"An error occurred while registering the webhook: {str(e)}")

    def sendWebhook(self):
        url = self.webhookUrlEdit.text().strip()
        event = self.webhookEventDropdown.currentText()
        message = self.messageTextEdit.toPlainText().strip()

        if not url:
            QMessageBox.warning(self, "Webhook Error", "Please enter a webhook URL.")
            return

        data = {
            "event": event,
            "message": message
        }

        try:
            response = requests.post(url, json=data, timeout=10)
            if response.status_code == 200:
                QMessageBox.information(self, "Webhook", "Webhook sent successfully.")
            elif response.status_code == 202:
                QMessageBox.information(self, "Webhook", "Webhook accepted and is being processed.")
            else:
                QMessageBox.critical(self, "Webhook Error", f"Failed to send webhook. Server responded with status code: {response.status_code}")
        except requests.exceptions.RequestException as e:
            QMessageBox.critical(self, "Webhook Error", f"An error occurred: {str(e)}")
            retry = QMessageBox.question(self, "Webhook Error", "Failed to connect to the server. Would you like to retry?",
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if retry == QMessageBox.Yes:
                self.sendWebhook()

    def openWebhookSenderDialog(self):
        dialog = WebhookSenderDialog(self)
        dialog.exec_()

class EmailSharingWidget(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.initUI()

    def initUI(self):
        self.setWindowTitle("Email Sharing Widget")

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        self.create_email_tab()
        self.create_inbox_tab()

    def create_email_tab(self):
        email_tab = QWidget()
        layout = QVBoxLayout(email_tab)

        scrollArea = QScrollArea()
        scrollArea.setWidgetResizable(True)
        scrollWidget = QWidget()
        scrollLayout = QVBoxLayout(scrollWidget)
        scrollArea.setWidget(scrollWidget)

        # Email settings
        email_group = QGroupBox("Email Settings")
        email_layout = QVBoxLayout(email_group)

        self.email_provider_combo = QComboBox()
        self.email_provider_combo.addItems(["Default Email Client", "Google", "Outlook/Office 365"])
        self.email_provider_combo.currentIndexChanged.connect(self.update_email_settings)
        email_layout.addWidget(QLabel("Email Provider:"))
        email_layout.addWidget(self.email_provider_combo)

        self.email_address_edit = QLineEdit()
        self.email_address_edit.setPlaceholderText("Enter your email address")
        email_layout.addWidget(QLabel("Email Address:"))
        email_layout.addWidget(self.email_address_edit)

        self.email_password_edit = QLineEdit()
        self.email_password_edit.setPlaceholderText("Enter your email password")
        self.email_password_edit.setEchoMode(QLineEdit.Password)
        email_layout.addWidget(QLabel("Email Password:"))
        email_layout.addWidget(self.email_password_edit)

        self.mfa_checkbox = QCheckBox("Enable MFA")
        email_layout.addWidget(self.mfa_checkbox)

        self.recipient_email_edit = QLineEdit()
        self.recipient_email_edit.setPlaceholderText("Enter recipient's email address")
        email_layout.addWidget(QLabel("Recipient Email:"))
        email_layout.addWidget(self.recipient_email_edit)

        scrollLayout.addWidget(email_group)

        # Email options
        options_group = QGroupBox("Email Options")
        options_layout = QVBoxLayout(options_group)

        self.send_on_save_checkbox = QCheckBox("Send email with each note save")
        options_layout.addWidget(self.send_on_save_checkbox)

        send_button = QPushButton("Send Current Note")
        send_button.clicked.connect(self.send_current_note)
        options_layout.addWidget(send_button)

        popout_button = QPushButton("Pop Out")
        popout_button.clicked.connect(self.pop_out)
        options_layout.addWidget(popout_button)

        scrollLayout.addWidget(options_group)

        layout.addWidget(scrollArea)
        self.tabs.addTab(email_tab, "Compose Email")

    def create_inbox_tab(self):
        inbox_tab = QWidget()
        layout = QVBoxLayout(inbox_tab)

        refresh_button = QPushButton("Refresh Inbox")
        refresh_button.clicked.connect(self.refresh_inbox)
        layout.addWidget(refresh_button)

        self.inbox_display = QLabel("Inbox messages will be displayed here.")
        layout.addWidget(self.inbox_display)

        self.tabs.addTab(inbox_tab, "Inbox")

    def update_email_settings(self, index):
        provider = self.email_provider_combo.currentText()
        if provider == "Default Email Client":
            self.email_address_edit.setEnabled(False)
            self.email_password_edit.setEnabled(False)
            self.mfa_checkbox.setEnabled(False)
        else:
            self.email_address_edit.setEnabled(True)
            self.email_password_edit.setEnabled(True)
            self.mfa_checkbox.setEnabled(True)

    def send_current_note(self):
        provider = self.email_provider_combo.currentText()
        email_address = self.email_address_edit.text().strip()
        email_password = self.email_password_edit.text().strip()
        recipient_email = self.recipient_email_edit.text().strip()
        mfa_enabled = self.mfa_checkbox.isChecked()

        if provider == "Default Email Client":
            try:
                subject = "Note from TSTP:Omni Omega"
                body = self.parent.note_maker_instance.textArea.toPlainText()
                url = QUrl(f"mailto:{recipient_email}?subject={subject}&body={body}")
                QDesktopServices.openUrl(url)
                QMessageBox.information(self, "Email Sharing", "Email sent using default email client.")
            except Exception as e:
                QMessageBox.critical(self, "Email Sharing", f"Failed to send email using default email client: {str(e)}")
        else:
            if not email_address:
                QMessageBox.warning(self, "Email Sharing", "Please enter your email address.")
                return

            if not email_password:
                QMessageBox.warning(self, "Email Sharing", "Please enter your email password.")
                return

            if not recipient_email:
                QMessageBox.warning(self, "Email Sharing", "Please enter the recipient's email address.")
                return

            try:
                if provider == "Google":
                    self.send_email_via_google(email_address, email_password, recipient_email, mfa_enabled)
                elif provider == "Outlook/Office 365":
                    self.send_email_via_outlook(email_address, email_password, recipient_email, mfa_enabled)
            except Exception as e:
                QMessageBox.critical(self, "Email Sharing", f"Failed to send email: {str(e)}")

    def send_email_via_google(self, client_id, client_secret, refresh_token, recipient_email, mfa_enabled):
        try:
            access_token = self.get_google_oauth2_token(client_id, client_secret, refresh_token)
            if not access_token:
                return

            msg = MIMEMultipart()
            msg['From'] = self.email_address_edit.text().strip()
            msg['To'] = recipient_email
            msg['Subject'] = "Note from TSTP:Omni Omega"

            body = self.parent.note_maker_instance.textArea.toPlainText()
            msg.attach(MIMEText(body, 'plain'))

            server = smtplib.SMTP('smtp.gmail.com', 587)
            server.starttls()
            server.ehlo()
            server.auth('XOAUTH2', lambda x: access_token)
            server.sendmail(self.email_address_edit.text().strip(), recipient_email, msg.as_string())
            server.quit()

            QMessageBox.information(self, "Email Sharing", "Email sent successfully via Google.")
        except smtplib.SMTPAuthenticationError:
            QMessageBox.critical(self, "Email Sharing", "Authentication error. Please check your email address and password.")
        except smtplib.SMTPException as e:
            QMessageBox.critical(self, "Email Sharing", f"SMTP error occurred: {str(e)}")
        except Exception as e:
            QMessageBox.critical(self, "Email Sharing", f"An error occurred: {str(e)}")

    def send_email_via_outlook(self, client_id, client_secret, refresh_token, recipient_email, mfa_enabled):
        try:
            access_token = self.get_outlook_oauth2_token(client_id, client_secret, refresh_token)
            if not access_token:
                return

            msg = MIMEMultipart()
            msg['From'] = self.email_address_edit.text().strip()
            msg['To'] = recipient_email
            msg['Subject'] = "Note from TSTP:Omni Omega"

            body = self.parent.note_maker_instance.textArea.toPlainText()
            msg.attach(MIMEText(body, 'plain'))

            server = smtplib.SMTP('smtp.office365.com', 587)
            server.starttls()
            server.ehlo()
            server.auth('XOAUTH2', lambda x: access_token)
            server.sendmail(self.email_address_edit.text().strip(), recipient_email, msg.as_string())
            server.quit()

            QMessageBox.information(self, "Email Sharing", "Email sent successfully via Outlook/Office 365.")
        except smtplib.SMTPAuthenticationError:
            QMessageBox.critical(self, "Email Sharing", "Authentication error. Please check your email address and password.")
        except smtplib.SMTPException as e:
            QMessageBox.critical(self, "Email Sharing", f"SMTP error occurred: {str(e)}")
        except Exception as e:
            QMessageBox.critical(self, "Email Sharing", f"An error occurred: {str(e)}")

    def get_google_oauth2_token(self, client_id, client_secret, refresh_token):
        try:
            token_url = "https://oauth2.googleapis.com/token"
            token_data = {
                "client_id": client_id,
                "client_secret": client_secret,
                "refresh_token": refresh_token,
                "grant_type": "refresh_token",
            }
            token_r = requests.post(token_url, data=token_data)
            token_r.raise_for_status()
            token_response = token_r.json()
            return token_response["access_token"]
        except Exception as e:
            QMessageBox.critical(self, "OAuth2 Error", f"Failed to obtain Google OAuth2 token: {str(e)}")
            return None

    def get_outlook_oauth2_token(self, client_id, client_secret, refresh_token):
        try:
            token_url = "https://login.microsoftonline.com/common/oauth2/v2.0/token"
            token_data = {
                "client_id": client_id,
                "client_secret": client_secret,
                "refresh_token": refresh_token,
                "grant_type": "refresh_token",
                "scope": "https://graph.microsoft.com/.default",
            }
            token_r = requests.post(token_url, data=token_data)
            token_r.raise_for_status()
            token_response = token_r.json()
            return token_response["access_token"]
        except Exception as e:
            QMessageBox.critical(self, "OAuth2 Error", f"Failed to obtain Outlook OAuth2 token: {str(e)}")
            return None

    def refresh_inbox(self):
        provider = self.email_provider_combo.currentText()
        email_address = self.email_address_edit.text().strip()
        email_password = self.email_password_edit.text().strip()

        if not email_address or not email_password:
            QMessageBox.warning(self, "Email Sharing", "Please enter your email address and password.")
            return

        try:
            if provider == "Google":
                self.check_email_via_google(email_address, email_password)
            elif provider == "Outlook/Office 365":
                self.check_email_via_outlook(email_address, email_password)
        except Exception as e:
            QMessageBox.critical(self, "Email Sharing", f"Failed to check emails: {str(e)}")

    def check_email_via_google(self, email_address, email_password):
        try:
            mail = imaplib.IMAP4_SSL('imap.gmail.com')
            mail.login(email_address, email_password)
            mail.select('inbox')

            result, data = mail.search(None, 'ALL')
            email_ids = data[0].split()

            messages = []
            for e_id in email_ids[-10:]:
                result, msg_data = mail.fetch(e_id, '(RFC822)')
                raw_email = msg_data[0][1].decode('utf-8')
                msg = email.message_from_string(raw_email)
                messages.append(f"From: {msg['From']}\nSubject: {msg['Subject']}\n\n")

            self.inbox_display.setText("\n".join(messages))
            mail.logout()
        except Exception as e:
            QMessageBox.critical(self, "Email Sharing", f"An error occurred: {str(e)}")

    def check_email_via_outlook(self, email_address, email_password):
        try:
            mail = imaplib.IMAP4_SSL('outlook.office365.com')
            mail.login(email_address, email_password)
            mail.select('inbox')

            result, data = mail.search(None, 'ALL')
            email_ids = data[0].split()

            messages = []
            for e_id in email_ids[-10:]:
                result, msg_data = mail.fetch(e_id, '(RFC822)')
                raw_email = msg_data[0][1].decode('utf-8')
                msg = email.message_from_string(raw_email)
                messages.append(f"From: {msg['From']}\nSubject: {msg['Subject']}\n\n")

            self.inbox_display.setText("\n".join(messages))
            mail.logout()
        except Exception as e:
            QMessageBox.critical(self, "Email Sharing", f"An error occurred: {str(e)}")

    def pop_out(self):
        pop_out_window = EmailSharingWidget(parent=self.parent)
        pop_out_window.show()

class DatabaseViewerWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)

        # Create the tab widget
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet("QTabWidget::pane { border: 0; }")  # Remove tab pane border

        # Create the "Query" tab
        self.query_tab = QWidget()
        query_layout = QVBoxLayout(self.query_tab)

        # Query execution
        query_group = QGroupBox("Query Execution")
        query_group.setStyleSheet("QGroupBox { font-weight: bold; }")
        query_layout_inner = QVBoxLayout(query_group)

        self.query_edit = QPlainTextEdit()
        self.query_edit.setPlaceholderText("Enter SQL query")
        self.query_edit.setStyleSheet("QPlainTextEdit { font-family: monospace; }")
        query_layout_inner.addWidget(self.query_edit)

        execute_button = QPushButton("Execute Query")
        execute_button.clicked.connect(self.execute_query)
        query_layout_inner.addWidget(execute_button)

        # Query results
        results_group = QGroupBox("Query Results")
        results_group.setStyleSheet("QGroupBox { font-weight: bold; }")
        results_layout = QVBoxLayout(results_group)

        self.results_table = QTableWidget()
        self.results_table.setColumnCount(0)
        self.results_table.setRowCount(0)
        self.results_table.setStyleSheet("QTableWidget { font-family: monospace; }")
        results_layout.addWidget(self.results_table)

        query_layout.addWidget(query_group)
        query_layout.addWidget(results_group)

        # Create the "Database" tab
        self.database_tab = QWidget()
        database_layout = QVBoxLayout(self.database_tab)

        # Database connection settings
        connection_group = QGroupBox("Database Connection")
        connection_group.setStyleSheet("QGroupBox { font-weight: bold; }")
        connection_layout = QFormLayout(connection_group)

        self.db_type_combo = QComboBox()
        self.db_type_combo.addItems(["SQLite", "MySQL", "PostgreSQL", "File"])
        self.db_type_combo.currentIndexChanged.connect(self.update_database_settings)
        connection_layout.addRow("Database Type:", self.db_type_combo)

        self.db_host_edit = QLineEdit()
        self.db_host_edit.setPlaceholderText("Enter database host")
        connection_layout.addRow("Host:", self.db_host_edit)

        self.db_port_edit = QLineEdit()
        self.db_port_edit.setPlaceholderText("Enter database port")
        connection_layout.addRow("Port:", self.db_port_edit)

        self.db_name_edit = QLineEdit()
        self.db_name_edit.setPlaceholderText("Enter database name")
        connection_layout.addRow("Database Name:", self.db_name_edit)

        self.db_username_edit = QLineEdit()
        self.db_username_edit.setPlaceholderText("Enter database username")
        connection_layout.addRow("Username:", self.db_username_edit)

        self.db_password_edit = QLineEdit()
        self.db_password_edit.setPlaceholderText("Enter database password")
        self.db_password_edit.setEchoMode(QLineEdit.Password)
        connection_layout.addRow("Password:", self.db_password_edit)

        self.db_file_edit = QLineEdit()
        self.db_file_edit.setPlaceholderText("Select database file")
        self.db_file_button = QPushButton("Browse")
        self.db_file_button.clicked.connect(self.browse_database_file)
        file_layout = QHBoxLayout()
        file_layout.addWidget(self.db_file_edit)
        file_layout.addWidget(self.db_file_button)
        connection_layout.addRow("Database File:", file_layout)

        connect_button = QPushButton("Connect")
        connect_button.clicked.connect(self.connect_to_database)
        connection_layout.addRow(connect_button)

        database_layout.addWidget(connection_group)

        # Add the tabs to the tab widget
        self.tab_widget.addTab(self.database_tab, "Database")
        self.tab_widget.addTab(self.query_tab, "Query")

        layout.addWidget(self.tab_widget)
        self.setLayout(layout)

    def connect_to_database(self):
        db_type = self.db_type_combo.currentText()

        if db_type == "File":
            db_file = self.db_file_edit.text().strip()
            if not db_file:
                QMessageBox.warning(self, "Database Connection", "Please select a database file.")
                return
            try:
                self.connection = sqlite3.connect(db_file)
                QMessageBox.information(self, "Database Connection", "Connected to the database file successfully.")
                self.create_database_viewer_tab()
            except Exception as e:
                QMessageBox.critical(self, "Database Connection", f"Failed to connect to the database file: {str(e)}")
        else:
            db_host = self.db_host_edit.text().strip()
            db_port = self.db_port_edit.text().strip()
            db_name = self.db_name_edit.text().strip()
            db_username = self.db_username_edit.text().strip()
            db_password = self.db_password_edit.text().strip()

            try:
                if db_type == "MySQL":
                    import mysql.connector
                    self.connection = mysql.connector.connect(
                        host=db_host,
                        port=int(db_port),
                        database=db_name,
                        user=db_username,
                        password=db_password
                    )
                elif db_type == "PostgreSQL":
                    import psycopg2
                    self.connection = psycopg2.connect(
                        host=db_host,
                        port=db_port,
                        database=db_name,
                        user=db_username,
                        password=db_password
                    )
                else:
                    raise Exception("Unsupported database type.")

                QMessageBox.information(self, "Database Connection", "Connected to the database successfully.")
                self.create_database_viewer_tab()
            except Exception as e:
                QMessageBox.critical(self, "Database Connection", f"Failed to connect to the database: {str(e)}")

    def create_database_viewer_tab(self):
        # Create the "Database Viewer" tab
        self.database_viewer_tab = QWidget()
        database_viewer_layout = QVBoxLayout(self.database_viewer_tab)

        # Table selection
        table_selection_group = QGroupBox("Table Selection")
        table_selection_group.setStyleSheet("QGroupBox { font-weight: bold; }")
        table_selection_layout = QHBoxLayout(table_selection_group)

        self.table_combo = QComboBox()
        self.table_combo.currentIndexChanged.connect(self.load_table_data)
        table_selection_layout.addWidget(self.table_combo)

        # Table data
        table_data_group = QGroupBox("Table Data")
        table_data_group.setStyleSheet("QGroupBox { font-weight: bold; }")
        table_data_layout = QVBoxLayout(table_data_group)

        self.table_data_table = QTableWidget()
        self.table_data_table.setColumnCount(0)
        self.table_data_table.setRowCount(0)
        self.table_data_table.setStyleSheet("QTableWidget { font-family: monospace; }")
        table_data_layout.addWidget(self.table_data_table)

        # CRUD buttons
        crud_layout = QHBoxLayout()
        create_button = QPushButton("Create")
        create_button.clicked.connect(self.create_record)
        update_button = QPushButton("Update")
        update_button.clicked.connect(self.update_record)
        delete_button = QPushButton("Delete")
        delete_button.clicked.connect(self.delete_record)
        crud_layout.addWidget(create_button)
        crud_layout.addWidget(update_button)
        crud_layout.addWidget(delete_button)

        # Close button
        close_button = QPushButton("Close")
        close_button.clicked.connect(self.close_database_viewer_tab)

        database_viewer_layout.addWidget(table_selection_group)
        database_viewer_layout.addWidget(table_data_group)
        database_viewer_layout.addLayout(crud_layout)
        database_viewer_layout.addWidget(close_button)

        # Add the "Database Viewer" tab to the tab widget
        self.tab_widget.addTab(self.database_viewer_tab, "Database Viewer")

        # Load table names
        self.load_table_names()

    def load_table_names(self):
        try:
            cursor = self.connection.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            table_names = [row[0] for row in cursor.fetchall()]
            self.table_combo.clear()
            self.table_combo.addItems(table_names)
        except Exception as e:
            QMessageBox.critical(self, "Load Table Names", f"Failed to load table names: {str(e)}")

    def load_table_data(self):
        selected_table = self.table_combo.currentText()
        try:
            self.table_data_table.setEnabled(False)
            self.table_data_table.setRowCount(0)
            self.table_data_table.setColumnCount(0)

            loading_label = QLabel("Loading table data...")
            self.table_data_table.setIndexWidget(self.table_data_table.model().index(0, 0), loading_label)

            cursor = self.connection.cursor()
            cursor.execute(f"SELECT * FROM {selected_table}")
            data = cursor.fetchall()
            column_names = [description[0] for description in cursor.description]

            self.table_data_table.setColumnCount(len(column_names))
            self.table_data_table.setRowCount(len(data))
            self.table_data_table.setHorizontalHeaderLabels(column_names)

            for row_index, row_data in enumerate(data):
                for column_index, cell_data in enumerate(row_data):
                    self.table_data_table.setItem(row_index, column_index, QTableWidgetItem(str(cell_data)))

            self.table_data_table.setEnabled(True)
            self.table_data_table.setIndexWidget(self.table_data_table.model().index(0, 0), None)
        except Exception as e:
            QMessageBox.critical(self, "Load Table Data", f"Failed to load table data: {str(e)}")

    def create_record(self):
        selected_table = self.table_combo.currentText()
        if not selected_table:
            QMessageBox.warning(self, "Create Record", "Please select a table.")
            return

        column_names = self.get_column_names(selected_table)

        dialog = RecordDialog(self, "Create Record", column_names)
        if dialog.exec_() == QDialog.Accepted:
            values = dialog.get_values()
            try:
                cursor = self.connection.cursor()
                placeholders = ', '.join(['?'] * len(values))
                query = f"INSERT INTO {selected_table} ({', '.join(column_names)}) VALUES ({placeholders})"
                cursor.execute(query, values)
                self.connection.commit()
                self.load_table_data()
            except Exception as e:
                QMessageBox.critical(self, "Create Record", f"Failed to create record: {str(e)}")

    def update_record(self):
        selected_table = self.table_combo.currentText()
        if not selected_table:
            QMessageBox.warning(self, "Update Record", "Please select a table.")
            return

        selected_row = self.table_data_table.currentRow()
        if selected_row == -1:
            QMessageBox.warning(self, "Update Record", "Please select a record to update.")
            return

        column_names = self.get_column_names(selected_table)
        current_values = [self.table_data_table.item(selected_row, column_index).text() for column_index in range(len(column_names))]

        dialog = RecordDialog(self, "Update Record", column_names, current_values)
        if dialog.exec_() == QDialog.Accepted:
            updated_values = dialog.get_values()
            try:
                cursor = self.connection.cursor()
                set_clauses = [f"{column} = ?" for column in column_names]
                query = f"UPDATE {selected_table} SET {', '.join(set_clauses)} WHERE rowid = ?"
                cursor.execute(query, updated_values + [selected_row + 1])  # rowid is 1-based
                self.connection.commit()
                self.load_table_data()
            except Exception as e:
                QMessageBox.critical(self, "Update Record", f"Failed to update record: {str(e)}")

    def delete_record(self):
        selected_table = self.table_combo.currentText()
        if not selected_table:
            QMessageBox.warning(self, "Delete Record", "Please select a table.")
            return

        selected_row = self.table_data_table.currentRow()
        if selected_row == -1:
            QMessageBox.warning(self, "Delete Record", "Please select a record to delete.")
            return

        confirmation = QMessageBox.question(self, "Delete Record", "Are you sure you want to delete this record?",
                                            QMessageBox.Yes | QMessageBox.No)
        if confirmation == QMessageBox.Yes:
            try:
                cursor = self.connection.cursor()
                query = f"DELETE FROM {selected_table} WHERE rowid = ?"
                cursor.execute(query, [selected_row + 1])  # rowid is 1-based
                self.connection.commit()
                self.load_table_data()
            except Exception as e:
                QMessageBox.critical(self, "Delete Record", f"Failed to delete record: {str(e)}")

    def get_column_names(self, table_name):
        try:
            cursor = self.connection.cursor()
            cursor.execute(f"PRAGMA table_info({table_name})")
            column_names = [row[1] for row in cursor.fetchall()]
            return column_names
        except Exception as e:
            QMessageBox.critical(self, "Get Column Names", f"Failed to get column names: {str(e)}")
            return []
       
    def save_record(self, table_name, input_fields, dialog, row_to_update=-1):
        try:
            # Collect the input values
            column_values = [input_fields[column].text() for column in input_fields]

            if row_to_update >= 0:
                # Update the existing record
                self.update_database_record(table_name, column_values, row_to_update)
            else:
                # Create a new record
                self.create_database_record(table_name, column_values)

            # Refresh the database table
            self.load_database_table(table_name)
            dialog.accept()
        except Exception as e:
            QMessageBox.critical(self, "Save Record", f"Failed to save the record: {str(e)}")
        
    def get_table_columns(self, table_name):
        """
        Fetch the column names for the given table.
        """
        try:
            cursor = self.connection.cursor()
            cursor.execute(f"PRAGMA table_info({table_name})")
            columns = [column[1] for column in cursor.fetchall()]
            return columns
        except Exception as e:
            QMessageBox.critical(self, "Get Table Columns", f"Failed to fetch column names: {str(e)}")
            return []

    def create_database_record(self, table_name, column_values):
        """
        Insert a new record into the database.
        """
        try:
            columns = self.get_table_columns(table_name)
            column_placeholders = ", ".join(["?"] * len(columns))
            query = f"INSERT INTO {table_name} ({', '.join(columns)}) VALUES ({column_placeholders})"
            cursor = self.connection.cursor()
            cursor.execute(query, column_values)
            self.connection.commit()
        except Exception as e:
            self.connection.rollback()
            raise Exception(f"Failed to create new record: {str(e)}")

    def update_database_record(self, table_name, column_values, row_index):
        """
        Update an existing record in the database.
        """
        try:
            columns = self.get_table_columns(table_name)
            set_clauses = [f"{column} = ?" for column in columns]
            query = f"UPDATE {table_name} SET {', '.join(set_clauses)} WHERE rowid = ?"
            cursor = self.connection.cursor()
            cursor.execute(query, column_values + [row_index + 1])  # Add 1 to rowid since it's 1-based
            self.connection.commit()
        except Exception as e:
            self.connection.rollback()
            raise Exception(f"Failed to update record: {str(e)}")

    def delete_database_record(self, table_name, row_index):
        """
        Delete a record from the database.
        """
        try:
            query = f"DELETE FROM {table_name} WHERE rowid = ?"
            cursor = self.connection.cursor()
            cursor.execute(query, [row_index + 1])  # Add 1 to rowid since it's 1-based
            self.connection.commit()
        except Exception as e:
            self.connection.rollback()
            raise Exception(f"Failed to delete record: {str(e)}")

    def load_database_table(self, table_name):
        """
        Load the data from the given table and display it in the database table.
        """
        try:
            cursor = self.connection.cursor()
            cursor.execute(f"SELECT * FROM {table_name}")
            data = cursor.fetchall()
            columns = self.get_table_columns(table_name)

            self.database_table.setRowCount(len(data))
            self.database_table.setColumnCount(len(columns))
            self.database_table.setHorizontalHeaderLabels(columns)

            for row_index, row_data in enumerate(data):
                for col_index, cell_data in enumerate(row_data):
                    self.database_table.setItem(row_index, col_index, QTableWidgetItem(str(cell_data)))
        except Exception as e:
            QMessageBox.critical(self, "Load Database Table", f"Failed to load table data: {str(e)}")

    def update_database_settings(self, index):
        db_type = self.db_type_combo.currentText()
        if db_type == "File":
            self.db_host_edit.setEnabled(False)
            self.db_port_edit.setEnabled(False)
            self.db_name_edit.setEnabled(False)
            self.db_username_edit.setEnabled(False)
            self.db_password_edit.setEnabled(False)
            self.db_file_edit.setEnabled(True)
            self.db_file_button.setEnabled(True)
        else:
            self.db_host_edit.setEnabled(True)
            self.db_port_edit.setEnabled(True)
            self.db_name_edit.setEnabled(True)
            self.db_username_edit.setEnabled(True)
            self.db_password_edit.setEnabled(True)
            self.db_file_edit.setEnabled(False)
            self.db_file_button.setEnabled(False)

    def browse_database_file(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "Select Database File", "", "Database Files (*.db *.sqlite)")
        if file_path:
            self.db_file_edit.setText(file_path)

    def close_database_viewer_tab(self):
        current_index = self.tab_widget.indexOf(self.database_viewer_tab)
        if current_index != -1:
            self.tab_widget.removeTab(current_index)
            self.disconnect_from_database()

    def disconnect_from_database(self):
        if self.connection:
            self.connection.close()
            self.connection = None
            QMessageBox.information(self, "Database Disconnection", "Disconnected from the database.")

    def execute_query(self):
        query = self.query_edit.toPlainText().strip()

        if not query:
            QMessageBox.warning(self, "Query Execution", "Please enter a query.")
            return

        try:
            cursor = self.connection.cursor()
            cursor.execute(query)

            if query.lower().startswith("select"):
                # Query returned results
                column_names = [column[0] for column in cursor.description]
                results = cursor.fetchall()

                self.results_table.setColumnCount(len(column_names))
                self.results_table.setHorizontalHeaderLabels(column_names)
                self.results_table.setRowCount(len(results))

                for row_index, row_data in enumerate(results):
                    for column_index, cell_data in enumerate(row_data):
                        self.results_table.setItem(row_index, column_index, QTableWidgetItem(str(cell_data)))
            else:
                # Query did not return results (e.g., INSERT, UPDATE, DELETE)
                self.connection.commit()
                QMessageBox.information(self, "Query Execution", "Query executed successfully.")

        except Exception as e:
            QMessageBox.critical(self, "Query Execution", f"Failed to execute the query: {str(e)}")

class CloudIntegrationWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)

        # Create a scrollable area for the tab content
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)

        # Create the tab content widget
        content_widget = QWidget()
        content_layout = QVBoxLayout(content_widget)

        # Cloud service selection
        service_group = QGroupBox("Cloud Service")
        service_group.setStyleSheet("QGroupBox { font-weight: bold; }")
        service_layout = QHBoxLayout(service_group)

        self.service_combo = QComboBox()
        self.service_combo.addItems(["Dropbox", "Google Drive", "OneDrive"])
        self.service_combo.currentIndexChanged.connect(self.update_authentication_ui)
        service_layout.addWidget(QLabel("Select Service:"))
        service_layout.addWidget(self.service_combo)

        content_layout.addWidget(service_group)

        # Authentication
        auth_group = QGroupBox("Authentication")
        auth_group.setStyleSheet("QGroupBox { font-weight: bold; }")
        auth_layout = QVBoxLayout(auth_group)

        self.auth_status_label = QLabel("Authentication Status: Not Authenticated")
        auth_layout.addWidget(self.auth_status_label)

        auth_button = QPushButton("Authenticate")
        auth_button.clicked.connect(self.authenticate_cloud_service)
        auth_layout.addWidget(auth_button)

        content_layout.addWidget(auth_group)

        # File synchronization
        sync_group = QGroupBox("File Synchronization")
        sync_group.setStyleSheet("QGroupBox { font-weight: bold; }")
        sync_layout = QVBoxLayout(sync_group)

        self.local_folder_edit = QLineEdit()
        self.local_folder_edit.setPlaceholderText("Select local folder")
        local_folder_button = QPushButton("Browse")
        local_folder_button.clicked.connect(self.browse_local_folder)
        sync_layout.addWidget(QLabel("Local Folder:"))
        sync_layout.addWidget(self.local_folder_edit)
        sync_layout.addWidget(local_folder_button)

        self.cloud_folder_edit = QLineEdit()
        self.cloud_folder_edit.setPlaceholderText("Enter cloud folder path")
        sync_layout.addWidget(QLabel("Cloud Folder:"))
        sync_layout.addWidget(self.cloud_folder_edit)

        sync_button = QPushButton("Sync Files")
        sync_button.clicked.connect(self.sync_files)
        sync_layout.addWidget(sync_button)

        content_layout.addWidget(sync_group)

        scroll_area.setWidget(content_widget)
        layout.addWidget(scroll_area)
        self.setLayout(layout)

    def update_authentication_ui(self, index):
        service = self.service_combo.currentText()
        self.auth_status_label.setText("Authentication Status: Not Authenticated")

    def authenticate_cloud_service(self):
        service = self.service_combo.currentText()

        try:
            if service == "Dropbox":
                # Dropbox authentication code
                self.auth_status_label.setText("Authentication Status: Authenticated")
                QMessageBox.information(self, "Cloud Integration", "Authenticated with Dropbox successfully.")
            elif service == "Google Drive":
                # Google Drive authentication code
                self.auth_status_label.setText("Authentication Status: Authenticated")
                QMessageBox.information(self, "Cloud Integration", "Authenticated with Google Drive successfully.")
            elif service == "OneDrive":
                # OneDrive authentication code
                self.auth_status_label.setText("Authentication Status: Authenticated")
                QMessageBox.information(self, "Cloud Integration", "Authenticated with OneDrive successfully.")
            else:
                raise Exception("Unsupported cloud service.")
        except Exception as e:
            QMessageBox.critical(self, "Cloud Integration", f"Authentication failed: {str(e)}")

    def browse_local_folder(self):
        folder_path = QFileDialog.getExistingDirectory(self, "Select Local Folder")
        if folder_path:
            self.local_folder_edit.setText(folder_path)

    def sync_files(self):
        service = self.service_combo.currentText()
        local_folder = self.local_folder_edit.text().strip()
        cloud_folder = self.cloud_folder_edit.text().strip()

        if not local_folder:
            QMessageBox.warning(self, "File Synchronization", "Please select a local folder.")
            return

        if not cloud_folder:
            QMessageBox.warning(self, "File Synchronization", "Please enter a cloud folder path.")
            return

        try:
            if service == "Dropbox":
                # Dropbox synchronization code
                QMessageBox.information(self, "File Synchronization", "Files synchronized with Dropbox successfully.")
            elif service == "Google Drive":
                # Google Drive synchronization code
                QMessageBox.information(self, "File Synchronization", "Files synchronized with Google Drive successfully.")
            elif service == "OneDrive":
                # OneDrive synchronization code
                QMessageBox.information(self, "File Synchronization", "Files synchronized with OneDrive successfully.")
            else:
                raise Exception("Unsupported cloud service.")
        except Exception as e:
            QMessageBox.critical(self, "File Synchronization", f"File synchronization failed: {str(e)}")

# SSH Widget START #
class SSHToolConnectionManager:
    def __init__(self, db_path="ssh_connections.db"):
        self.conn = sqlite3.connect(db_path)
        self.create_table()

    def create_table(self):
        query = """
        CREATE TABLE IF NOT EXISTS connections (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            hostname TEXT NOT NULL,
            port INTEGER NOT NULL,
            username TEXT NOT NULL,
            auth_method TEXT NOT NULL,
            password TEXT,
            private_key_file TEXT
        );
        """
        self.conn.execute(query)
        self.conn.commit()

    def add_connection(self, name, hostname, port, username, auth_method, password=None, private_key_file=None):
        query = """
        INSERT INTO connections (name, hostname, port, username, auth_method, password, private_key_file)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        """
        self.conn.execute(query, (name, hostname, port, username, auth_method, password, private_key_file))
        self.conn.commit()

    def update_connection(self, conn_id, name, hostname, port, username, auth_method, password=None, private_key_file=None):
        query = """
        UPDATE connections
        SET name = ?, hostname = ?, port = ?, username = ?, auth_method = ?, password = ?, private_key_file = ?
        WHERE id = ?
        """
        self.conn.execute(query, (name, hostname, port, username, auth_method, password, private_key_file, conn_id))
        self.conn.commit()

    def delete_connection(self, conn_id):
        query = "DELETE FROM connections WHERE id = ?"
        self.conn.execute(query, (conn_id,))
        self.conn.commit()

    def list_connections(self):
        query = "SELECT * FROM connections"
        cursor = self.conn.execute(query)
        return cursor.fetchall()

class SSHToolClient:
    def __init__(self, hostname, port, username, password=None, private_key_file=None):
        self.hostname = hostname
        self.port = port
        self.username = username
        self.password = password
        self.private_key_file = private_key_file
        self.client = paramiko.SSHClient()
        self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    def connect(self):
        try:
            if self.private_key_file:
                pkey = paramiko.RSAKey.from_private_key_file(self.private_key_file)
                self.client.connect(self.hostname, port=self.port, username=self.username, pkey=pkey)
            else:
                self.client.connect(self.hostname, port=self.port, username=self.username, password=self.password)
        except paramiko.SSHException as e:
            raise ConnectionError(f"Failed to connect to {self.hostname}:{self.port} - {str(e)}")

    def execute_command(self, command):
        try:
            stdin, stdout, stderr = self.client.exec_command(command)
            return stdout.read().decode(), stderr.read().decode()
        except paramiko.SSHException as e:
            raise RuntimeError(f"Failed to execute command: {str(e)}")

    def close(self):
        self.client.close()

class CommandThread(QThread):
    output_ready = pyqtSignal(str)
    error_ready = pyqtSignal(str)

    def __init__(self, client, command):
        super().__init__()
        self.client = client
        self.command = command

    def run(self):
        try:
            stdout, stderr = self.client.execute_command(self.command)
            if stdout:
                self.output_ready.emit(stdout)
            if stderr:
                self.error_ready.emit(stderr)
        except Exception as e:
            self.error_ready.emit(str(e))

class SSHToolCredentialManager(QMainWindow):
    def __init__(self, connection_manager, parent=None):
        super().__init__(parent)
        self.connection_manager = connection_manager
        self.initUI()
        self.load_connections()

    def initUI(self):
        self.setWindowTitle("SSH Credential Manager")
        self.setGeometry(100, 100, 400, 400)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        self.connection_list = QComboBox()
        self.connection_list.currentIndexChanged.connect(self.populate_fields)
        layout.addWidget(self.connection_list)

        form_layout = QFormLayout()

        self.name_input = QLineEdit()
        self.hostname_input = QLineEdit()
        self.port_input = QLineEdit()
        self.username_input = QLineEdit()
        self.auth_method_input = QComboBox()
        self.auth_method_input.addItems(["Password", "Private Key"])
        self.password_input = QLineEdit()
        self.private_key_input = QLineEdit()

        form_layout.addRow("Name:", self.name_input)
        form_layout.addRow("Hostname:", self.hostname_input)
        form_layout.addRow("Port:", self.port_input)
        form_layout.addRow("Username:", self.username_input)
        form_layout.addRow("Authentication Method:", self.auth_method_input)
        form_layout.addRow("Password:", self.password_input)
        form_layout.addRow("Private Key File:", self.private_key_input)

        button_layout = QHBoxLayout()
        self.add_button = QPushButton("Add Connection")
        self.add_button.clicked.connect(self.add_connection)
        self.edit_button = QPushButton("Edit Connection")
        self.edit_button.clicked.connect(self.show_edit_connection_dialog)
        self.delete_button = QPushButton("Delete Connection")
        self.delete_button.clicked.connect(self.delete_connection)
        button_layout.addWidget(self.add_button)
        button_layout.addWidget(self.edit_button)
        button_layout.addWidget(self.delete_button)

        layout.addLayout(form_layout)
        layout.addLayout(button_layout)

    def load_connections(self):
        connections = self.connection_manager.list_connections()
        self.connection_list.clear()
        for conn in connections:
            self.connection_list.addItem(conn[1], conn)

    def populate_fields(self):
        connection = self.connection_list.currentData()
        if connection:
            self.name_input.setText(connection[1])
            self.hostname_input.setText(connection[2])
            self.port_input.setText(str(connection[3]))
            self.username_input.setText(connection[4])
            self.auth_method_input.setCurrentText(connection[5])
            self.password_input.setText(connection[6] if connection[5] == "Password" else "")
            self.private_key_input.setText(connection[7] if connection[5] == "Private Key" else "")

    def add_connection(self):
        try:
            name = self.name_input.text()
            hostname = self.hostname_input.text()
            port = int(self.port_input.text())
            username = self.username_input.text()
            auth_method = self.auth_method_input.currentText()
            password = self.password_input.text()
            private_key_file = self.private_key_input.text()
            self.connection_manager.add_connection(name, hostname, port, username, auth_method, password, private_key_file)
            self.load_connections()
        except ValueError:
            QMessageBox.critical(self, "Error", "Invalid port number.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to add connection: {str(e)}")

    def show_edit_connection_dialog(self):
        connection = self.connection_list.currentData()
        if connection:
            dialog = QDialog(self)
            dialog.setWindowTitle("Edit Connection")
            dialog.setGeometry(100, 100, 400, 200)

            form_layout = QFormLayout(dialog)

            name_input = QLineEdit(connection[1])
            hostname_input = QLineEdit(connection[2])
            port_input = QLineEdit(str(connection[3]))
            username_input = QLineEdit(connection[4])
            auth_method_input = QComboBox()
            auth_method_input.addItems(["Password", "Private Key"])
            auth_method_input.setCurrentText(connection[5])
            password_input = QLineEdit(connection[6] if connection[5] == "Password" else "")
            private_key_input = QLineEdit(connection[7] if connection[5] == "Private Key" else "")

            form_layout.addRow("Name:", name_input)
            form_layout.addRow("Hostname:", hostname_input)
            form_layout.addRow("Port:", port_input)
            form_layout.addRow("Username:", username_input)
            form_layout.addRow("Authentication Method:", auth_method_input)
            form_layout.addRow("Password:", password_input)
            form_layout.addRow("Private Key File:", private_key_input)

            button_layout = QHBoxLayout()
            save_button = QPushButton("Save")
            save_button.clicked.connect(lambda: self.edit_connection(
                connection[0], name_input.text(), hostname_input.text(), port_input.text(), username_input.text(),
                auth_method_input.currentText(), password_input.text(), private_key_input.text(), dialog
            ))
            cancel_button = QPushButton("Cancel")
            cancel_button.clicked.connect(dialog.reject)
            button_layout.addWidget(save_button)
            button_layout.addWidget(cancel_button)

            form_layout.addRow(button_layout)
            dialog.exec_()

    def edit_connection(self, conn_id, name, hostname, port, username, auth_method, password, private_key_file, dialog):
        try:
            port = int(port)
            self.connection_manager.update_connection(conn_id, name, hostname, port, username, auth_method, password, private_key_file)
            self.load_connections()
            dialog.accept()
        except ValueError:
            QMessageBox.critical(self, "Error", "Invalid port number.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to update connection: {str(e)}")

    def delete_connection(self):
        connection = self.connection_list.currentData()
        if connection:
            conn_id = connection[0]
            try:
                self.connection_manager.delete_connection(conn_id)
                self.load_connections()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to delete connection: {str(e)}")

class SSHToolUserManager:
    def __init__(self, db_path="ssh_users.db"):
        self.conn = sqlite3.connect(db_path)
        self.create_table()

    def create_table(self):
        query = """
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT NOT NULL,
            password TEXT NOT NULL
        );
        """
        self.conn.execute(query)
        self.conn.commit()

    def add_user(self, username, password):
        query = """
        INSERT INTO users (username, password)
        VALUES (?, ?)
        """
        self.conn.execute(query, (username, password))
        self.conn.commit()

    def update_user(self, username, new_password):
        query = """
        UPDATE users
        SET password = ?
        WHERE username = ?
        """
        self.conn.execute(query, (new_password, username))
        self.conn.commit()

    def delete_user(self, username):
        query = "DELETE FROM users WHERE username = ?"
        self.conn.execute(query, (username,))
        self.conn.commit()

    def list_users(self):
        query = "SELECT * FROM users"
        cursor = self.conn.execute(query)
        return cursor.fetchall()

class SSHServerThread(QThread):
    log_signal = pyqtSignal(str)
    error_signal = pyqtSignal(str)

    def __init__(self, ip, port, banner, user_manager):
        super().__init__()
        self.ip = ip
        self.port = port
        self.banner = banner
        self.user_manager = user_manager
        self.server = None
        self.running = True

    def run(self):
        try:
            self.server = paramiko.Transport((self.ip, self.port))
            self.server.banner = self.banner
            self.server.add_server_key(paramiko.RSAKey.generate(2048))

            class SSHServer(paramiko.ServerInterface):
                def __init__(self, user_manager):
                    self.user_manager = user_manager

                def check_auth_password(self, username, password):
                    users = self.user_manager.list_users()
                    for user in users:
                        if user[1] == username and user[2] == password:
                            return paramiko.AUTH_SUCCESSFUL
                    return paramiko.AUTH_FAILED

            server = SSHServer(self.user_manager)
            self.server.start_server(server=server)
            self.log_signal.emit(f"Server started on {self.ip}:{self.port}")

            while self.running:
                channel = self.server.accept()
                if channel is None:
                    break
                channel.send(self.banner)
                while self.running:
                    command = channel.recv(1024)
                    if not command:
                        break
                    channel.send(f"Received: {command.decode('utf-8')}")
                if not self.running:
                    break

        except paramiko.SSHException as e:
            self.error_signal.emit(f"SSH Exception: {str(e)}")
        except Exception as e:
            self.error_signal.emit(f"Error: {str(e)}")
        finally:
            if self.server:
                self.server.close()
            self.log_signal.emit("Server stopped")

    def stop(self):
        self.running = False
        if self.server:
            self.server.close()
            
class SSHToolServerManager(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.user_manager = SSHToolUserManager()
        self.server_thread = None
        self.initUI()

    def initUI(self):
        self.setWindowTitle("SSH Server Manager")
        self.setGeometry(100, 100, 400, 400)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        layout.addWidget(self.console)

        form_layout = QFormLayout()

        self.ip_input = QLineEdit()
        self.ip_input.setText("127.0.0.1")
        self.port_input = QLineEdit()
        self.port_input.setText("22")
        self.banner_input = QLineEdit()

        form_layout.addRow("IP Address", self.ip_input)
        form_layout.addRow("Port", self.port_input)
        form_layout.addRow("Banner", self.banner_input)

        layout.addLayout(form_layout)

        self.toggle_button = QPushButton("Start Server")
        self.toggle_button.setCheckable(True)
        self.toggle_button.toggled.connect(self.toggle_server)
        layout.addWidget(self.toggle_button)

        self.user_list = QListWidget()
        layout.addWidget(self.user_list)

        self.add_user_button = QPushButton("Add User")
        self.add_user_button.clicked.connect(self.add_user)
        self.edit_user_button = QPushButton("Edit User")
        self.edit_user_button.clicked.connect(self.edit_user)
        self.delete_user_button = QPushButton("Delete User")
        self.delete_user_button.clicked.connect(self.delete_user)
        user_button_layout = QHBoxLayout()
        user_button_layout.addWidget(self.add_user_button)
        user_button_layout.addWidget(self.edit_user_button)
        user_button_layout.addWidget(self.delete_user_button)
        layout.addLayout(user_button_layout)

        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)

        self.load_users()

    def toggle_server(self, checked):
        if checked:
            try:
                ip = self.ip_input.text()
                port = int(self.port_input.text())
                banner = self.banner_input.text()
                self.server_thread = SSHServerThread(ip, port, banner, self.user_manager)
                self.server_thread.log_signal.connect(self.console.append)
                self.server_thread.error_signal.connect(self.show_error)
                self.server_thread.start()
                self.console.append(f"Server started at {ip}:{port}")
                self.toggle_button.setText("Stop Server")
                self.status_bar.showMessage("Server is running")
            except ValueError as e:
                QMessageBox.critical(self, "Error", f"Invalid port number: {str(e)}")
                self.toggle_button.setChecked(False)
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to start server: {str(e)}")
                self.toggle_button.setChecked(False)
        else:
            if self.server_thread:
                self.server_thread.stop()
                self.server_thread.wait()
                self.console.append("Server stopped")
                self.toggle_button.setText("Start Server")
                self.status_bar.showMessage("Server is stopped")

    def show_error(self, error):
        self.console.append(f"<span style='color:red'>{error}</span>")
        if "actively refused it" in error:
            reply = QMessageBox.question(
                self, 'Firewall Rule', 'Connection was refused. Do you want to add a firewall rule for this port?',
                QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes
            )
            if reply == QMessageBox.Yes:
                port = self.port_input.text()
                try:
                    subprocess.check_call(["netsh", "advfirewall", "firewall", "add", "rule", f"name=SSHServer port={port} protocol=TCP action=allow"])
                    QMessageBox.information(self, "Firewall Rule", "Firewall rule added successfully.")
                except subprocess.CalledProcessError as e:
                    QMessageBox.critical(self, "Firewall Rule Error", f"Failed to add firewall rule: {str(e)}")

    def load_users(self):
        users = self.user_manager.list_users()
        self.user_list.clear()
        for user in users:
            self.user_list.addItem(f"{user[1]}")

    def add_user(self):
        name, ok = QInputDialog.getText(self, "Add User", "Enter username:")
        if ok and name:
            password, ok = QInputDialog.getText(self, "Add User", "Enter password:")
            if ok and password:
                self.user_manager.add_user(name, password)
                self.load_users()

    def edit_user(self):
        name, ok = QInputDialog.getText(self, "Edit User", "Enter username to edit:")
        if ok and name:
            new_password, ok = QInputDialog.getText(self, "Edit User", "Enter new password:")
            if ok and new_password:
                self.user_manager.update_user(name, new_password)
                self.load_users()

    def delete_user(self):
        name, ok = QInputDialog.getText(self, "Delete User", "Enter username to delete:")
        if ok and name:
            self.user_manager.delete_user(name)
            self.load_users()

class SSHToolMainWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection_manager = SSHToolConnectionManager()
        self.initUI()
        self.tab_count = 0

    def initUI(self):
        self.setLayout(QVBoxLayout(self))

        # Create a scroll area and set its properties
        self.scroll_area = QScrollArea(self)
        self.scroll_area.setWidgetResizable(True)

        # Create a central widget for the scroll area
        self.central_widget = QWidget()
        self.central_layout = QVBoxLayout(self.central_widget)

        # Add the connection dropdown
        self.connection_dropdown = QComboBox()
        self.load_connections()
        self.central_layout.addWidget(QLabel("Saved Connections"))
        self.central_layout.addWidget(self.connection_dropdown)

        # Add the tabs
        self.tabs = QTabWidget()
        self.central_layout.addWidget(self.tabs)

        # Create button frame
        self.button_frame = QGroupBox("Controls")
        button_layout = QHBoxLayout()

        self.new_ssh_tab_button = QPushButton("New SSH Tab")
        self.new_ssh_tab_button.clicked.connect(self.open_new_ssh_tab)
        button_layout.addWidget(self.new_ssh_tab_button)

        self.manage_credentials_button = QPushButton("Manage Credentials")
        self.manage_credentials_button.clicked.connect(self.open_credential_manager)
        button_layout.addWidget(self.manage_credentials_button)

        self.ssh_server_button = QPushButton("SSH Server")
        self.ssh_server_button.clicked.connect(self.open_ssh_server_manager)
        button_layout.addWidget(self.ssh_server_button)

        self.button_frame.setLayout(button_layout)

        self.toggle_button = QCheckBox("Show/Hide Buttons")
        self.toggle_button.setChecked(True)
        self.toggle_button.stateChanged.connect(self.toggle_buttons)
        self.central_layout.addWidget(self.toggle_button)
        self.central_layout.addWidget(self.button_frame)

        # Set the central widget as the widget of the scroll area
        self.scroll_area.setWidget(self.central_widget)

        # Add the scroll area to the main layout
        self.layout().addWidget(self.scroll_area)

    def load_connections(self):
        connections = self.connection_manager.list_connections()
        self.connection_dropdown.clear()
        for conn in connections:
            self.connection_dropdown.addItem(conn[1], conn)

    def open_new_ssh_tab(self):
        self.tab_count += 1
        tab_name = f"SSH Tab {self.tab_count}"
        connection = self.connection_dropdown.currentData()
        if connection:
            new_tab = SSHToolSessionTab(connection, tab_name)
            new_tab.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            index = self.tabs.addTab(new_tab, tab_name)
            self.tabs.setCurrentIndex(index)

    def open_credential_manager(self):
        self.credential_manager = SSHToolCredentialManager(self.connection_manager, self)
        self.credential_manager.show()

    def open_ssh_server_manager(self):
        self.ssh_server_manager = SSHToolServerManager(self)
        self.ssh_server_manager.show()

    def close_tab(self, index):
        widget = self.tabs.widget(index)
        if widget is not None:
            widget.close_tab()
        self.tabs.removeTab(index)

    def toggle_buttons(self):
        if self.toggle_button.isChecked():
            self.button_frame.show()
        else:
            self.button_frame.hide()

    def show_tab_context_menu(self, pos):
        menu = QMenu()
        rename_action = menu.addAction("Rename Tab")
        action = menu.exec_(self.tabs.mapToGlobal(pos))
        if action == rename_action:
            self.rename_tab(self.tabs.currentIndex())

    def rename_tab(self, index):
        new_name, ok = QInputDialog.getText(self, 'Rename Tab', 'Enter new tab name:')
        if ok and new_name:
            self.tabs.setTabText(index, new_name)

class SSHToolSessionTab(QWidget):
    def __init__(self, connection, tab_name, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.tab_name = tab_name
        self.client = None
        self.pop_out_window = None
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout()

        self.output = QTextEdit()
        self.output.setReadOnly(True)
        self.output.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        layout.addWidget(self.output)

        self.command_input = QLineEdit()
        self.command_input.returnPressed.connect(self.send_command)
        self.command_input.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        layout.addWidget(self.command_input)

        button_layout = QHBoxLayout()
        buttons = [
            ("Save Log", self.save_log),
            ("Copy Log", self.copy_log),
            ("Pop Out", self.pop_out),
            ("Close Tab", self.close_tab)
        ]

        for button_text, button_function in buttons:
            button = QPushButton(button_text)
            button.clicked.connect(button_function)
            button_layout.addWidget(button)

        layout.addLayout(button_layout)
        self.setLayout(layout)

        # Initialize SSH connection
        self.init_connection()

    def init_connection(self):
        try:
            hostname = self.connection[2]
            port = self.connection[3]
            username = self.connection[4]
            auth_method = self.connection[5]
            password = self.connection[6] if self.connection[5] == "Password" else None
            private_key_file = self.connection[7] if self.connection[5] == "Private Key" else None

            self.client = SSHToolClient(hostname, port, username, password, private_key_file)
            self.client.connect()
            self.output.append(f"Connected to {hostname}:{port} as {username}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to connect: {str(e)}")

    def send_command(self):
        command = self.command_input.text()
        if command:
            self.command_thread = CommandThread(self.client, command)
            self.command_thread.output_ready.connect(self.append_output)
            self.command_thread.error_ready.connect(self.append_error)
            self.command_thread.start()
            self.command_input.clear()

    def append_output(self, output):
        self.output.append(output)

    def append_error(self, error):
        self.output.append(f"<span style='color:red'>{error}</span>")

    def save_log(self):
        options = QFileDialog.Options()
        file_name, _ = QFileDialog.getSaveFileName(self, "Save Log", "", "Text Files (*.txt);;All Files (*)", options=options)
        if file_name:
            try:
                with open(file_name, 'w') as file:
                    file.write(self.output.toPlainText())
                QMessageBox.information(self, "Success", "Log saved successfully.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save log: {str(e)}")

    def copy_log(self):
        QApplication.clipboard().setText(self.output.toPlainText())
        QMessageBox.information(self, "Success", "Log copied to clipboard.")

    def pop_out(self):
        if self.pop_out_window is None:
            pop_out_title = f"SSH - {self.tab_name}"
            self.pop_out_window = SSHToolPopOutWindow(pop_out_title, self.output.toPlainText(), self.client, self)
            self.pop_out_window.show()
            self.hide()

    def reintegrate_tab(self):
        if self.pop_out_window:
            self.pop_out_window.close()
            self.pop_out_window = None
            self.show()

    def close_tab(self):
        try:
            if self.client:
                self.client.close()
            if self.pop_out_window:
                self.pop_out_window.close()
            self.deleteLater()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to close tab: {str(e)}")

class SSHToolPopOutWindow(QMainWindow):
    def __init__(self, title, initial_text, client, tab, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.client = client
        self.tab = tab
        self.initUI(initial_text)

    def initUI(self, initial_text):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        self.output_widget = QTextEdit()
        self.output_widget.setReadOnly(True)
        self.output_widget.setPlainText(initial_text)
        layout.addWidget(self.output_widget)

        self.input_widget = QLineEdit()
        self.input_widget.returnPressed.connect(self.send_command)
        layout.addWidget(self.input_widget)

        self.resize(800, 600)

    def send_command(self):
        command = self.input_widget.text()
        if command and self.client and self.client.client.get_transport().is_active():
            self.command_thread = CommandThread(self.client, command)
            self.command_thread.output_ready.connect(self.append_output)
            self.command_thread.error_ready.connect(self.append_error)
            self.command_thread.start()
            self.input_widget.clear()

    def append_output(self, output):
        self.output_widget.append(output)

    def append_error(self, error):
        self.output_widget.append(f"<span style='color:red'>{error}</span>")

    def closeEvent(self, event):
        reply = QMessageBox.question(
            self, 'Close Window', 'Do you want to close the tab too?',
            QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel, QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            self.tab.close_tab()
            event.accept()
        elif reply == QMessageBox.No:
            try:
                self.tab.reintegrate_tab()
                event.accept()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to reintegrate tab: {str(e)}")
                event.ignore()
        else:
            event.ignore()
# SSH Widget END #

# Terminal Widget START #
class CommandPromptTab(QWidget):
    def __init__(self, parent=None, admin=False, powershell=False, tab_name=""):
        super().__init__(parent)
        self.admin = admin
        self.powershell = powershell
        self.tab_name = tab_name if tab_name else self.generate_default_tab_name()
        self.process = None
        self.pop_out_window = None
        self.original_parent = None
        self.original_index = None
        self.initUI()

    def generate_default_tab_name(self):
        if self.admin:
            return "Admin PowerShell" if self.powershell else "Admin CMD"
        else:
            return "PowerShell" if self.powershell else "CMD"

    def initUI(self):
        layout = QVBoxLayout()

        self.output = QTextEdit()
        self.output.setReadOnly(True)
        self.output.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        layout.addWidget(self.output)

        self.command_input = QLineEdit()
        self.command_input.returnPressed.connect(self.send_command)
        self.command_input.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        layout.addWidget(self.command_input)

        button_layout = QHBoxLayout()
        buttons = [
            ("Save Log", self.save_log),
            ("Copy Log", self.copy_log),
            ("Pop Out", self.pop_out),
            ("Close Tab", self.close_tab)
        ]

        for button_text, button_function in buttons:
            button = QPushButton(button_text)
            button.clicked.connect(button_function)
            button_layout.addWidget(button)

        layout.addLayout(button_layout)
        self.setLayout(layout)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        self.start_process()

    def start_process(self):
        self.process = QProcess(self)
        self.process.readyReadStandardOutput.connect(self.on_ready_read_standard_output)
        self.process.readyReadStandardError.connect(self.on_ready_read_standard_error)
        self.process.errorOccurred.connect(self.on_error_occurred)
        self.process.finished.connect(self.on_process_finished)

        try:
            if self.admin:
                if self.powershell:
                    self.process.start("powershell", ["-Command", "Start-Process", "powershell", "-Verb", "RunAs"])
                else:
                    self.process.start("powershell", ["-Command", "Start-Process", "cmd", "-Verb", "RunAs"])
            else:
                self.process.start("powershell" if self.powershell else "cmd")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to start command prompt: {str(e)}")

    def send_command(self):
        command = self.command_input.text()
        if command:
            try:
                self.process.write((command + '\n').encode())
                self.command_input.clear()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to send command: {str(e)}")

    def on_ready_read_standard_output(self):
        output = self.process.readAllStandardOutput().data().decode()
        self.output.moveCursor(QTextCursor.End)
        self.output.insertPlainText(output)
        self.output.moveCursor(QTextCursor.End)
        if self.pop_out_window:
            self.pop_out_window.update_output(output)

    def on_ready_read_standard_error(self):
        error = self.process.readAllStandardError().data().decode()
        self.output.moveCursor(QTextCursor.End)
        self.output.insertHtml(f"<span style='color:red'>{error}</span>")
        self.output.moveCursor(QTextCursor.End)
        if self.pop_out_window:
            self.pop_out_window.update_error(error)

    def on_error_occurred(self, error):
        error_message = {
            QProcess.FailedToStart: "Failed to start the process.",
            QProcess.Crashed: "The process crashed.",
            QProcess.Timedout: "The process timed out.",
            QProcess.WriteError: "An error occurred when writing to the process.",
            QProcess.ReadError: "An error occurred when reading from the process.",
            QProcess.UnknownError: "An unknown error occurred."
        }.get(error, "An unknown error occurred.")
        QMessageBox.critical(self, "Error", error_message)

    def on_process_finished(self, exit_code, exit_status):
        self.output.append(f"Process finished with exit code {exit_code}")

    def save_log(self):
        options = QFileDialog.Options()
        file_name, _ = QFileDialog.getSaveFileName(self, "Save Log", "", "Text Files (*.txt);;All Files (*)", options=options)
        if file_name:
            try:
                with open(file_name, 'w') as file:
                    file.write(self.output.toPlainText())
                QMessageBox.information(self, "Success", "Log saved successfully.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save log: {str(e)}")

    def copy_log(self):
        QApplication.clipboard().setText(self.output.toPlainText())
        QMessageBox.information(self, "Success", "Log copied to clipboard.")

    def pop_out(self):
        if self.pop_out_window is None:
            self.original_parent = self.parentWidget()
            self.original_index = self.original_parent.indexOf(self)
            pop_out_title = f"{'Admin ' if self.admin else ''}{'PowerShell' if self.powershell else 'CMD'} - {self.tab_name}"
            self.pop_out_window = CMDPopOutWindow(pop_out_title, self.output.toPlainText(), self.process, self)
            self.pop_out_window.show()
            self.hide()

    def reintegrate_tab(self):
        if self.pop_out_window:
            self.pop_out_window.close()
            self.pop_out_window = None
            self.show()
            if isinstance(self.original_parent, QTabWidget):
                self.original_parent.insertTab(self.original_index, self, self.tab_name)
                self.original_parent.setCurrentIndex(self.original_index)
            elif isinstance(self.original_parent, QStackedWidget):
                self.original_parent.insertWidget(self.original_index, self)
                self.original_parent.setCurrentIndex(self.original_index)
            else:
                QMessageBox.warning(self, "Reintegration Failed", "Unable to reintegrate tab to its original location.")

    def close_tab(self):
        try:
            if self.process and self.process.state() == QProcess.Running:
                self.process.kill()
            if self.pop_out_window:
                self.pop_out_window.close()
            self.deleteLater()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to close tab: {str(e)}")

    def closeEvent(self, event):
        self.close_tab()
        event.accept()

class CMDPopOutWindow(QMainWindow):
    def __init__(self, title, initial_text, process, tab, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.process = process
        self.tab = tab
        self.initUI(initial_text)

    def initUI(self, initial_text):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        self.output_widget = QTextEdit()
        self.output_widget.setReadOnly(True)
        self.output_widget.setPlainText(initial_text)
        layout.addWidget(self.output_widget)

        self.input_widget = QLineEdit()
        self.input_widget.returnPressed.connect(self.send_command)
        layout.addWidget(self.input_widget)

        self.resize(800, 600)

    def send_command(self):
        command = self.input_widget.text()
        if command and self.process and self.process.state() == QProcess.Running:
            try:
                self.process.write(f"{command}\n".encode())
                self.input_widget.clear()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to send command: {str(e)}")

    def update_output(self, output):
        self.output_widget.moveCursor(QTextCursor.End)
        self.output_widget.insertPlainText(output)
        self.output_widget.moveCursor(QTextCursor.End)

    def update_error(self, error):
        self.output_widget.moveCursor(QTextCursor.End)
        self.output_widget.insertHtml(f"<span style='color:red'>{error}</span>")
        self.output_widget.moveCursor(QTextCursor.End)

    def closeEvent(self, event):
        reply = QMessageBox.question(
            self, 'Close Window', 'Do you want to close the tab too?',
            QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel, QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            self.tab.close_tab()
            event.accept()
        elif reply == QMessageBox.No:
            try:
                self.tab.reintegrate_tab()
                event.accept()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to reintegrate tab: {str(e)}")
                event.ignore()
        else:
            event.ignore()

class CommandPromptWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.initUI()
        self.tab_count = 0

    def initUI(self):
        layout = QVBoxLayout()

        self.tabs = QTabWidget()
        self.tabs.setTabsClosable(True)
        self.tabs.tabCloseRequested.connect(self.close_tab)
        self.tabs.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tabs.customContextMenuRequested.connect(self.show_tab_context_menu)
        layout.addWidget(self.tabs)

        self.button_frame = QGroupBox("Controls")
        button_layout = QVBoxLayout()

        shell_buttons_layout = QHBoxLayout()
        self.new_cmd_tab_button = QPushButton("New CMD Tab")
        self.new_cmd_tab_button.clicked.connect(self.open_new_cmd_tab)
        shell_buttons_layout.addWidget(self.new_cmd_tab_button)

        self.new_powershell_tab_button = QPushButton("New PowerShell Tab")
        self.new_powershell_tab_button.clicked.connect(self.open_new_powershell_tab)
        shell_buttons_layout.addWidget(self.new_powershell_tab_button)
        button_layout.addLayout(shell_buttons_layout)

        admin_buttons_layout = QHBoxLayout()
        self.new_admin_cmd_button = QPushButton("Admin CMD Window")
        self.new_admin_cmd_button.clicked.connect(self.open_admin_cmd_window)
        admin_buttons_layout.addWidget(self.new_admin_cmd_button)

        self.new_admin_powershell_button = QPushButton("Admin PowerShell Window")
        self.new_admin_powershell_button.clicked.connect(self.open_admin_powershell_window)
        admin_buttons_layout.addWidget(self.new_admin_powershell_button)
        button_layout.addLayout(admin_buttons_layout)

        self.button_frame.setLayout(button_layout)

        self.toggle_button = QCheckBox("Show/Hide Buttons")
        self.toggle_button.setChecked(True)
        self.toggle_button.stateChanged.connect(self.toggle_buttons)
        layout.addWidget(self.toggle_button)
        layout.addWidget(self.button_frame)

        self.setLayout(layout)

    def open_new_cmd_tab(self):
        self.tab_count += 1
        tab_name = f"CMD Tab {self.tab_count}"
        new_tab = CommandPromptTab(tab_name=tab_name)
        new_tab.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        index = self.tabs.addTab(new_tab, tab_name)
        self.tabs.setCurrentIndex(index)

    def open_new_powershell_tab(self):
        self.tab_count += 1
        tab_name = f"PowerShell Tab {self.tab_count}"
        new_tab = CommandPromptTab(powershell=True, tab_name=tab_name)
        new_tab.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        index = self.tabs.addTab(new_tab, tab_name)
        self.tabs.setCurrentIndex(index)

    def open_admin_cmd_window(self):
        try:
            subprocess.run(["powershell", "-Command", "Start-Process", "cmd", "-Verb", "RunAs"])
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to open admin CMD: {str(e)}")

    def open_admin_powershell_window(self):
        try:
            subprocess.run(["powershell", "-Command", "Start-Process", "powershell", "-Verb", "RunAs"])
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to open admin PowerShell: {str(e)}")

    def close_tab(self, index):
        widget = self.tabs.widget(index)
        if widget is not None:
            widget.close_tab()
        self.tabs.removeTab(index)

    def toggle_buttons(self):
        if self.toggle_button.isChecked():
            self.button_frame.show()
        else:
            self.button_frame.hide()

    def show_tab_context_menu(self, pos):
        menu = QMenu()
        rename_action = menu.addAction("Rename Tab")
        action = menu.exec_(self.tabs.mapToGlobal(pos))
        if action == rename_action:
            self.rename_tab(self.tabs.currentIndex())

    def rename_tab(self, index):
        new_name, ok = QInputDialog.getText(self, 'Rename Tab', 'Enter new tab name:')
        if ok and new_name:
            self.tabs.setTabText(index, new_name)
# Terminal Widget END #

class OtherOptionsWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)
        # Add buttons for other options
        self.setLayout(layout)

# AI Chat Widget START #
class PopOutChatWindow(QMainWindow):
    closed = pyqtSignal(str, dict)  # Emit the tab name and chat data when closed

    def __init__(self, parent, tab_name, chat_data):
        super().__init__(parent)
        self.parent_widget = parent
        self.setWindowTitle(f"Detached Chat - {tab_name}")
        self.tab_name = tab_name
        self.db_file = "api_keys.db"
        self.chat_data = chat_data
        self.chat_widget = self.create_chat_widget()
        self.setCentralWidget(self.chat_widget)
        self.resize(600, 800)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.ensure_api_keys_table_exists()

    def on_api_type_changed(self, api_type_dropdown, model_dropdown):
        api_type = api_type_dropdown.currentText()
        model_dropdown.clear()
        if api_type in ACTIVE_MODELS:
            model_dropdown.addItems(ACTIVE_MODELS[api_type])

    def create_chat_widget(self):
        chat_widget = QWidget()
        layout = QVBoxLayout(chat_widget)

        # Collapsible settings area
        settings_area = QGroupBox("Settings")
        settings_area.setCheckable(True)
        settings_area.setChecked(True)
        settings_area.toggled.connect(lambda checked: settings_content.setVisible(checked))
        settings_layout = QVBoxLayout()

        settings_content = QWidget()
        content_layout = QVBoxLayout(settings_content)

        # Add streaming checkbox inside settings
        #self.streaming_checkbox = QCheckBox("Enable Streaming")
        #self.streaming_checkbox.setChecked(False)
        #content_layout.addWidget(self.streaming_checkbox)

        # API Key area
        api_key_layout = QHBoxLayout()
        api_key_label = QLabel("API Key:")
        api_key_label.setFixedWidth(50)
        self.api_key_edit = QComboBox()
        self.api_key_edit.setEditable(True)
        self.api_key_edit.setMaximumHeight(30)
        self.api_key_edit.setPlaceholderText("Enter your API key")
        self.load_api_keys()  # Ensure API keys are loaded
        save_api_button = QPushButton("Save")
        delete_api_button = QPushButton("Delete")
        save_api_button.setMaximumHeight(30)
        delete_api_button.setMaximumHeight(30)
        save_api_button.setFixedWidth(50)
        delete_api_button.setFixedWidth(50)
        save_api_button.clicked.connect(lambda: self.parent_widget.save_api_key(self.api_key_edit))
        delete_api_button.clicked.connect(lambda: self.parent_widget.delete_api_key(self.api_key_edit))
        api_key_layout.addWidget(api_key_label)
        api_key_layout.addWidget(self.api_key_edit)
        api_key_layout.addWidget(save_api_button)
        api_key_layout.addWidget(delete_api_button)
        content_layout.addLayout(api_key_layout)

        # Model, API Type, and Token usage in one line
        model_api_layout = QHBoxLayout()
        model_label = QLabel("Model:")
        model_label.setFixedWidth(50)
        self.model_dropdown = QComboBox()
        self.model_dropdown.setMaximumHeight(30)

        api_type_label = QLabel("API Type:")
        api_type_label.setFixedWidth(60)
        self.api_type_dropdown = QComboBox()
        self.api_type_dropdown.setMaximumHeight(30)
        self.api_type_dropdown.addItems(ACTIVE_MODELS.keys())
        self.api_type_dropdown.currentIndexChanged.connect(lambda: self.on_api_type_changed(self.api_type_dropdown, self.model_dropdown))

        self.token_usage_label = QLabel("Tokens: 0")
        self.token_usage_label.setFixedWidth(80)
        self.token_usage_label.setMaximumHeight(30)

        model_api_layout.addWidget(model_label)
        model_api_layout.addWidget(self.model_dropdown)
        model_api_layout.addWidget(api_type_label)
        model_api_layout.addWidget(self.api_type_dropdown)
        model_api_layout.addWidget(self.token_usage_label)

        content_layout.addLayout(model_api_layout)

        settings_content.setLayout(content_layout)
        settings_layout.addWidget(settings_content)
        settings_area.setLayout(settings_layout)
        layout.addWidget(settings_area)

        # Chat area
        self.chat_scroll = QScrollArea()
        self.chat_scroll.setWidgetResizable(True)
        self.chat_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.chat_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)

        self.chat_area = QWidget()
        self.chat_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.chat_layout = QVBoxLayout(self.chat_area)
        self.chat_layout.setAlignment(Qt.AlignTop)
        self.chat_scroll.setWidget(self.chat_area)
        layout.addWidget(self.chat_scroll)

        # Input area
        input_layout = QHBoxLayout()
        self.chat_input = QTextEdit()
        self.chat_input.setPlaceholderText("Type your message here...")
        self.chat_input.setFont(QFont("Arial", 12))
        self.chat_input.setMaximumHeight(50)
        self.chat_input.setWordWrapMode(QTextOption.WordWrap)
        self.chat_input.textChanged.connect(lambda: self.parent_widget.update_token_usage(self.chat_input, self.token_usage_label))
        self.chat_input.installEventFilter(self)  # Add this line to install the event filter
        send_button = QPushButton("Send")
        send_button.setMaximumHeight(50)
        send_button.clicked.connect(self.submit_user_input)
        input_layout.addWidget(self.chat_input)
        input_layout.addWidget(send_button)
        layout.addLayout(input_layout)

        # Typing indicator
        self.typing_indicator = QLabel("Assistant is typing...")
        self.typing_indicator.setStyleSheet("color: #999999; font-style: italic;")
        self.typing_indicator.hide()
        layout.addWidget(self.typing_indicator)

        # Load initial chat data
        self.load_chat_data(self.chat_data)

        return chat_widget

    def load_api_keys(self):
        try:
            conn = sqlite3.connect(self.parent_widget.db_file)
            cursor = conn.cursor()
            cursor.execute("SELECT name, key, added, last_used FROM api_keys")
            keys = cursor.fetchall()
            self.api_key_edit.clear()
            for key in keys:
                name, key_value, added, last_used = key
                key_entry = f"{name} (****{key_value[-4:]}) - Added: {added} - Last Used: {last_used}"
                self.api_key_edit.addItem(key_entry)
            conn.close()
        except sqlite3.Error as e:
            print(f"Error: Failed to load API keys: {str(e)}")
            QMessageBox.critical(self, "Database Error", f"Failed to load API keys for PopOut Chat: {str(e)}")
        except Exception as e:
            print(f"Error: An unexpected error occurred while loading API keys: {str(e)}")
            QMessageBox.critical(self, "Error", f"An unexpected error occurred while loading API keys: {str(e)}")

    def ensure_api_keys_table_exists(self):
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS api_keys (
                name TEXT,
                key TEXT,
                added TEXT,
                last_used TEXT
            )
        ''')
        conn.commit()
        conn.close()

    def load_chat_data(self, chat_data):
        self.api_key_edit.setEditText(chat_data.get("api_key", ""))
        self.model_dropdown.addItems(chat_data.get("model_options", []))
        self.model_dropdown.setCurrentText(chat_data.get("selected_model", ""))
        self.api_type_dropdown.addItems(chat_data.get("api_type_options", []))
        self.api_type_dropdown.setCurrentText(chat_data.get("selected_api_type", ""))
        self.chat_layout.setAlignment(Qt.AlignTop)
        self.clear_chat_area()
        for message in chat_data.get("messages", []):
            if message.get("is_image"):
                self.add_image_message(message["content"])
            else:
                self.add_message_bubble(message["sender"], message["content"], message.get("is_code", False), message.get("is_image", False))
        self.token_usage_label.setText(f"Tokens: {chat_data.get('token_usage', 0)}")

    def clear_chat_area(self):
        for i in reversed(range(self.chat_layout.count())):
            self.chat_layout.itemAt(i).widget().deleteLater()

    def add_message_bubble(self, sender, message, is_code=False, is_image=False):
        bubble = QWidget()
        bubble_layout = QVBoxLayout(bubble)
        bubble_layout.setContentsMargins(2, 2, 2, 2)  # Adjust margins to fit the content better

        sender_label = QLabel(sender)
        sender_label.setObjectName("sender")
        sender_label.setStyleSheet("font-weight: bold; color: white;")  # Set text color to white

        if is_image:
            message_label = QLabel()
            message_label.setObjectName("message")
            message_label.setPixmap(QPixmap(message).scaled(512, 512, Qt.KeepAspectRatio))
        else:
            message_label = QLabel(message)
            message_label.setObjectName("message")
            message_label.setWordWrap(True)
            message_label.setTextInteractionFlags(Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard)
            message_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Allow vertical expansion
            message_label.setStyleSheet("color: white;")  # Set text color to white

        if is_code:
            message_label.setFont(QFont("Courier", 12))
            message_label.setStyleSheet("background-color: black; color: white; padding: 5px; border-radius: 10px;")
        else:
            message_label.setStyleSheet("background-color: black; color: white; padding: 5px; border-radius: 10px;")

        bubble_layout.addWidget(sender_label)
        bubble_layout.addWidget(message_label)

        # Add buttons for save/download
        button_layout = QHBoxLayout()
        save_button = QPushButton("Save")
        save_button.setObjectName("save_button")
        save_button.setStyleSheet("background-color: #4CAF50; color: white; padding: 5px; border-radius: 5px;")
        save_button.clicked.connect(lambda: self.save_message(message, is_image))

        if is_image:
            download_button = QPushButton("Download")
            download_button.setObjectName("download_button")
            download_button.setStyleSheet("background-color: #2196F3; color: white; padding: 5px; border-radius: 5px;")
            download_button.clicked.connect(lambda: self.download_image(message))
            button_layout.addWidget(download_button)

        button_layout.addWidget(save_button)
        bubble_layout.addLayout(button_layout)

        self.chat_layout.addWidget(bubble)
        bubble.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Minimum)

        return message_label

    def save_message(self, message, is_image):
        if is_image:
            self.save_image(message)
        else:
            self.save_text(message)

    def save_text(self, text):
        file_path, _ = QFileDialog.getSaveFileName(self, "Save Message", "", "Text Files (*.txt)")
        if file_path:
            with open(file_path, "w") as file:
                file.write(text)

    def save_image(self, image_path):
        file_path, _ = QFileDialog.getSaveFileName(self, "Save Image", "", "Image Files (*.png *.jpg *.jpeg)")
        if file_path:
            shutil.copy(image_path, file_path)

    def download_image(self, image_path):
        file_path, _ = QFileDialog.getSaveFileName(self, "Download Image", "", "Image Files (*.png *.jpg *.jpeg)")
        if file_path:
            urllib2.request.urlretrieve(image_path, file_path)

    def closeEvent(self, event):
        self.chat_data = self.collect_chat_data()  # Collect chat data before closing
        self.closed.emit(self.tab_name, self.chat_data)
        super().closeEvent(event)

    def submit_user_input(self):
        user_input = self.chat_input.toPlainText().strip()
        api_key_item_text = self.api_key_edit.currentText()
        api_key = self.parent_widget.retrieve_api_key(api_key_item_text)
        model = self.model_dropdown.currentText()

        if self.parent_widget.show_debug:
            print(f"Debug: Sending API key: {api_key_item_text}")
            print(f"Debug: Full API key: {api_key}")

        if user_input and api_key:
            api_type = self.api_type_dropdown.currentText().lower()
            self.add_message_bubble("You", user_input)
            self.chat_input.clear()
            api_url = self.parent_widget.get_api_url(api_type, model)
            self.api_call_thread = EnhancedAPICallThread(api_type, api_key, model, user_input, api_url)
            self.api_call_thread.finished.connect(self.parent_widget.handle_api_response_wrapper(self.token_usage_label, self))
            self.api_call_thread.start()
            self.parent_widget.update_token_usage(self.chat_input, self.token_usage_label)
            self.show_typing_indicator()
        else:
            QMessageBox.warning(self, "Input Error", "Please enter both a message and an API key.")

    def handle_api_response(self, assistant_response, model, response_info, token_usage_label, current_tab):
        self.hide_typing_indicator(current_tab.typing_indicator)
        if 'status' in response_info and response_info['status'] == 'RESPONSE':
            if model == "dall-e" and assistant_response.startswith("http"):
                self.add_image_message(assistant_response, current_tab)
            else:
                self.add_message_bubble(f"{model} Assistant", assistant_response, self.detect_code_block(assistant_response), tab=current_tab)
            self.parent_widget.add_timestamp(datetime.now().strftime("%Y-%m-%d %H:%M:%S"), current_tab)
            self.message_sent.emit(current_tab.api_type_dropdown.currentText().lower(), assistant_response, response_info)
            token_usage_label.setText(f"Tokens: {response_info['token_usage']}")
        elif 'error' in response_info:
            logging.error(f"API call error: {response_info['error']}")
            QMessageBox.critical(None, "API Error", f"An error occurred: {response_info['error']}")
        else:
            logging.error("Unexpected response structure: " + str(response_info))
            QMessageBox.critical(None, "API Error", "An unexpected error occurred.")

    def add_image_message(self, image_url, tab=None):
        if tab is None:
            tab = self.tabs.currentWidget()
        image_label = QLabel()
        image_label.setObjectName("message")
        image = QImage()
        image.loadFromData(requests.get(image_url).content)
        image_label.setPixmap(QPixmap.fromImage(image).scaled(512, 512, Qt.KeepAspectRatio))
        image_label.setScaledContents(True)
        tab.chat_layout.addWidget(image_label)
        tab.chat_layout.addStretch()

    def show_typing_indicator(self):
        self.typing_indicator.show()

    def hide_typing_indicator(self):
        self.typing_indicator.hide()

    def load_saved_api_keys(self):
        settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
        for key in settings.allKeys():
            self.api_key_edit.addItem(key)

    def update_token_usage(self, chat_input, token_usage_label):
        user_input = chat_input.toPlainText()
        token_usage = self.calculate_token_usage(user_input)
        token_usage_label.setText(f"Tokens: {token_usage}")

    def calculate_token_usage(self, text):
        try:
            # Simple token estimation based on word count
            token_usage = len(text.split())
            return token_usage
        except Exception as e:
            QMessageBox.critical(None, "Token Calculation Error", f"An error occurred while calculating token usage: {str(e)}")
            return 0

    def handle_api_response_wrapper(self, token_usage_label):
        def wrapper(assistant_response, model, response_info):
            self.handle_api_response(assistant_response, model, response_info, token_usage_label)
        return wrapper

    def detect_code_block(self, text):
        # Use a regular expression to detect code blocks
        pattern = r'```.*?```'
        if re.search(pattern, text, re.DOTALL):
            return True
        return False

    def get_api_url(api_type, model):
        api_urls = {
            "openai": {
                "default": "https://api.openai.com/v1/engines/{model}/completions",
                "chat": "https://api.openai.com/v1/chat/completions",
                "dall-e": "https://api.openai.com/v1/images/generations"
            },
            "claude": {
                "claude-3": "https://api.anthropic.com/v1/messages",
                "default": "https://api.anthropic.com/v1/complete"
            },
            "google gemini": {
                "default": "https://generativelanguage.googleapis.com/v1beta2/models/gemini-1.5:generateText",
                "chat": "https://generativelanguage.googleapis.com/v1beta2/models/gemini-1.5:generateMessage",
                "text_generation": "https://generativelanguage.googleapis.com/v1beta2/models/gemini-1.5:generateText",
                "image_generation": "https://generativelanguage.googleapis.com/v1beta2/models/gemini-1.5:generateImage",
                "content_generation": "https://generativelanguage.googleapis.com/v1beta2/models/gemini-1.5:generateContent"
            },
            "inflection_pi": {
                "default": "https://api.inflection.ai/v2/pi/chat",
                "generate_content": "https://api.inflection.ai/v2/pi/generateContent",
                "generate_text": "https://api.inflection.ai/v2/pi/generateText"
            }
        }

        if api_type == "openai":
            if model in ["gpt-3.5-turbo", "gpt-4", "gpt-4-0613", "gpt-4-0613-4o", "gpt-3.5-turbo-0613", "gpt-4o", "gpt-3.5-turbo", "gpt-4o", "gpt-4-turbo"]:
                return api_urls[api_type]["chat"]
            elif "dall-e" in model:
                return api_urls[api_type]["dall-e"]
            else:
                return api_urls[api_type]["default"].format(model=model)
        elif api_type == "claude":
            if "claude-3" in model:
                return api_urls[api_type]["claude-3"]
            else:
                return api_urls[api_type]["default"]
        elif api_type == "google gemini":
            if model == "chat":
                return api_urls[api_type]["chat"]
            elif model == "text_generation":
                return api_urls[api_type]["text_generation"]
            elif model == "image_generation":
                return api_urls[api_type]["image_generation"]
            elif model == "content_generation":
                return api_urls[api_type]["content_generation"]
            else:
                return api_urls[api_type]["default"]
        elif api_type == "inflection_pi":
            if model == "generate_content":
                return api_urls[api_type]["generate_content"]
            elif model == "generate_text":
                return api_urls[api_type]["generate_text"]
            else:
                return api_urls[api_type]["default"]
    
        return api_urls[api_type].get("default", "")

    def save_api_key(self, api_key_edit):
        key = api_key_edit.currentText().strip()
        if not key:
            QMessageBox.warning(self, "Invalid Key", "API key cannot be empty.")
            return
        name, ok = QInputDialog.getText(self, "Name API Key", "Enter a name for this API key:")
        if ok and name:
            settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
            key_entry = f"{name} (****{key[-4:]})"
            settings.setValue(key_entry, key)
            api_key_edit.addItem(key_entry)
            api_key_edit.setCurrentText(key_entry)

    def delete_api_key(self, api_key_edit):
        key_entry = api_key_edit.currentText().strip()
        if key_entry:
            try:
                settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
                name = key_entry.split(" (****")[0]
                settings.remove(name)
                api_key_edit.removeItem(api_key_edit.currentIndex())
                api_key_edit.setCurrentText("")
                if self.show_debug:
                    print(f"Debug: Deleted API key: {key_entry}")
            except Exception as e:
                print(f"Error: Failed to delete API key: {str(e)}")
                QMessageBox.critical(self, "Error", f"Failed to delete API key: {str(e)}")

    def eventFilter(self, source, event):
        if event.type() == QEvent.KeyPress:
            if source is self.chat_input and event.key() == Qt.Key_Return and not (event.modifiers() & Qt.ShiftModifier):
                self.submit_user_input()
                return True
        return super().eventFilter(source, event)

    def collect_chat_data(self):
        chat_data = {
            "api_key": self.api_key_edit.currentText(),
            "model_options": [self.model_dropdown.itemText(i) for i in range(self.model_dropdown.count())],
            "selected_model": self.model_dropdown.currentText(),
            "api_type_options": [self.api_type_dropdown.itemText(i) for i in range(self.api_type_dropdown.count())],
            "selected_api_type": self.api_type_dropdown.currentText(),
            "messages": []
        }
        for i in range(self.chat_layout.count()):
            bubble = self.chat_layout.itemAt(i).widget()
            sender_label = bubble.findChild(QLabel, "sender")
            message_label = bubble.findChild(QLabel, "message")
            if sender_label and message_label:
                chat_data["messages"].append({
                    "sender": sender_label.text(),
                    "content": message_label.text(),
                    "is_code": "Courier" in message_label.font().family(),
                    "is_image": bool(message_label.pixmap())
                })
        chat_data["token_usage"] = self.token_usage_label.text().split(": ")[1]
        return chat_data

class ChatWidget(QWidget):
    message_sent = pyqtSignal(str, str, dict)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.show_debug = True
        self.DB_FILE = "chat_history.db"
        self.DB_BACKUP_FILE = "chat_history_backup.db"
        self.db_file = "api_keys.db"
        self.pop_out_windows = {}
        self.initDB()
        self.initDBkey()
        self.initUI()
        self.load_settings()
        self.load_chat_history("openai", "gpt-3.5-turbo")
        self.ensure_api_keys_table_exists()

    def initUI(self):
        layout = QVBoxLayout(self)

        # Tabs for different chats
        self.tabs = QTabWidget()
        self.tabs.setTabsClosable(True)
        self.tabs.setMovable(True)
        self.tabs.tabCloseRequested.connect(self.close_tab)
        self.tabs.tabBarDoubleClicked.connect(self.edit_tab_name)
        layout.addWidget(self.tabs)

        # Collapsible group for buttons
        button_group = QGroupBox("Controls")
        button_group.setCheckable(True)
        button_group.setChecked(True)
        button_group.setMaximumHeight(200)  # Adjust as needed
        button_group.toggled.connect(lambda checked: content.setVisible(checked))
        group_layout = QVBoxLayout()

        content = QWidget()
        content_layout = QVBoxLayout(content)

        # First row of buttons
        buttons_layout_row1 = QHBoxLayout()
        self.load_more_button = QPushButton("Load More")
        self.load_more_button.setMaximumHeight(30)
        self.load_more_button.clicked.connect(self.load_more_history)
        self.remove_history_button = QPushButton("Remove History")
        self.remove_history_button.setMaximumHeight(30)
        self.remove_history_button.clicked.connect(self.remove_loaded_history)
        self.save_chat_button = QPushButton("Save Chat")
        self.save_chat_button.setMaximumHeight(30)
        self.save_chat_button.clicked.connect(self.save_chat_to_file)
        self.save_format_button = QPushButton("Save Format")
        self.save_format_button.setMaximumHeight(30)
        self.save_format_button.clicked.connect(self.select_save_format)

        buttons_layout_row1.addWidget(self.load_more_button)
        buttons_layout_row1.addWidget(self.remove_history_button)
        buttons_layout_row1.addWidget(self.save_chat_button)
        buttons_layout_row1.addWidget(self.save_format_button)
        content_layout.addLayout(buttons_layout_row1)

        # Second row of buttons
        buttons_layout_row2 = QHBoxLayout()
        self.analytics_button = QPushButton("Show Analytics")
        self.analytics_button.setMaximumHeight(30)
        self.analytics_button.clicked.connect(self.show_analytics_dashboard)
        self.new_tab_button = QPushButton("New Tab")
        self.new_tab_button.setMaximumHeight(30)
        self.new_tab_button.clicked.connect(self.add_new_tab)
        self.pop_out_button = QPushButton("Pop Out Chat")
        self.pop_out_button.setMaximumHeight(30)
        self.pop_out_button.clicked.connect(self.toggle_pop_out_chat)
        self.api_key_manager_button = QPushButton("Manage API Keys")
        self.api_key_manager_button.setMaximumHeight(30)
        self.api_key_manager_button.clicked.connect(self.show_api_key_manager)

        buttons_layout_row2.addWidget(self.analytics_button)
        buttons_layout_row2.addWidget(self.new_tab_button)
        buttons_layout_row2.addWidget(self.pop_out_button)
        buttons_layout_row2.addWidget(self.api_key_manager_button)
        content_layout.addLayout(buttons_layout_row2)

        group_layout.addWidget(content)
        button_group.setLayout(group_layout)
        layout.addWidget(button_group)

        self.setLayout(layout)

        # Add initial tab
        self.add_new_tab("Tab 1")

    def load_api_keys(self, api_key_edit):
        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.cursor()
            cursor.execute("SELECT name, key, added, last_used FROM api_keys")
            keys = cursor.fetchall()
            api_key_edit.clear()
            for key in keys:
                name, key_value, added, last_used = key
                key_entry = f"{name} (****{key_value[-4:]}) - Added: {added} - Last Used: {last_used}"
                api_key_edit.addItem(key_entry)
            conn.close()
        except sqlite3.Error as e:
            print(f"Error: Failed to load API keys: {str(e)}")
            QMessageBox.critical(self, "Database Error", f"Failed to load API keys: {str(e)}")
        except Exception as e:
            print(f"Error: An unexpected error occurred while loading API keys: {str(e)}")
            QMessageBox.critical(self, "Error", f"An unexpected error occurred while loading API keys: {str(e)}")
            
    def ensure_api_keys_table_exists(self):
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS api_keys (
                name TEXT,
                key TEXT,
                added TEXT,
                last_used TEXT
            )
        ''')
        conn.commit()
        conn.close()

    def add_new_tab(self, default_name=None):
        if default_name is None or isinstance(default_name, bool):
            base_name = "Tab"
            existing_tab_names = [self.tabs.tabText(i) for i in range(self.tabs.count())]
            index = 1
            while f"{base_name} {index}" in existing_tab_names:
                index += 1
            tab_name = f"{base_name} {index}"
        else:
            tab_name = str(default_name)  # Ensure tab_name is a string

        new_tab = QWidget()
        new_tab.setObjectName(tab_name)  # Set unique object name for the tab
        new_tab_layout = QVBoxLayout(new_tab)

        # Collapsible settings area
        settings_area = QGroupBox("Settings")
        settings_area.setCheckable(True)
        settings_area.setChecked(True)
        settings_area.toggled.connect(lambda checked: settings_content.setVisible(checked))
        settings_layout = QVBoxLayout()

        settings_content = QWidget()
        content_layout = QVBoxLayout(settings_content)

        # API Key area
        api_key_layout = QHBoxLayout()
        api_key_label = QLabel("API Key:")
        api_key_label.setFixedWidth(50)
        api_key_edit = QComboBox()
        api_key_edit.setEditable(True)
        api_key_edit.setMaximumHeight(30)
        api_key_edit.setPlaceholderText("Enter your API key")
        self.load_api_keys(api_key_edit)  # Load API keys into the new combo box
        save_api_button = QPushButton("Save")
        delete_api_button = QPushButton("Delete")
        save_api_button.setMaximumHeight(30)
        delete_api_button.setMaximumHeight(30)
        save_api_button.setFixedWidth(50)
        delete_api_button.setFixedWidth(50)
        save_api_button.clicked.connect(lambda: self.save_api_key(api_key_edit))
        delete_api_button.clicked.connect(lambda: self.delete_api_key(api_key_edit))
        api_key_layout.addWidget(api_key_label)
        api_key_layout.addWidget(api_key_edit)
        api_key_layout.addWidget(save_api_button)
        api_key_layout.addWidget(delete_api_button)
        content_layout.addLayout(api_key_layout)

        # Model, API Type, and Token usage in one line
        model_api_layout = QHBoxLayout()
    
        model_label = QLabel("Model:")
        model_label.setFixedWidth(50)
        model_dropdown = QComboBox()
        model_dropdown.addItems([
            "gpt-4o", "gpt-4-turbo", "gpt-4", "gpt-4-0613", "gpt-3.5-turbo", "gpt-3.5-turbo-0613","dall-e",
        ])
        model_dropdown.setMaximumHeight(30)

        api_type_label = QLabel("API Type:")
        api_type_label.setFixedWidth(60)
        api_type_dropdown = QComboBox()
        api_type_dropdown.setMaximumHeight(30)
        api_type_dropdown.addItems(["OpenAI", "Claude", "Google Gemini", "Inflection Pi"])
        api_type_dropdown.currentIndexChanged.connect(lambda: self.on_api_type_changed(api_type_dropdown, model_dropdown))

        token_usage_label = QLabel("Tokens: 0")
        token_usage_label.setFixedWidth(80)
        token_usage_label.setMaximumHeight(30)

        model_api_layout.addWidget(model_label)
        model_api_layout.addWidget(model_dropdown)
        model_api_layout.addWidget(api_type_label)
        model_api_layout.addWidget(api_type_dropdown)
        model_api_layout.addWidget(token_usage_label)

        content_layout.addLayout(model_api_layout)

        settings_content.setLayout(content_layout)
        settings_layout.addWidget(settings_content)
        settings_area.setLayout(settings_layout)
        new_tab_layout.addWidget(settings_area)

        # Chat area
        chat_scroll = QScrollArea(new_tab)
        chat_scroll.setWidgetResizable(True)
        chat_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        chat_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)

        chat_area = QWidget()
        chat_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        chat_layout = QVBoxLayout(chat_area)
        chat_layout.setAlignment(Qt.AlignTop)
        chat_scroll.setWidget(chat_area)
        new_tab_layout.addWidget(chat_scroll)

        # Input area
        input_layout = QHBoxLayout()
        chat_input = QTextEdit()
        chat_input.setPlaceholderText("Type your message here...")
        chat_input.setFont(QFont("Arial", 12))
        chat_input.setMaximumHeight(50)
        chat_input.textChanged.connect(lambda: self.update_token_usage(chat_input, token_usage_label))
        chat_input.installEventFilter(self)  # Add this line to install the event filter
        send_button = QPushButton("Send")
        send_button.setMaximumHeight(50)
        send_button.clicked.connect(lambda: self.submit_user_input(chat_input, token_usage_label, api_key_edit, model_dropdown, api_type_dropdown))
        input_layout.addWidget(chat_input)
        input_layout.addWidget(send_button)
        new_tab_layout.addLayout(input_layout)

        # Typing indicator
        typing_indicator = QLabel("Assistant is typing...")
        typing_indicator.setStyleSheet("color: #999999; font-style: italic;")
        typing_indicator.hide()
        new_tab_layout.addWidget(typing_indicator)

        new_tab.chat_layout = chat_layout
        new_tab.api_key_edit = api_key_edit
        new_tab.model_dropdown = model_dropdown
        new_tab.api_type_dropdown = api_type_dropdown
        new_tab.chat_input = chat_input
        new_tab.send_button = send_button
        new_tab.token_usage_label = token_usage_label
        new_tab.typing_indicator = typing_indicator

        self.tabs.addTab(new_tab, tab_name)
        self.tabs.setCurrentWidget(new_tab)

    def closeEvent(self, event):
        tab_name = self.tab_name
        chat_data = self.collect_chat_data()
        self.closed.emit(tab_name, chat_data)
        super().closeEvent(event)

    def reattach_chat_widget(self, tab_name, chat_data):
        new_tab = self.create_tab_from_pop_out(tab_name, chat_data)
        index = self.tabs.addTab(new_tab, tab_name)
        self.tabs.setCurrentIndex(index)
        self.load_chat_data(chat_data, new_tab)  # Pass new_tab to ensure correct data loading
        if tab_name in self.pop_out_windows:
            del self.pop_out_windows[tab_name]

    def create_tab_from_pop_out(self, tab_name, chat_data):
        new_tab = QWidget()
        new_tab.setObjectName(tab_name)
        new_tab_layout = QVBoxLayout(new_tab)

        # Collapsible settings area
        settings_area = QGroupBox("Settings")
        settings_area.setCheckable(True)
        settings_area.setChecked(True)
        settings_area.toggled.connect(lambda checked: settings_content.setVisible(checked))
        settings_layout = QVBoxLayout()

        settings_content = QWidget()
        content_layout = QVBoxLayout(settings_content)

        # API Key area
        api_key_layout = QHBoxLayout()
        api_key_label = QLabel("API Key:")
        api_key_edit = QComboBox()
        api_key_edit.setEditable(True)
        api_key_edit.setMaximumHeight(30)
        api_key_edit.setPlaceholderText("Enter your API key")
        save_api_button = QPushButton("Save")
        delete_api_button = QPushButton("Delete")
        save_api_button.setMaximumHeight(30)
        delete_api_button.setMaximumHeight(30)
        save_api_button.setFixedWidth(50)
        delete_api_button.setFixedWidth(50)
        save_api_button.clicked.connect(lambda: self.parent().save_api_key(api_key_edit))
        delete_api_button.clicked.connect(lambda: self.parent().delete_api_key(api_key_edit))
        api_key_layout.addWidget(api_key_label)
        api_key_layout.addWidget(api_key_edit)
        api_key_layout.addWidget(save_api_button)
        api_key_layout.addWidget(delete_api_button)
        content_layout.addLayout(api_key_layout)

        # Model, API Type, and Token usage in one line
        model_api_layout = QHBoxLayout()
    
        model_label = QLabel("Model:")
        model_dropdown = QComboBox()
        model_dropdown.setMaximumHeight(30)

        api_type_label = QLabel("API Type:")
        api_type_dropdown = QComboBox()
        api_type_dropdown.setMaximumHeight(30)
        api_type_dropdown.currentIndexChanged.connect(lambda: self.on_api_type_changed(api_type_dropdown, model_dropdown))

        token_usage_label = QLabel("Tokens: 0")
        token_usage_label.setFixedWidth(80)
        token_usage_label.setMaximumHeight(30)

        model_api_layout.addWidget(model_label)
        model_api_layout.addWidget(model_dropdown)
        model_api_layout.addWidget(api_type_label)
        model_api_layout.addWidget(api_type_dropdown)
        model_api_layout.addWidget(token_usage_label)

        content_layout.addLayout(model_api_layout)

        settings_content.setLayout(content_layout)
        settings_layout.addWidget(settings_content)
        settings_area.setLayout(settings_layout)
        new_tab_layout.addWidget(settings_area)

        # Chat area
        chat_scroll = QScrollArea(new_tab)
        chat_scroll.setWidgetResizable(True)
        chat_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        chat_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)

        chat_area = QWidget()
        chat_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        chat_layout = QVBoxLayout(chat_area)
        chat_layout.setAlignment(Qt.AlignTop)
        chat_scroll.setWidget(chat_area)
        new_tab_layout.addWidget(chat_scroll)

        # Input area
        input_layout = QHBoxLayout()
        chat_input = QTextEdit()
        chat_input.setPlaceholderText("Type your message here...")
        chat_input.setFont(QFont("Arial", 12))
        chat_input.setMaximumHeight(50)
        input_layout.addWidget(chat_input)
        send_button = QPushButton("Send")
        send_button.setMaximumHeight(50)
        input_layout.addWidget(send_button)
        new_tab_layout.addLayout(input_layout)

        # Typing indicator
        typing_indicator = QLabel("Assistant is typing...")
        typing_indicator.setStyleSheet("color: #999999; font-style: italic;")
        typing_indicator.hide()
        new_tab_layout.addWidget(typing_indicator)

        new_tab.chat_layout = chat_layout
        new_tab.api_key_edit = api_key_edit
        new_tab.model_dropdown = model_dropdown
        new_tab.api_type_dropdown = api_type_dropdown
        new_tab.chat_input = chat_input
        new_tab.send_button = send_button
        new_tab.token_usage_label = token_usage_label
        new_tab.typing_indicator = typing_indicator

        self.load_api_keys(api_key_edit)

        return new_tab

    def load_chat_data(self, chat_data, tab):
        tab.api_key_edit.setEditText(chat_data.get("api_key", ""))
        tab.model_dropdown.addItems(chat_data.get("model_options", []))
        tab.model_dropdown.setCurrentText(chat_data.get("selected_model", ""))
        tab.api_type_dropdown.addItems(chat_data.get("api_type_options", []))
        tab.api_type_dropdown.setCurrentText(chat_data.get("selected_api_type", ""))
        tab.chat_layout.setAlignment(Qt.AlignTop)
        self.clear_chat_area(tab)
        for message in chat_data.get("messages", []):
            if message.get("is_image"):
                self.add_image_message(message["content"], tab)
            else:
                self.add_message_bubble(message["sender"], message["content"], message.get("is_code", False), message.get("is_image", False), tab)
        tab.token_usage_label.setText(f"Tokens: {chat_data.get('token_usage', 0)}")

    def collect_chat_data(self, tab):
        chat_data = {
            "api_key": tab.api_key_edit.currentText(),
            "model_options": [tab.model_dropdown.itemText(i) for i in range(tab.model_dropdown.count())],
            "selected_model": tab.model_dropdown.currentText(),
            "api_type_options": [tab.api_type_dropdown.itemText(i) for i in range(tab.api_type_dropdown.count())],
            "selected_api_type": tab.api_type_dropdown.currentText(),
            "messages": []
        }
        for i in range(tab.chat_layout.count()):
            bubble = tab.chat_layout.itemAt(i).widget()
            if bubble:
                sender_label = bubble.findChild(QLabel, "sender")
                message_label = bubble.findChild(QLabel, "message")
                if sender_label and message_label:
                    chat_data["messages"].append({
                        "sender": sender_label.text(),
                        "content": message_label.text(),
                        "is_code": "Courier" in message_label.font().family(),
                        "is_image": bool(message_label.pixmap())
                    })
        chat_data["token_usage"] = tab.token_usage_label.text().split(": ")[1]
        return chat_data

    def show_api_key_manager(self):
        self.api_key_manager = APIKeyManager(self)
        self.api_key_manager.exec_()

    def toggle_pop_out_chat(self):
        current_tab = self.tabs.currentWidget()
        if current_tab is not None:
            tab_name = self.tabs.tabText(self.tabs.currentIndex())
            if tab_name in self.pop_out_windows:
                # Reattach the chat widget
                if self.pop_out_windows[tab_name] is not None:
                    self.reattach_chat_widget(tab_name, self.pop_out_windows[tab_name].chat_data)
                    self.pop_out_windows[tab_name].close()
                    del self.pop_out_windows[tab_name]
            else:
                chat_data = self.collect_chat_data(current_tab)
                pop_out_window = PopOutChatWindow(self, tab_name, chat_data)
                self.pop_out_windows[tab_name] = pop_out_window
                pop_out_window.closed.connect(lambda tab_name=tab_name, chat_data=chat_data: self.reattach_chat_widget(tab_name, chat_data))
                pop_out_window.show()
                self.tabs.removeTab(self.tabs.indexOf(current_tab))

    def save_api_key(self, api_key_edit):
        key = api_key_edit.currentText().strip()
        if not key:
            QMessageBox.warning(self, "Invalid Key", "API key cannot be empty.")
            return
        name, ok = QInputDialog.getText(self, "Name API Key", "Enter a name for this API key:")
        if ok and name:
            added_date = QDateTime.currentDateTime().toString()
            last_used = "Never"
            conn = sqlite3.connect(self.db_file)
            cursor = conn.cursor()
            cursor.execute("INSERT INTO api_keys (name, key, added, last_used) VALUES (?, ?, ?, ?)", (name, key, added_date, last_used))
            conn.commit()
            conn.close()
            key_entry = f"{name} (****{key[-4:]}) - Added: {added_date} - Last Used: {last_used}"
            api_key_edit.addItem(key_entry)
            api_key_edit.setCurrentText(key_entry)
            if self.show_debug:
                print(f"Debug: Saved API key: {key_entry}")
                #print(f"Debug: Full API key saved: {key}")

    def delete_api_key(self, api_key_edit):
        key_entry = api_key_edit.currentText().strip()
        if key_entry:
            try:
                name = key_entry.split(" (****")[0]
                conn = sqlite3.connect(self.db_file)
                cursor = conn.cursor()
                cursor.execute("DELETE FROM api_keys WHERE name=?", (name,))
                conn.commit()
                conn.close()
                api_key_edit.removeItem(api_key_edit.currentIndex())
                api_key_edit.setCurrentText("")
                if self.show_debug:
                    print(f"Debug: Deleted API key: {key_entry}")
            except Exception as e:
                print(f"Error: Failed to delete API key: {str(e)}")
                QMessageBox.critical(self, "Error", f"Failed to delete API key: {str(e)}")

    def clear_chat_area(self, tab):
        if tab:
            for i in reversed(range(tab.chat_layout.count())):
                tab.chat_layout.itemAt(i).widget().deleteLater()

    def load_chat_history(self, api_type, model):
        current_tab = self.tabs.currentWidget()
        chat_history = self.load_chat_history_from_db(api_type.lower(), model)
        self.clear_chat_area(current_tab)
        total_token_usage = 0
        for user_input, assistant_response, timestamp, token_usage in chat_history:
            self.add_message_bubble("You", user_input, tab=current_tab)
            self.add_message_bubble(f"{model} Assistant", assistant_response, tab=current_tab)
            self.add_timestamp(timestamp, tab=current_tab)
            total_token_usage += token_usage
        current_tab.token_usage_label.setText(f"Tokens: {total_token_usage}")

    def add_message_bubble(self, sender, message, is_code=False, is_image=False, tab=None):
        if tab is None:
            tab = self.tabs.currentWidget()
        bubble = QWidget()
        bubble_layout = QVBoxLayout(bubble)
        bubble_layout.setContentsMargins(2, 2, 2, 2)

        sender_label = QLabel(sender)
        sender_label.setObjectName("sender")
        sender_label.setStyleSheet("font-weight: bold; color: white;")
        bubble_layout.addWidget(sender_label)

        # Add the checkboxes
        display_as_code_checkbox = QCheckBox("Display as Code Bubble")
        display_as_code_checkbox.setChecked(is_code)
        display_as_code_checkbox.stateChanged.connect(lambda state: self.update_message_display(bubble, message, is_code, is_image, state))
        bubble_layout.addWidget(display_as_code_checkbox)

        combine_code_checkbox = QCheckBox("Combine Code Bubbles")
        combine_code_checkbox.setVisible(is_code)
        combine_code_checkbox.stateChanged.connect(lambda state: self.combine_code_bubbles(bubble))
        bubble_layout.addWidget(combine_code_checkbox)

        # Add the message or code bubble
        self.update_message_display(bubble, message, is_code, is_image, display_as_code_checkbox.isChecked())

        tab.chat_layout.addWidget(bubble)
        bubble.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Minimum)

        return bubble

    def update_message_display(self, bubble, message, is_code, is_image, display_as_code):
        try:
            # Clear the existing layout except for the sender label and checkboxes
            sender_label = bubble.layout().itemAt(0).widget()
            display_as_code_checkbox = bubble.layout().itemAt(1).widget()
            combine_code_checkbox = bubble.layout().itemAt(2).widget()

            while bubble.layout().count() > 3:
                item = bubble.layout().takeAt(3)
                widget = item.widget()
                if widget is not None:
                    widget.deleteLater()

            bubble.layout().addWidget(sender_label)
            bubble.layout().addWidget(display_as_code_checkbox)
            bubble.layout().addWidget(combine_code_checkbox)

            if display_as_code:
                parts = self.extract_code_and_text_and_images(message)

                for part in parts:
                    if isinstance(part, dict):
                        if part['type'] == 'code':
                            self.create_code_bubble(part['content'], bubble.layout())
                        elif part['type'] == 'image':
                            message_label = QLabel()
                            message_label.setObjectName("message")
                            message_label.setPixmap(QPixmap(part['content']).scaled(512, 512, Qt.KeepAspectRatio))
                            bubble.layout().addWidget(message_label)

                            # Add buttons for save/download
                            button_layout = QHBoxLayout()
                            save_button = QPushButton("Save")
                            save_button.setObjectName("save_button")
                            save_button.setStyleSheet("background-color: #4CAF50; color: white; padding: 5px; border-radius: 5px;")
                            save_button.clicked.connect(lambda: self.save_message(part['content'], is_image=True))

                            download_button = QPushButton("Download")
                            download_button.setObjectName("download_button")
                            download_button.setStyleSheet("color: #2196F3; padding: 5px; border-radius: 5px;")
                            download_button.clicked.connect(lambda: self.download_image(part['content']))
                            button_layout.addWidget(download_button)

                            button_layout.addWidget(save_button)
                            bubble.layout().addLayout(button_layout)
                    else:
                        message_label = QLabel(part)
                        message_label.setObjectName("message")
                        message_label.setWordWrap(True)
                        message_label.setTextInteractionFlags(Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard)
                        message_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
                        message_label.setStyleSheet("color: white; background-color: black; padding: 5px; border-radius: 10px;")
                        bubble.layout().addWidget(message_label)

                        # Add button for save
                        button_layout = QHBoxLayout()
                        save_button = QPushButton("Save")
                        save_button.setObjectName("save_button")
                        save_button.setStyleSheet("background-color: #4CAF50; color: white; padding: 5px; border-radius: 5px;")
                        save_button.clicked.connect(lambda: self.save_message(part, is_image=False))
                        button_layout.addWidget(save_button)
                        bubble.layout().addLayout(button_layout)
            else:
                self.create_code_bubble(message, bubble.layout())
        except Exception as e:
            print(f"Error: {str(e)}")
            QMessageBox.critical(self, "Display Error", f"An error occurred while updating the message display: {str(e)}")

    def create_code_bubble(self, code, parent_layout):
        try:
            code_label = QLabel(f"Generated Code")
            code_label.setStyleSheet("font-weight: bold;")

            code_text = QTextEdit()
            code_text.setReadOnly(True)
            code_text.setFont(QFont("Courier", 12))
            code_text.setStyleSheet("background-color: black; color: white; padding: 5px; border-radius: 10px;")
            code_text.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            code_text.setMinimumHeight(200)

            # Set the text format to plain text to preserve line breaks
            code_text.setPlainText(code)

            button_layout = QHBoxLayout()
            save_button = QPushButton("Save")
            save_button.setStyleSheet("background-color: #4CAF50; color: white; padding: 5px; border-radius: 5px;")
            save_button.clicked.connect(lambda: self.save_message(code, is_image=False))

            copy_button = QPushButton("Copy to Clipboard")
            copy_button.setStyleSheet("background-color: #2196F3; color: white; padding: 5px; border-radius: 5px;")
            copy_button.clicked.connect(lambda: self.copy_to_clipboard(code))

            validate_button = QPushButton("Validate Code")
            validate_button.setStyleSheet("background-color: #FF9800; color: white; padding: 5px; border-radius: 5px;")
            validate_button.clicked.connect(lambda: self.validate_code(code, validate_button))

            button_layout.addWidget(save_button)
            button_layout.addWidget(copy_button)
            button_layout.addWidget(validate_button)

            parent_layout.addWidget(code_label)
            parent_layout.addWidget(code_text)
            parent_layout.addLayout(button_layout)

        except Exception as e:
            QMessageBox.critical(None, "Code Bubble Error", f"An error occurred while creating the code bubble: {str(e)}")

    def extract_code_and_text_and_images(self, message):
        parts = []
        current_part = ""
        in_code = False
        in_image = False

        lines = message.split('\n')
        for line in lines:
            if line.startswith('```') and not in_code:
                if current_part:
                    parts.append(current_part.strip())
                    current_part = ""
                in_code = True
                code_type = line[3:].strip() if line[3:] else "code"
            elif line.startswith('```') and in_code:
                if current_part:
                    parts.append({"type": "code", "content": current_part.strip(), "code_type": code_type})
                    current_part = ""
                in_code = False
            elif line.startswith('![') and not in_image:
                if current_part:
                    parts.append(current_part.strip())
                    current_part = ""
                in_image = True
            elif in_image and line.startswith(')'):
                if current_part:
                    parts.append({"type": "image", "content": current_part.strip()})
                    current_part = ""
                in_image = False
            else:
                current_part += line + '\n'

        if current_part.strip():
            parts.append(current_part.strip())

        return parts

    def combine_code_bubbles(self, current_bubble):
        # Identify selected bubbles
        selected_bubbles = []
        for i in range(self.tabs.currentWidget().chat_layout.count()):
            widget = self.tabs.currentWidget().chat_layout.itemAt(i).widget()
            if widget != current_bubble and hasattr(widget, 'combine_code_checkbox') and widget.combine_code_checkbox.isChecked():
                selected_bubbles.append(widget)

        if len(selected_bubbles) > 0:
            confirm = QMessageBox.question(None, "Combine Code Bubbles", "Do you want to combine the selected code bubbles?", QMessageBox.Yes | QMessageBox.No)
            if confirm == QMessageBox.Yes:
                combined_code = ""
                for bubble in selected_bubbles:
                    code_text = bubble.layout().itemAt(4).widget().toPlainText()  # Assuming the code is at position 4
                    combined_code += code_text + "\n\n"

                # Create a new code bubble with the combined code
                self.create_code_bubble(combined_code, True, current_bubble.layout())
                for bubble in selected_bubbles:
                    bubble.hide()

    def save_combined_code(self):
        combined_code = self.combine_code_bubbles()
        if combined_code:
            self.save_text(combined_code)

    def execute_combined_code(self):
        combined_code = self.combine_code_bubbles()
        if combined_code:
            self.execute_code(combined_code)

    def copy_to_clipboard(self, text):
        clipboard = QApplication.clipboard()
        clipboard.setText(text)

    def validate_code(self, code, button):
        try:
            # Simple validation for Python code
            compile(code, '<string>', 'exec')
            button.setText("Execute Code")
            button.clicked.disconnect()
            button.clicked.connect(lambda: self.execute_code(code))
        except Exception as e:
            QMessageBox.warning(None, "Code Validation", f"Code validation failed: {e}")

    def execute_code(self, code):
        confirm = QMessageBox.question(None, "Execute Code", "Executing code can be unsafe. Do you want to proceed?", QMessageBox.Yes | QMessageBox.No)

        if confirm == QMessageBox.Yes:
            try:
                with tempfile.NamedTemporaryFile(mode='w', delete=False) as temp_file:
                    temp_file.write(code)
                    temp_file.flush()
                subprocess.Popen(['python', temp_file.name])
            except Exception as e:
                QMessageBox.critical(None, "Code Execution Error", f"Error executing code: {e}")
            finally:
                temp_file.close() # Close the temporary file regardless of exception
        elif confirm == QMessageBox.No: # Add a message for the user if they choose not to proceed
            QMessageBox.information(None, "Code Execution Canceled", "Code execution has been canceled.")

    def save_message(self, message, is_image):
        if is_image:
            self.save_image(message)
        else:
            self.save_text(message)

    def save_image(self, image_data):
        try:
            file_path, _ = QFileDialog.getSaveFileName(self, "Save Image", os.path.expanduser("~"), "Image Files (*.png *.jpg *.jpeg)")
            if file_path:
                with open(file_path, 'wb') as file:
                    file.write(image_data)
        except Exception as e:
            QMessageBox.critical(None, "Save Image Error", f"Error saving image: {e}")

    def save_text(self, text):
        try:
            file_path, _ = QFileDialog.getSaveFileName(self, "Save Text", os.path.expanduser("~"), "Text Files (*.txt)")
            if file_path:
                with open(file_path, 'w') as file:
                    file.write(text)
        except Exception as e:
            QMessageBox.critical(None, "Save Text Error", f"Error saving text: {e}")

    def download_image(self, image_data):
        try:
            file_path, _ = QFileDialog.getSaveFileName(self, "Download Image", os.path.expanduser("~"), "Image Files (*.png *.jpg *.jpeg)")
            if file_path:
                with open(file_path, 'wb') as file:
                    file.write(image_data)
        except Exception as e:
            QMessageBox.critical(None, "Download Image Error", f"Error downloading image: {e}")

    def detect_code_type(self, message):
        # This method should return the code type if found, otherwise None
        patterns = {
            "HTML": r"<html>.*</html>",
            "CSS": r"<style>.*</style>",
            "Python": r"```python[\s\S]*?```",
            "PHP": r"```php[\s\S]*?```",
            "C#": r"```csharp[\s\S]*?```",
            "JavaScript": r"```javascript[\s\S]*?```",
            "C": r"```c[\s\S]*?```",
            "PowerShell": r"```powershell[\s\S]*?```",
            "Bash": r"```bash[\s\S]*?```",
            "JSON": r"\{[\s\S]*?\}",
            "XML": r"<\?xml[\s\S]*?\?>"
        }
        for code_type, pattern in patterns.items():
            if re.search(pattern, message, re.IGNORECASE):
                return code_type
        return "Code"

    def extract_code_and_type(self, message):
        code_type = self.detect_code_type(message)
        if code_type in ["HTML", "CSS", "JSON", "XML"]:
            return code_type, message
        elif code_type != "Code":
            return code_type, "\n".join(message.split("```")[1].strip().split("\n")[1:])
        return "Code", message

    def add_timestamp(self, timestamp, tab=None):
        if tab is None:
            tab = self.tabs.currentWidget()
        timestamp_label = QLabel(timestamp)
        timestamp_label.setAlignment(Qt.AlignCenter)
        timestamp_label.setStyleSheet("color: #999999; font-size: 10px;")
        tab.chat_layout.addWidget(timestamp_label)

    def on_api_type_changed(self, api_type_dropdown, model_dropdown):
        api_type = api_type_dropdown.currentText()
        model_dropdown.clear()
        if api_type in ACTIVE_MODELS:
            model_dropdown.addItems(ACTIVE_MODELS[api_type])

    def edit_tab_name(self, index):
        if index != -1:
            tab_name, ok = QInputDialog.getText(self, "Edit Tab Name", "Enter new name for the tab:", text=self.tabs.tabText(index))
            if ok and tab_name:
                self.tabs.setTabText(index, tab_name)

    def close_tab(self, index):
        widget = self.tabs.widget(index)
        if widget is not None:
            widget.deleteLater()
        self.tabs.removeTab(index)

    def initDB(self):
        try:
            if not os.path.exists(self.DB_FILE):
                self.create_db_tables()
            else:
                conn = sqlite3.connect(self.DB_FILE)
                cursor = conn.cursor()
                cursor.execute("PRAGMA table_info(chat_history)")
                table_info = cursor.fetchall()
                conn.close()

                if len(table_info) != 7 or any(col[1] != expected for col, expected in zip(table_info, ["id", "api_type", "model", "user_input", "assistant_response", "timestamp", "token_usage"])):
                    self.backup_db_file()
                    os.remove(self.DB_FILE)
                    self.create_db_tables()
            if debug_mode:
                print("Chat database initialized successfully.")
        except sqlite3.Error as e:
            print(f"SQLite error: {str(e)}")
            QMessageBox.critical(None, "Database Error", f"SQLite error: {str(e)}")
        except Exception as e:
            print(f"Error initializing the chat database: {str(e)}")
            QMessageBox.critical(None, "Database Error", f"An error occurred while initializing the database: {str(e)}")

    def initDBkey(self):
        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.cursor()
            cursor.execute('''CREATE TABLE IF NOT EXISTS api_keys (
                                name TEXT PRIMARY KEY,
                                key TEXT,
                                added TEXT,
                                last_used TEXT)''')
            conn.commit()
            conn.close()
            if debug_mode:
                print("API keys database initialized successfully.")
        except sqlite3.Error as e:
            print(f"SQLite error: {str(e)}")
            QMessageBox.critical(self, "Database Error", f"SQLite error: {str(e)}")
        except Exception as e:
            print(f"Error initializing the API keys database: {str(e)}")
            QMessageBox.critical(self, "Database Error", f"An error occurred while initializing the database: {str(e)}")

    def create_db_tables(self):
        try:
            conn = sqlite3.connect(self.DB_FILE)
            cursor = conn.cursor()
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS chat_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    api_type TEXT,
                    model TEXT,
                    user_input TEXT,
                    assistant_response TEXT,
                    timestamp TEXT,
                    token_usage INTEGER
                )
            """)
            conn.commit()
            conn.close()
            if debug_mode:
                print("Chat history table created successfully.")
        except sqlite3.Error as e:
            print(f"SQLite error: {str(e)}")
            QMessageBox.critical(None, "Database Error", f"SQLite error: {str(e)}")
        except Exception as e:
            print(f"Error creating the chat history table: {str(e)}")
            QMessageBox.critical(None, "Database Error", f"An error occurred while creating the database tables: {str(e)}")

    def backup_db_file(self):
        try:
            backup_file = self.DB_FILE + '.backup'
            import shutil
            shutil.copyfile(self.DB_FILE, backup_file)
            if debug_mode:
                print(f"Database backup created at {backup_file}")
        except Exception as e:
            print(f"Error creating database backup: {str(e)}")
            QMessageBox.critical(None, "Backup Error", f"An error occurred while creating the database backup: {str(e)}")

    def load_chat_history_from_db(self, api_type, model, limit=20, offset=0):
        try:
            conn = sqlite3.connect(self.DB_FILE)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT user_input, assistant_response, timestamp, token_usage
                FROM chat_history
                WHERE api_type = ? AND model = ?
                ORDER BY id DESC
                LIMIT ? OFFSET ?
            """, (api_type, model, limit, offset))
            chat_history = cursor.fetchall()
            conn.close()
            return chat_history
        except sqlite3.Error as e:
            QMessageBox.critical(None, "Database Error", f"An error occurred while loading the chat history: {str(e)}")
            return []

    def save_chat_message(self, api_type, model, user_input, assistant_response, token_usage):
        try:
            conn = sqlite3.connect(self.DB_FILE)
            cursor = conn.cursor()
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            cursor.execute("""
                INSERT INTO chat_history (api_type, model, user_input, assistant_response, timestamp, token_usage)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (api_type, model, user_input, assistant_response, timestamp, token_usage))
            conn.commit()
            conn.close()
        except sqlite3.Error as e:
            QMessageBox.critical(None, "Database Error", f"An error occurred while saving the chat message: {str(e)}")

    def load_more_history(self):
        current_tab = self.tabs.currentWidget()
        api_type = current_tab.api_type_dropdown.currentText().lower()
        model = current_tab.model_dropdown.currentText()
        existing_count = current_tab.chat_layout.count()
        chat_history = self.load_chat_history_from_db(api_type, model, limit=40, offset=existing_count)
        for user_input, assistant_response, timestamp, token_usage in chat_history:
            self.add_message_bubble("You", user_input)
            self.add_message_bubble(f"{model} Assistant", assistant_response)
            self.add_timestamp(timestamp)

    def remove_loaded_history(self):
        try:
            conn = sqlite3.connect(self.DB_FILE)
            cursor = conn.cursor()
            cursor.execute("DELETE FROM chat_history")
            conn.commit()
            conn.close()
            self.clear_chat_area()
            self.load_chat_history(self.api_type_dropdown.currentText().lower(), self.model_dropdown.currentText())
        except sqlite3.Error as e:
            QMessageBox.critical(None, "Database Error", f"An error occurred while removing the chat history: {str(e)}")

    def save_chat_to_file(self):
        try:
            file_path, _ = QFileDialog.getSaveFileName(self, "Save Chat", "", "Text Files (*.txt);;HTML Files (*.html);;PDF Files (*.pdf)")
            if file_path:
                save_format = os.path.splitext(file_path)[1][1:].lower()
                if save_format == "txt":
                    self.save_chat_as_text(file_path)
                elif save_format == "html":
                    self.save_chat_as_html(file_path)
                elif save_format == "pdf":
                    self.save_chat_as_pdf(file_path)
        except Exception as e:
            QMessageBox.critical(None, "Save Error", f"An error occurred while saving the chat: {str(e)}")

    def save_chat_as_text(self, file_path):
        with open(file_path, "w") as file:
            for i in range(self.chat_layout.count()):
                item = self.chat_layout.itemAt(i).widget()
                if isinstance(item, QWidget):
                    sender_label = item.findChild(QLabel, "sender")
                    message_label = item.findChild(QLabel, "message")
                    if sender_label and message_label:
                        file.write(f"{sender_label.text()}: {message_label.text()}\n")
                elif isinstance(item, QLabel):
                    file.write(f"{item.text()}\n")

    def save_chat_as_html(self, file_path):
        html = "<html><head><title>Chat History</title></head><body>"
        for i in range(self.chat_layout.count()):
            item = self.chat_layout.itemAt(i).widget()
            if isinstance(item, QWidget):
                sender_label = item.findChild(QLabel, "sender")
                message_label = item.findChild(QLabel, "message")
                if sender_label and message_label:
                    html += f"<p><strong>{sender_label.text()}:</strong> {message_label.text()}</p>"
            elif isinstance(item, QLabel):
                html += f"<p>{item.text()}</p>"
        html += "</body></html>"
        with open(file_path, "w") as file:
            file.write(html)

    def save_chat_as_pdf(self, file_path):
        from reportlab.lib.pagesizes import letter
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
        from reportlab.lib.styles import getSampleStyleSheet
        from reportlab.lib.units import inch

        doc = SimpleDocTemplate(file_path, pagesize=letter)
        styles = getSampleStyleSheet()

        elements = []
        for i in range(self.chat_layout.count()):
            item = self.chat_layout.itemAt(i).widget()
            if isinstance(item, QWidget):
                sender_label = item.findChild(QLabel, "sender")
                message_label = item.findChild(QLabel, "message")
                if sender_label and message_label:
                    elements.append(Paragraph(f"{sender_label.text()}: {message_label.text()}", styles["BodyText"]))
                    elements.append(Spacer(1, 12))
            elif isinstance(item, QLabel):
                elements.append(Paragraph(item.text(), styles["BodyText"]))
                elements.append(Spacer(1, 12))

        doc.build(elements)

    def retrieve_api_key(self, key_entry):
        name = key_entry.split(" (****")[0]
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute("SELECT key FROM api_keys WHERE name=?", (name,))
        key_data = cursor.fetchone()
        conn.close()
        if key_data:
            api_key = key_data[0]
            if self.show_debug:
                print(f"Debug: Retrieved API key for {name}: {api_key}")
            return api_key
        else:
            if self.show_debug:
                print(f"Debug: API key not found for {name}")
            return ""

    def submit_user_input(self, chat_input, token_usage_label, api_key_edit, model_dropdown, api_type_dropdown):
        user_input = chat_input.toPlainText().strip()
        api_key_item_text = api_key_edit.currentText()
        api_key = self.retrieve_api_key(api_key_item_text)
        model = model_dropdown.currentText()

        if self.show_debug:
            print(f"Debug: Sending API key: {api_key_item_text}")
            print(f"Debug: Full API key: {api_key}")

        if user_input and api_key:
            api_type = api_type_dropdown.currentText().lower()
            self.add_message_bubble("You", user_input)
            chat_input.clear()
            api_url = self.get_api_url(api_type, model)
            self.api_call_thread = EnhancedAPICallThread(api_type, api_key, model, user_input, api_url)
            current_tab = self.tabs.currentWidget()
            self.api_call_thread.finished.connect(self.handle_api_response_wrapper(token_usage_label, current_tab))
            self.api_call_thread.start()
            self.update_token_usage(chat_input, token_usage_label, additional_tokens=len(user_input.split()))
            self.show_typing_indicator(current_tab.typing_indicator)
        else:
            QMessageBox.warning(self, "Input Error", "Please enter both a message and an API key.")

    def handle_api_response(self, assistant_response, model, response_info, token_usage_label, current_tab):
        self.hide_typing_indicator(current_tab.typing_indicator)
        if 'status' in response_info and response_info['status'] == 'RESPONSE':
            if model == "dall-e" and assistant_response.startswith("http"):
                self.add_image_message(assistant_response, current_tab)
            else:
                self.add_message_bubble(f"{model} Assistant", assistant_response, self.detect_code_block(assistant_response), tab=current_tab)
            self.add_timestamp(datetime.now().strftime("%Y-%m-%d %H:%M:%S"), current_tab)
            self.message_sent.emit(current_tab.api_type_dropdown.currentText().lower(), assistant_response, response_info)
            token_usage_label.setText(f"Tokens: {response_info['token_usage']}")
        elif 'error' in response_info:
            logging.error(f"API call error: {response_info['error']}")
            QMessageBox.critical(None, "API Error", f"An error occurred: {response_info['error']}")
        else:
            logging.error("Unexpected response structure: " + str(response_info))
            QMessageBox.critical(None, "API Error", "An unexpected error occurred.")

    def handle_api_response_wrapper(self, token_usage_label, current_tab):
        def wrapper(assistant_response, model, response_info):
            self.handle_api_response(assistant_response, model, response_info, token_usage_label, current_tab)
        return wrapper

    def add_image_message(self, image_url, tab=None):
        if tab is None:
            tab = self.tabs.currentWidget()
        image_label = QLabel()
        image_label.setObjectName("message")
        image = QImage()
        image.loadFromData(requests.get(image_url).content)
        image_label.setPixmap(QPixmap.fromImage(image).scaled(512, 512, Qt.KeepAspectRatio))
        image_label.setScaledContents(True)
        tab.chat_layout.addWidget(image_label)
        tab.chat_layout.addStretch()

    def show_typing_indicator(self, typing_indicator):
        typing_indicator.show()

    def hide_typing_indicator(self, typing_indicator):
        typing_indicator.hide()

    def calculate_token_usage(self, text):
        try:
            # Simple token estimation based on word count
            token_usage = len(text.split())
            return token_usage
        except Exception as e:
            QMessageBox.critical(None, "Token Calculation Error", f"An error occurred while calculating token usage: {str(e)}")
            return 0

    def update_token_usage(self, chat_input, token_usage_label, additional_tokens=0):
        user_input = chat_input.toPlainText()
        token_usage = self.calculate_token_usage(user_input) + additional_tokens
        token_usage_label.setText(f"Tokens: {token_usage}")

    def attach_file(self):
        try:
            file_path, _ = QFileDialog.getOpenFileName(self, "Attach File", "", "All Files (*)")
            if file_path:
                self.send_attachment(file_path)
        except Exception as e:
            QMessageBox.critical(None, "Attachment Error", f"An error occurred while attaching the file: {str(e)}")

    def send_attachment(self, file_path):
        try:
            file_name = os.path.basename(file_path)
            # Display the file in the chat
            self.add_message_bubble("You", f"Attachment: {file_name}")
            # Simulate sending the file to the assistant
            self.add_message_bubble(f"{self.model_dropdown.currentText()} Assistant", f"Received file: {file_name}")
        except Exception as e:
            QMessageBox.critical(None, "Send Attachment Error", f"An error occurred while sending the attachment: {str(e)}")

    def show_analytics_dashboard(self):
        try:
            analytics_window = QMainWindow(self)
            analytics_window.setWindowTitle("Chat Analytics")
            analytics_window.setGeometry(100, 100, 800, 600)
        
            central_widget = QWidget()
            analytics_window.setCentralWidget(central_widget)
            layout = QVBoxLayout(central_widget)

            # Example analytics table
            analytics_table = QTableWidget()
            analytics_table.setRowCount(5)  # Number of rows
            analytics_table.setColumnCount(4)  # Number of columns
            analytics_table.setHorizontalHeaderLabels(["Metric", "Value", "Description", "USD Cost"])

            # Fill the table with sample data
            metrics = [
                ("Total Messages", "100", "Total number of messages exchanged", self.calculate_cost(1000)),
                ("Total Tokens Used", "1500", "Total tokens used in the chat", self.calculate_cost(1500)),
                ("Average Response Time", "2s", "Average response time of the assistant", "-"),
                ("Total Attachments", "10", "Total number of attachments sent", "-"),
                ("Active Sessions", "5", "Number of active chat sessions", "-")
            ]

            for i, (metric, value, description, usd_cost) in enumerate(metrics):
                analytics_table.setItem(i, 0, QTableWidgetItem(metric))
                analytics_table.setItem(i, 1, QTableWidgetItem(value))
                analytics_table.setItem(i, 2, QTableWidgetItem(description))
                analytics_table.setItem(i, 3, QTableWidgetItem(usd_cost))

            layout.addWidget(analytics_table)
            analytics_window.show()
        except Exception as e:
            QMessageBox.critical(None, "Analytics Error", f"An error occurred while showing the analytics dashboard: {str(e)}")

    def calculate_cost(self, tokens):
        # Example cost calculation, adjust based on actual API pricing
        cost_per_token = 0.0001  # Example cost per token in USD
        return f"${tokens * cost_per_token:.4f}"

    def detect_code_block(self, text):
        # Use a regular expression to detect code blocks
        pattern = r'```.*?```'
        if re.search(pattern, text, re.DOTALL):
            return True
        return False

    def select_save_format(self):
        options = ["Text", "HTML", "PDF"]
        selected_option, ok = QInputDialog.getItem(self, "Select Save Format", "Choose the format to save the chat:", options, 0, False)
        if ok and selected_option:
            if selected_option == "Text":
                self.save_chat_to_file()
            elif selected_option == "HTML":
                self.save_chat_to_file()
            elif selected_option == "PDF":
                self.save_chat_to_file()

    def on_pop_out_window_closed(self, event):
        tab_name = self.pop_out_window.tab_name
        self.pop_out_windows.pop(tab_name, None)
        self.reattach_chat_widget(tab_name, self.pop_out_window.chat_data)
        super(PopOutChatWindow, self.pop_out_window).closeEvent(event)

    def send_message(self, api_type, message, response_info):
        self.message_sent.emit(api_type, message, response_info)

    def show_notification(self, message):
        if not self.isActiveWindow() or self.isMinimized():
            # Show desktop notification
            notification = QSystemTrayIcon(self)
            notification.setIcon(QIcon(resource_path("app_icon.ico")))
            notification.show()
            notification.showMessage("New Message", message, QSystemTrayIcon.Information, 5000)

    def search_messages(self, keyword):
        matching_messages = []
        for i in range(self.chat_layout.count()):
            item = self.chat_layout.itemAt(i).widget()
            if isinstance(item, QWidget):
                message_label = item.findChild(QLabel, "message")
                if message_label and keyword.lower() in message_label.text().lower():
                    matching_messages.append(message_label.text())
        return matching_messages

    def save_settings(self):
        settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
        current_tab = self.tabs.currentWidget()
        settings.setValue("api_key", current_tab.api_key_edit.toPlainText())
        settings.setValue("model", current_tab.model_dropdown.currentText())
        settings.setValue("tab_count", self.tabs.count())
        for i in range(self.tabs.count()):
            settings.setValue(f"tab_{i}_text", self.tabs.tabText(i))

    def load_settings(self):
        settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
        tab_count = settings.value("tab_count", 0, int)
        for i in range(tab_count):
            tab_text = settings.value(f"tab_{i}_text", "")
            if tab_text:
                self.add_new_tab(tab_text)
                current_tab = self.tabs.widget(i)
                current_tab.api_key_edit.setPlainText(settings.value("api_key", ""))
                model = settings.value("model", "")
                if model:
                    current_tab.model_dropdown.setCurrentText(model)

    def handle_image_message(self, image_data):
        image = QImage.fromData(image_data)
        if not image.isNull():
            pixmap = QPixmap.fromImage(image)
            image_label = QLabel()
            image_label.setPixmap(pixmap)
            self.chat_layout.addWidget(image_label)

    def get_api_url(self, api_type, model):
        api_urls = {
            "openai": {
                "default": "https://api.openai.com/v1/engines/{model}/completions",
                "chat": "https://api.openai.com/v1/chat/completions",
                "dall-e": "https://api.openai.com/v1/images/generations"
            },
            "claude": {
                "claude-3": "https://api.anthropic.com/v1/messages",
                "default": "https://api.anthropic.com/v1/complete"
            },
            "google gemini": {
                "default": "https://generativelanguage.googleapis.com/v1beta2/models/gemini-1.5:generateText",
                "chat": "https://generativelanguage.googleapis.com/v1beta2/models/gemini-1.5:generateMessage",
                "text_generation": "https://generativelanguage.googleapis.com/v1beta2/models/gemini-1.5:generateText",
                "image_generation": "https://generativelanguage.googleapis.com/v1beta2/models/gemini-1.5:generateImage",
                "content_generation": "https://generativelanguage.googleapis.com/v1beta2/models/gemini-1.5:generateContent"
            },
            "inflection_pi": {
                "default": "https://api.inflection.ai/v2/pi/chat",
                "generate_content": "https://api.inflection.ai/v2/pi/generateContent",
                "generate_text": "https://api.inflection.ai/v2/pi/generateText"
            }
        }

        if api_type == "openai":
            if model in ["gpt-3.5-turbo", "gpt-4", "gpt-4-0613", "gpt-4-0613-4o", "gpt-3.5-turbo-0613", "gpt-4o", "gpt-3.5-turbo", "gpt-4o", "gpt-4-turbo"]:
                return api_urls[api_type]["chat"]
            elif "dall-e" in model:
                return api_urls[api_type]["dall-e"]
            else:
                return api_urls[api_type]["default"].format(model=model)
        elif api_type == "claude":
            if "claude-3" in model:
                return api_urls[api_type]["claude-3"]
            else:
                return api_urls[api_type]["default"]
        elif api_type == "google gemini":
            if model == "chat":
                return api_urls[api_type]["chat"]
            elif model == "text_generation":
                return api_urls[api_type]["text_generation"]
            elif model == "image_generation":
                return api_urls[api_type]["image_generation"]
            elif model == "content_generation":
                return api_urls[api_type]["content_generation"]
            else:
                return api_urls[api_type]["default"]
        elif api_type == "inflection_pi":
            if model == "generate_content":
                return api_urls[api_type]["generate_content"]
            elif model == "generate_text":
                return api_urls[api_type]["generate_text"]
            else:
                return api_urls[api_type]["default"]
    
        return api_urls[api_type].get("default", "")

    def eventFilter(self, source, event):
        if event.type() == QEvent.KeyPress:
            current_tab = self.tabs.currentWidget()
            if source is current_tab.chat_input and event.key() == Qt.Key_Return and not (event.modifiers() & Qt.ShiftModifier):
                self.submit_user_input(current_tab.chat_input, current_tab.token_usage_label, current_tab.api_key_edit, current_tab.model_dropdown, current_tab.api_type_dropdown)
                return True
        return super().eventFilter(source, event)

class EnhancedAPICallThread(QThread):
    finished = pyqtSignal(str, str, dict)

    def __init__(self, api_type, api_key, model, user_input, api_url, show_debug=False, parent=None):
        super().__init__(parent)
        self.api_type = api_type
        self.api_key = api_key
        self.model = model
        self.user_input = user_input
        self.api_url = api_url
        self.show_debug = show_debug

    def run(self):
        try:
            headers = self.prepare_headers()
            json_data = self.prepare_payload()

            if self.show_debug:
                print(f"Debug: API call URL: {self.api_url}")
                print(f"Debug: API call headers: {headers}")
                print(f"Debug: API call data: {json_data}")

            response = requests.post(self.api_url, headers=headers, json=json_data)

            if self.show_debug:
                print(f"Debug: API response status code: {response.status_code}")
                print(f"Debug: API response content: {response.text}")

            if response.status_code == 200:
                response_data = response.json()
                self.handle_response(response_data)
            elif response.status_code == 401:
                error_message = "Unauthorized access. Please check your API key."
                print(f"Error: {error_message}")
                self.finished.emit("", self.model, {"error": error_message})
            elif response.status_code == 404:
                error_message = "API endpoint not found. Please check the API URL."
                print(f"Error: {error_message}")
                self.finished.emit("", self.model, {"error": error_message})
            else:
                error_message = f"API request failed with status code: {response.status_code}"
                print(f"Error: {error_message}")
                print(f"Error details: {response.text}")
                self.finished.emit("", self.model, {"error": error_message})

        except requests.exceptions.RequestException as e:
            error_message = f"API request failed: {str(e)}"
            print(f"Error: {error_message}")
            self.finished.emit("", self.model, {"error": error_message})

        except ValueError as e:
            error_message = str(e)
            print(f"Error: {error_message}")
            self.finished.emit("", self.model, {"error": error_message})

        except Exception as e:
            error_message = f"An error occurred: {str(e)}"
            print(f"Error: {error_message}")
            self.finished.emit("", self.model, {"error": error_message})

    def prepare_headers(self):
        if self.api_type == "openai":
            return {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
        elif self.api_type == "claude":
            return {
                "x-api-key": self.api_key,
                "anthropic-version": "2023-06-01",
                "content-type": "application/json"
            }
        elif self.api_type == "google gemini":
            return {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
        elif self.api_type == "inflection_pi":
            return {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
        else:
            raise ValueError(f"Unsupported API type: {self.api_type}")

    def prepare_payload(self):
        if self.api_type == "openai":
            return self.prepare_openai_payload()
        elif self.api_type == "claude":
            return self.prepare_claude_payload()
        elif self.api_type == "google gemini":
            return self.prepare_google_gemini_payload()
        elif self.api_type == "inflection_pi":
            return self.prepare_inflection_pi_payload()
        else:
            raise ValueError(f"Unsupported API type: {self.api_type}")

    def prepare_openai_payload(self):
        if self.model == "dall-e":
            return {"prompt": self.user_input, "n": 1, "size": "1024x1024"}
        elif "chat/completions" in self.api_url:
            return {"model": self.model, "messages": [{"role": "user", "content": self.user_input}]}
        else:
            return {"model": self.model, "prompt": self.user_input, "max_tokens": 4096, "temperature": 1.0}

    def prepare_claude_payload(self):
        if self.model.startswith("claude-3"):
            return {
                "model": self.model,
                "max_tokens": 4096,
                "messages": [
                    {"role": "user", "content": self.user_input}
                ]
            }
        else:
            return {
                "model": self.model,
                "prompt": f"\n\nHuman: {self.user_input}\n\nAssistant:",
                "max_tokens_to_sample": 2000,
                "stop_sequences": ["\n\nHuman:"],
                "temperature": 1.0
            }

    def prepare_google_gemini_payload(self):
        return {"prompt": self.user_input, "model": self.model}

    def prepare_inflection_pi_payload(self):
        return {"prompt": self.user_input, "model": self.model}

    def handle_response(self, response_data):
        if self.api_type == "claude" and "content" in response_data:
            assistant_response = response_data["content"][0]["text"].strip()
            token_usage = response_data.get('usage', {}).get('output_tokens', 0)
            self.finished.emit(assistant_response, self.model, {"status": "RESPONSE", "token_usage": token_usage})
        elif 'completion' in response_data:
            assistant_response = response_data['completion'].strip()
            token_usage = 0  # Set token usage to 0 if not provided by the API
            self.finished.emit(assistant_response, self.model, {"status": "RESPONSE", "token_usage": token_usage})
        elif 'choices' in response_data:
            assistant_response = response_data['choices'][0]['message']['content'].strip()
            token_usage = response_data.get('usage', {}).get('total_tokens', 0)
            self.finished.emit(assistant_response, self.model, {"status": "RESPONSE", "token_usage": token_usage})
        elif 'data' in response_data:
            # Handle image responses (for models like DALL-E)
            assistant_response = response_data['data'][0]['url']
            self.finished.emit(assistant_response, self.model, {"status": "RESPONSE", "token_usage": 0})
        elif 'error' in response_data:
            error_message = response_data['error']['message']
            self.finished.emit("", self.model, {"error": error_message})
        else:
            raise ValueError(f"Unexpected response structure: {response_data}")

class APIKeyManager(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("API Key Manager")
        self.setGeometry(100, 100, 400, 300)
        self.db_file = "api_keys.db"
        self.init_db()

        layout = QVBoxLayout()

        self.api_key_list = QListWidget()
        self.load_api_keys()
        layout.addWidget(self.api_key_list)

        button_layout = QHBoxLayout()
        add_button = QPushButton("Add")
        edit_button = QPushButton("Edit")
        delete_button = QPushButton("Delete")

        add_button.clicked.connect(self.add_api_key)
        edit_button.clicked.connect(self.edit_api_key)
        delete_button.clicked.connect(self.delete_api_key)

        button_layout.addWidget(add_button)
        button_layout.addWidget(edit_button)
        button_layout.addWidget(delete_button)
        layout.addLayout(button_layout)

        self.setLayout(layout)

    def init_db(self):
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute('''CREATE TABLE IF NOT EXISTS api_keys (
                            name TEXT PRIMARY KEY,
                            key TEXT,
                            added TEXT,
                            last_used TEXT)''')
        conn.commit()
        conn.close()

    def load_api_keys(self):
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute("SELECT name, key, added, last_used FROM api_keys")
        keys = cursor.fetchall()
        self.api_key_list.clear()
        for key in keys:
            name, key_value, added, last_used = key
            key_entry = f"{name} (****{key_value[-4:]}) - Added: {added} - Last Used: {last_used}"
            self.api_key_list.addItem(key_entry)
        conn.close()

    def add_api_key(self):
        name, ok = QInputDialog.getText(self, "Add API Key", "Enter name for the API key:")
        if ok and name:
            key, ok = QInputDialog.getText(self, "Add API Key", "Enter the API key:")
            if ok and key:
                added_date = QDateTime.currentDateTime().toString()
                last_used = "Never"
                conn = sqlite3.connect(self.db_file)
                cursor = conn.cursor()
                cursor.execute("INSERT INTO api_keys (name, key, added, last_used) VALUES (?, ?, ?, ?)", (name, key, added_date, last_used))
                conn.commit()
                conn.close()
                key_entry = f"{name} (****{key[-4:]}) - Added: {added_date} - Last Used: {last_used}"
                self.api_key_list.addItem(key_entry)

    def edit_api_key(self):
        current_item = self.api_key_list.currentItem()
        if current_item:
            name = current_item.text().split(" (****")[0]
            conn = sqlite3.connect(self.db_file)
            cursor = conn.cursor()
            cursor.execute("SELECT key FROM api_keys WHERE name=?", (name,))
            key_data = cursor.fetchone()
            conn.close()
            if key_data:
                new_key, ok = QInputDialog.getText(self, "Edit API Key", "Edit the API key:", text=key_data[0])
                if ok and new_key:
                    conn = sqlite3.connect(self.db_file)
                    cursor = conn.cursor()
                    cursor.execute("UPDATE api_keys SET key=? WHERE name=?", (new_key, name))
                    conn.commit()
                    conn.close()
                    added_date = current_item.text().split("Added: ")[1].split(" - Last Used: ")[0]
                    last_used = current_item.text().split(" - Last Used: ")[1]
                    key_entry = f"{name} (****{new_key[-4:]}) - Added: {added_date} - Last Used: {last_used}"
                    current_item.setText(key_entry)

    def delete_api_key(self):
        current_item = self.api_key_list.currentItem()
        if current_item:
            try:
                name = current_item.text().split(" (****")[0]
                conn = sqlite3.connect(self.db_file)
                cursor = conn.cursor()
                cursor.execute("DELETE FROM api_keys WHERE name=?", (name,))
                conn.commit()
                conn.close()
                self.api_key_list.takeItem(self.api_key_list.row(current_item))
                QMessageBox.information(self, "Success", f"API key '{name}' deleted successfully.")
                self.confirm_deletion(name)
            except Exception as e:
                print(f"Error: Failed to delete API key: {str(e)}")
                QMessageBox.critical(self, "Error", f"Failed to delete API key: {str(e)}")

    def confirm_deletion(self, name):
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM api_keys WHERE name=?", (name,))
        count = cursor.fetchone()[0]
        conn.close()
        if count == 0:
            print(f"Confirmation: API key '{name}' has been successfully deleted.")
        else:
            print(f"Error: API key '{name}' was not deleted properly.")

class MainTabWidget(QTabWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setTabsClosable(True)
        self.setTabBarAutoHide(True)
        self.setMovable(True)
        self.tabCloseRequested.connect(self.close_tab)
        self.addNewTab()

    def addNewTab(self):
        new_tab = ChatWidget(self)
        new_tab.message_sent.connect(self.handle_message_sent)
        self.addTab(new_tab, f"Chat {self.count() + 1}")
        self.setCurrentIndex(self.count() - 1)

    def close_tab(self, index):
        if self.count() > 1:
            self.removeTab(index)

    def handle_message_sent(self, api_type, message, response_info):
        current_tab = self.currentWidget()
        for i in range(self.count()):
            widget = self.widget(i)
            if widget == current_tab:
                continue
            widget.message_sent.emit(api_type, message, response_info)

    def detach_tab(self, index):
        chat_widget = self.widget(index)
        pop_out_window = PopOutChatWindow(chat_widget)
        pop_out_window.closed.connect(lambda: self.reattach_tab(pop_out_window))
        pop_out_window.show()

    def reattach_tab(self, pop_out_window):
        chat_widget = pop_out_window.centralWidget()
        self.addTab(chat_widget, f"Chat {self.count() + 1}")
        self.setCurrentWidget(chat_widget)
        pop_out_window.close()

    def wheelEvent(self, event):
        if event.modifiers() == Qt.ControlModifier:
            delta = event.angleDelta().y()
            if delta > 0:
                self.setStyleSheet("QTabBar::tab { height: 30px; }")
            else:
                self.setStyleSheet("QTabBar::tab { height: 20px; }")
        else:
            super().wheelEvent(event)
            
class WebhookSenderDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Send Webhook Message")
        self.setupUI()

    def setupUI(self):
        layout = QVBoxLayout(self)

        self.usernameEdit = QLineEdit()
        self.usernameEdit.setPlaceholderText("Enter Username")
        self.statusCheckbox = QCheckBox("Clocked In")
        self.reasonEdit = QLineEdit()
        self.reasonEdit.setPlaceholderText("Enter Reason")

        self.sendButton = QPushButton("Send Message")
        self.sendButton.clicked.connect(self.sendMessage)

        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.usernameEdit)
        layout.addWidget(QLabel("Status:"))
        layout.addWidget(self.statusCheckbox)
        layout.addWidget(QLabel("Reason:"))
        layout.addWidget(self.reasonEdit)
        layout.addWidget(self.sendButton)

    def sendMessage(self):
        username = self.usernameEdit.text().strip()
        status = self.statusCheckbox.isChecked()
        reason = self.reasonEdit.text().strip()
        self.parent().send_teams_webhook(status, reason, username)
        self.accept()
# AI Chat Widget END #        
### SPECIALFEATUREWIDGET END ###        

### GAMES START ###
# Define constants for the game
WINDOW_WIDTH = 800
WINDOW_HEIGHT = 800
HUD_HEIGHT = 50
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
COLORS = [(255, 0, 0), (0, 255, 0), (0, 0, 255), (255, 255, 0)]

class BaseGame(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.high_score = self.load_high_score()
        self.current_score = 0
        self.is_running = False
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()
        self.score_label = QLabel(f"Score: {self.current_score} | High Score: {self.high_score}")
        layout.addWidget(self.score_label)

        self.start_button = QPushButton("Start")
        self.start_button.clicked.connect(self.start_game)
        layout.addWidget(self.start_button)

        self.pause_button = QPushButton("Pause")
        self.pause_button.clicked.connect(self.pause_game)
        layout.addWidget(self.pause_button)

        self.reset_button = QPushButton("Reset")
        self.reset_button.clicked.connect(self.reset_game)
        layout.addWidget(self.reset_button)

        self.pop_out_button = QPushButton("Pop Out")
        self.pop_out_button.clicked.connect(self.pop_out)
        layout.addWidget(self.pop_out_button)

        self.game_widget = QWidget()  # Placeholder for actual game widget
        layout.addWidget(self.game_widget)

        self.setLayout(layout)

        self.game_timer = QTimer(self)
        self.game_timer.timeout.connect(self.update_game)

    def start_game(self):
        self.is_running = True
        self.game_timer.start(16)  # ~60 FPS

    def pause_game(self):
        self.is_running = not self.is_running
        if self.is_running:
            self.game_timer.start(16)
        else:
            self.game_timer.stop()

    def reset_game(self):
        self.current_score = 0
        self.update_score_display()
        # Additional reset logic here

    def update_game(self):
        if self.is_running:
            # Game logic here
            pass

    def update_score_display(self):
        self.score_label.setText(f"Score: {self.current_score} | High Score: {self.high_score}")

    def load_high_score(self):
        try:
            with open('game_settings.json', 'r') as f:
                settings = json.load(f)
                return settings.get(self.__class__.__name__, 0)
        except FileNotFoundError:
            return 0

    def save_high_score(self):
        try:
            with open('game_settings.json', 'r') as f:
                settings = json.load(f)
        except FileNotFoundError:
            settings = {}
        
        settings[self.__class__.__name__] = self.high_score
        
        with open('game_settings.json', 'w') as f:
            json.dump(settings, f)

    def pop_out(self):
        # Implement pop-out logic here
        pass

    def closeEvent(self, event):
        self.save_high_score()
        super().closeEvent(event)

class TicTacToeBoard(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.board = [' ' for _ in range(9)]
        self.player_turn = 'X'
        self.ai_difficulty = 'easy'
        self.player_score = 0
        self.ai_score = 0
        self.games_won = 0
        self.games_lost = 0
        self.games_tied = 0
        self.show_popups = True
        self.undo_available = False
        self.previous_board = None
        self.initUI()

    def initUI(self):
        # Game board
        self.buttons = []
        grid = QGridLayout()
        for i in range(9):
            button = QPushButton('')
            button.setFixedSize(80, 80)
            button.setStyleSheet("""
                QPushButton {
                    background-color: #fff;
                    border: 1px solid #ccc;
                    font-size: 32px;
                    font-weight: bold;
                }
            """)
            button.clicked.connect(lambda checked, index=i: self.makePlayerMove(index))
            self.buttons.append(button)
            grid.addWidget(self.buttons[i], i // 3, i % 3)

        # Controls
        self.start_button = QPushButton("Start")
        self.start_button.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                padding: 10px 20px;
                border: none;
                border-radius: 4px;
            }
        """)
        self.start_button.clicked.connect(self.startGame)

        self.stop_button = QPushButton("Stop")
        self.stop_button.setStyleSheet("""
            QPushButton {
                background-color: #f44336;
                color: white;
                padding: 10px 20px;
                border: none;
                border-radius: 4px;
            }
        """)
        self.stop_button.clicked.connect(self.stopGame)
        self.stop_button.setEnabled(False)

        self.difficulty_label = QLabel("Difficulty:")
        self.difficulty_combo = QComboBox()
        self.difficulty_combo.addItems(["Easy", "Medium", "Hard"])
        self.difficulty_combo.setCurrentIndex(0)
        self.difficulty_combo.currentIndexChanged.connect(self.changeDifficultyLevel)

        self.score_label = QLabel(f"Player: {self.player_score} - AI: {self.ai_score}")
        self.score_label.setAlignment(Qt.AlignCenter)

        self.show_popups_checkbox = QCheckBox("Show Popups")
        self.show_popups_checkbox.setChecked(True)
        self.show_popups_checkbox.stateChanged.connect(self.togglePopups)

        self.undo_button = QPushButton("Undo")
        self.undo_button.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                padding: 10px 20px;
                border: none;
                border-radius: 4px;
            }
        """)
        self.undo_button.clicked.connect(self.undoMove)
        self.undo_button.setEnabled(False)

        self.pop_out_button = QPushButton("Pop Out")
        self.pop_out_button.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                padding: 10px 20px;
                border: none;
                border-radius: 4px;
            }
        """)
        self.pop_out_button.clicked.connect(self.popOutWindow)

        self.stats_button = QPushButton("Game Stats")
        self.stats_button.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                padding: 10px 20px;
                border: none;
                border-radius: 4px;
            }
        """)
        self.stats_button.clicked.connect(self.showGameStats)

        controls_layout_1 = QHBoxLayout()
        controls_layout_1.addWidget(self.start_button)
        controls_layout_1.addWidget(self.stop_button)
        controls_layout_1.addWidget(self.difficulty_label)
        controls_layout_1.addWidget(self.difficulty_combo)

        controls_layout_2 = QHBoxLayout()
        controls_layout_2.addWidget(self.score_label)
        controls_layout_2.addWidget(self.show_popups_checkbox)
        controls_layout_2.addWidget(self.undo_button)

        controls_layout_3 = QHBoxLayout()
        controls_layout_3.addWidget(self.pop_out_button)
        controls_layout_3.addWidget(self.stats_button)

        main_layout = QVBoxLayout()
        main_layout.addLayout(grid)
        main_layout.addLayout(controls_layout_1)
        main_layout.addLayout(controls_layout_2)
        main_layout.addLayout(controls_layout_3)
        self.setLayout(main_layout)

    def makePlayerMove(self, index):
        if self.board[index] == ' ':
            self.saveCurrentBoard()
            self.board[index] = self.player_turn
            self.buttons[index].setText(self.player_turn)
            self.undo_available = True
            self.undo_button.setEnabled(self.undo_available)

            if self.checkWin():
                self.updateScore('player')
                self.showGameOverAnimation()
                if self.show_popups:
                    QMessageBox.information(self, 'Game Over', f'Player {self.player_turn} wins!')
                self.resetGame()
            elif ' ' not in self.board:
                self.games_tied += 1
                if self.show_popups:
                    QMessageBox.information(self, 'Game Over', 'It\'s a tie!')
                self.resetGame()
            else:
                self.player_turn = 'O'
                self.makeAIMove()

    def makeAIMove(self):
        if self.ai_difficulty == 'easy':
            move = self.getRandomMove()
        elif self.ai_difficulty == 'medium':
            move = self.getSmartMove()
        else:
            move = self.getMiniMaxMove()

        if move is not None:
            self.saveCurrentBoard()
            self.board[move] = 'O'
            self.buttons[move].setText('O')
            self.player_turn = 'X'
            self.showAIMoveAnimation(move)

            if self.checkWin():
                self.updateScore('ai')
                self.showGameOverAnimation()
                if self.show_popups:
                    QMessageBox.information(self, 'Game Over', 'AI wins!')
                self.resetGame()
            elif ' ' not in self.board:
                self.games_tied += 1
                if self.show_popups:
                    QMessageBox.information(self, 'Game Over', 'It\'s a tie!')
                self.resetGame()

        self.undo_available = True
        self.undo_button.setEnabled(self.undo_available)

    def getRandomMove(self):
        empty_cells = [i for i, cell in enumerate(self.board) if cell == ' ']
        if empty_cells:
            return random.choice(empty_cells)
        return None

    def getSmartMove(self):
        # Try to win
        for i in range(9):
            if self.board[i] == ' ':
                self.board[i] = 'O'
                if self.checkWin():
                    self.board[i] = ' '
                    return i
                self.board[i] = ' '

        # Try to block the player
        for i in range(9):
            if self.board[i] == ' ':
                self.board[i] = 'X'
                if self.checkWin():
                    self.board[i] = ' '
                    return i
                self.board[i] = ' '

        # Try to take the center
        if self.board[4] == ' ':
            return 4

        # Try to take a corner
        corners = [0, 2, 6, 8]
        for corner in corners:
            if self.board[corner] == ' ':
                return corner

        # Try to take an edge
        edges = [1, 3, 5, 7]
        for edge in edges:
            if self.board[edge] == ' ':
                return edge

        # Take any available cell
        return self.getRandomMove()

    def getMiniMaxMove(self):
        best_score = -float('inf')
        best_move = None

        for i in range(9):
            if self.board[i] == ' ':
                self.board[i] = 'O'
                score = self.minimax(self.board, 0, False)
                self.board[i] = ' '
                if score > best_score:
                    best_score = score
                    best_move = i

        return best_move

    def minimax(self, board, depth, is_maximizing):
        if self.checkWin(board, 'O'):
            return 1
        elif self.checkWin(board, 'X'):
            return -1
        elif ' ' not in board:
            return 0

        if is_maximizing:
            max_score = -float('inf')
            for i in range(9):
                if board[i] == ' ':
                    board[i] = 'O'
                    score = self.minimax(board, depth + 1, False)
                    board[i] = ' '
                    max_score = max(max_score, score)
            return max_score
        else:
            min_score = float('inf')
            for i in range(9):
                if board[i] == ' ':
                    board[i] = 'X'
                    score = self.minimax(board, depth + 1, True)
                    board[i] = ' '
                    min_score = min(min_score, score)
            return min_score

    def checkWin(self, board=None, player=None):
        if board is None:
            board = self.board
        if player is None:
            player = self.player_turn

        win_patterns = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns
            [0, 4, 8], [2, 4, 6]              # Diagonals
        ]

        for pattern in win_patterns:
            if board[pattern[0]] == player and board[pattern[1]] == player and board[pattern[2]] == player:
                self.highlightWinningLine(pattern)
                return True

        return False

    def highlightWinningLine(self, pattern):
        for i in pattern:
            self.buttons[i].setStyleSheet("""
                QPushButton {
                    background-color: #4CAF50;
                    color: white;
                    border: 1px solid #4CAF50;
                    font-size: 32px;
                    font-weight: bold;
                }
            """)
        QTimer.singleShot(2000, self.resetButtonStyles)

    def resetButtonStyles(self):
        for button in self.buttons:
            button.setStyleSheet("""
                QPushButton {
                    background-color: #fff;
                    border: 1px solid #ccc;
                    font-size: 32px;
                    font-weight: bold;
                }
            """)

    def showAIMoveAnimation(self, move):
        button = self.buttons[move]
        button.setStyleSheet("""
            QPushButton {
                background-color: #ffeb3b;
                color: #000;
                border: 1px solid #ffeb3b;
                font-size: 32px;
                font-weight: bold;
            }
        """)
        QTimer.singleShot(500, lambda: button.setStyleSheet("""
            QPushButton {
                background-color: #fff;
                border: 1px solid #ccc;
                font-size: 32px;
                font-weight: bold;
            }
        """))

    def showGameOverAnimation(self):
        for button in self.buttons:
            button.setStyleSheet("""
                QPushButton {
                    background-color: #f44336;
                    color: white;
                    border: 1px solid #f44336;
                    font-size: 32px;
                    font-weight: bold;
                }
            """)
        QTimer.singleShot(2000, self.resetButtonStyles)

    def resetGame(self):
        self.board = [' ' for _ in range(9)]
        self.player_turn = 'X'
        for button in self.buttons:
            button.setText('')
        self.resetButtonStyles()
        self.undo_available = False
        self.undo_button.setEnabled(self.undo_available)

    def changeDifficultyLevel(self, index):
        self.ai_difficulty = ['easy', 'medium', 'hard'][index]
        self.resetGame()

    def updateScore(self, winner):
        if winner == 'player':
            self.player_score += 1
            self.games_won += 1
        else:
            self.ai_score += 1
            self.games_lost += 1
        self.score_label.setText(f"Player: {self.player_score} - AI: {self.ai_score}")

    def togglePopups(self, state):
        self.show_popups = state == 1

    def startGame(self):
        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)
        self.difficulty_combo.setEnabled(False)
        self.undo_button.setEnabled(False)
        self.stats_button.setEnabled(False)

    def stopGame(self):
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        self.difficulty_combo.setEnabled(True)
        self.undo_button.setEnabled(True)
        self.stats_button.setEnabled(True)

    def popOutWindow(self):
        self.pop_out_window = TicTacToePopOutWindow(self)
        self.pop_out_window.show()

    def showGameStats(self):
        self.stats_dialog = GameStatsDialog(self)
        self.stats_dialog.exec_()

    def saveCurrentBoard(self):
        self.previous_board = self.board.copy()

    def undoMove(self):
        if self.undo_available:
            self.board = self.previous_board.copy()
            self.player_turn = 'X' if self.player_turn == 'O' else 'O'
            for i, button in enumerate(self.buttons):
                button.setText(self.board[i])
            self.undo_available = False
            self.undo_button.setEnabled(self.undo_available)

class TicTacToePopOutWindow(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Tic-Tac-Toe (Pop Out)")
        self.setMinimumSize(QSize(400, 400))
        self.game_board = TicTacToeBoard(self)
        self.setCentralWidget(self.game_board)

    def closeEvent(self, event):
        self.game_board.stopGame()
        self.game_board.setParent(self.parent())
        self.game_board.show()
        self.hide()
        event.accept()

class GameStatsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Game Statistics")
        self.setMinimumSize(QSize(300, 200))

        layout = QVBoxLayout()

        self.games_won_label = QLabel(f"Games Won: {parent.games_won}")
        self.games_lost_label = QLabel(f"Games Lost: {parent.games_lost}")
        self.games_tied_label = QLabel(f"Games Tied: {parent.games_tied}")

        layout.addWidget(self.games_won_label)
        layout.addWidget(self.games_lost_label)
        layout.addWidget(self.games_tied_label)

        self.setLayout(layout)

class TetrisBoard(QWidget):
    scoreUpdated = pyqtSignal(int)

    def __init__(self, parent=None, width=10, height=20, block_size=30):
        super().__init__(parent)
        self.width = width
        self.height = height
        self.block_size = block_size
        self.setFixedSize(width * block_size, (height + 4) * block_size)  # Extra space for next piece

        self.colors = [
            QColor(255, 56, 85),   # Red
            QColor(75, 199, 207),  # Cyan
            QColor(255, 211, 0),   # Yellow
            QColor(102, 255, 0),   # Green
            QColor(255, 0, 255),   # Magenta
            QColor(255, 136, 51),  # Orange
            QColor(0, 255, 255)    # Light Blue
        ]

        self.shapes = [
            [[1, 1, 1, 1]],
            [[1, 1], [1, 1]],
            [[0, 1, 1], [1, 1, 0]],
            [[1, 1, 0], [0, 1, 1]],
            [[1, 1, 1], [0, 1, 0]],
            [[1, 1, 1], [1, 0, 0]],
            [[1, 1, 1], [0, 0, 1]]
        ]

        self.board = [[0 for _ in range(width)] for _ in range(height)]
        self.current_piece = None
        self.next_piece = None
        self.score = 0
        self.high_score = self.load_high_score()

        self.drop_speed = 500  # milliseconds
        self.drop_timer = QTimer(self)
        self.drop_timer.timeout.connect(self.drop_piece)

        self.is_paused = False
        self.is_game_over = True

        self.setFocusPolicy(Qt.StrongFocus)

    def new_piece(self):
        shape = random.choice(self.shapes)
        color = random.choice(self.colors)
        return {
            'shape': shape,
            'color': color,
            'x': self.width // 2 - len(shape[0]) // 2,
            'y': 0
        }

    def start_game(self):
        if self.is_game_over:
            self.reset_game()
        self.is_paused = False
        self.is_game_over = False
        self.drop_timer.start(self.drop_speed)

    def pause_game(self):
        if not self.is_game_over:
            self.is_paused = not self.is_paused
            if self.is_paused:
                self.drop_timer.stop()
            else:
                self.drop_timer.start(self.drop_speed)

    def reset_game(self):
        self.board = [[0 for _ in range(self.width)] for _ in range(self.height)]
        self.current_piece = self.new_piece()
        self.next_piece = self.new_piece()
        self.score = 0
        self.scoreUpdated.emit(self.score)
        self.is_game_over = False
        self.is_paused = False
        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        self.draw_board(painter)
        self.draw_current_piece(painter)
        self.draw_next_piece(painter)
        self.draw_border(painter)

    def draw_board(self, painter):
        for y, row in enumerate(self.board):
            for x, cell in enumerate(row):
                if cell:
                    painter.fillRect(x * self.block_size, y * self.block_size,
                                     self.block_size - 1, self.block_size - 1,
                                     self.colors[cell - 1])

    def draw_current_piece(self, painter):
        if self.current_piece:
            for y, row in enumerate(self.current_piece['shape']):
                for x, cell in enumerate(row):
                    if cell:
                        painter.fillRect((self.current_piece['x'] + x) * self.block_size,
                                         (self.current_piece['y'] + y) * self.block_size,
                                         self.block_size - 1, self.block_size - 1,
                                         self.current_piece['color'])

    def draw_next_piece(self, painter):
        if self.next_piece:
            for y, row in enumerate(self.next_piece['shape']):
                for x, cell in enumerate(row):
                    if cell:
                        painter.fillRect((self.width + 1 + x) * self.block_size,
                                         (1 + y) * self.block_size,
                                         self.block_size - 1, self.block_size - 1,
                                         self.next_piece['color'])

    def draw_border(self, painter):
        pen = QPen(Qt.white)
        pen.setWidth(2)
        painter.setPen(pen)
        painter.drawRect(0, 0, self.width * self.block_size, self.height * self.block_size)
        painter.drawRect(self.width * self.block_size, 0, 4 * self.block_size, 4 * self.block_size)

    def keyPressEvent(self, event):
        if self.is_paused or self.is_game_over:
            return

        if event.key() == Qt.Key_Left:
            self.move_piece(-1)
        elif event.key() == Qt.Key_Right:
            self.move_piece(1)
        elif event.key() == Qt.Key_Up:
            self.rotate_piece()
        elif event.key() == Qt.Key_Down:
            self.drop_piece()
        self.update()

    def move_piece(self, dx):
        if self.current_piece:
            self.current_piece['x'] += dx
            if self.piece_collision():
                self.current_piece['x'] -= dx

    def rotate_piece(self):
        if self.current_piece:
            rotated = list(zip(*self.current_piece['shape'][::-1]))
            if not self.collision_check(rotated, self.current_piece['x'], self.current_piece['y']):
                self.current_piece['shape'] = rotated

    def drop_piece(self):
        if self.current_piece:
            self.current_piece['y'] += 1
            if self.piece_collision():
                self.current_piece['y'] -= 1
                self.lock_piece()
            self.update()

    def lock_piece(self):
        for y, row in enumerate(self.current_piece['shape']):
            for x, cell in enumerate(row):
                if cell:
                    self.board[y + self.current_piece['y']][x + self.current_piece['x']] = self.colors.index(self.current_piece['color']) + 1
        self.clear_lines()
        self.current_piece = self.next_piece
        self.next_piece = self.new_piece()
        if self.piece_collision():
            self.game_over()

    def piece_collision(self):
        return self.collision_check(self.current_piece['shape'],
                                    self.current_piece['x'],
                                    self.current_piece['y'])

    def collision_check(self, shape, x, y):
        for y_offset, row in enumerate(shape):
            for x_offset, cell in enumerate(row):
                if cell:
                    if (y + y_offset >= self.height or
                        x + x_offset < 0 or
                        x + x_offset >= self.width or
                        self.board[y + y_offset][x + x_offset]):
                        return True
        return False

    def clear_lines(self):
        lines_cleared = 0
        for i in range(self.height - 1, -1, -1):
            if all(self.board[i]):
                del self.board[i]
                self.board.insert(0, [0 for _ in range(self.width)])
                lines_cleared += 1
        self.score += lines_cleared ** 2 * 100
        self.scoreUpdated.emit(self.score)
        if self.score > self.high_score:
            self.high_score = self.score
            self.save_high_score()

    def game_over(self):
        self.is_game_over = True
        self.drop_timer.stop()

    def load_high_score(self):
        settings = QSettings("YourCompany", "Tetris")
        return settings.value("high_score", 0, type=int)

    def save_high_score(self):
        settings = QSettings("YourCompany", "Tetris")
        settings.setValue("high_score", self.high_score)

class TetrisPopOutWindow(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Tetris")
        self.setWindowFlags(Qt.Window)
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.layout = QVBoxLayout(self.central_widget)
        self.tetris_board = TetrisBoard(self)
        self.name_label = QLabel("Tetris")
        self.name_label.setAlignment(Qt.AlignCenter)
        self.layout.addWidget(self.name_label)

        self.high_score_label = QLabel(f"High Score: {self.tetris_board.high_score}")
        self.high_score_label.setAlignment(Qt.AlignCenter)
        self.layout.addWidget(self.high_score_label)

        self.score_label = QLabel("Score: 0")
        self.score_label.setAlignment(Qt.AlignCenter)
        self.layout.addWidget(self.score_label)

        self.layout.addWidget(self.tetris_board)

        button_layout = QHBoxLayout()
        self.start_button = QPushButton("Start")
        self.start_button.clicked.connect(self.tetris_board.start_game)
        button_layout.addWidget(self.start_button)

        self.pause_button = QPushButton("Pause")
        self.pause_button.clicked.connect(self.tetris_board.pause_game)
        button_layout.addWidget(self.pause_button)

        self.layout.addLayout(button_layout)

        self.tetris_board.scoreUpdated.connect(self.update_score)

    def update_score(self, score):
        self.score_label.setText(f"Score: {score}")
        self.high_score_label.setText(f"High Score: {self.tetris_board.high_score}")

class Brick(pygame.Rect):
    def __init__(self, x, y, width, height, color, points, health=1, moving=False):
        super().__init__(x, y, width, height)
        self.color = color
        self.points = points
        self.health = health
        self.moving = moving
        self.speed = random.choice([-2, -1, 1, 2]) if moving else 0

    def update(self):
        if self.moving:
            self.x += self.speed
            if self.left <= 0 or self.right >= WINDOW_WIDTH:
                self.speed *= -1

class PowerUp(pygame.Rect):
    def __init__(self, x, y, width, height, type):
        super().__init__(x, y, width, height)
        self.type = type
        self.speed = 3

    def update(self):
        self.y += self.speed

class Particle(pygame.Rect):
    def __init__(self, x, y, color):
        super().__init__(x, y, 2, 2)  # Small size for particles
        self.color = color
        self.velocity = [random.uniform(-2, 2), random.uniform(-2, 2)]
        self.lifetime = 50  # Lifetime of the particle

    def update(self):
        self.x += self.velocity[0]
        self.y += self.velocity[1]
        self.lifetime -= 1

    def is_alive(self):
        return self.lifetime > 0

class BreakoutGame(QWidget):
    gameClosed = pyqtSignal(int)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.initUI()
        self.initGame()
        self.timer = QTimer()
        self.timer.timeout.connect(self.run)
        self.is_popped_out = False
        self.load_settings()
        self.paddle_speed = 10
        self.active_power_up = None
        self.extreme_error_handling()
        self.particles = []
        self.powerup_timer = 0
        self.border_color = None

    def initUI(self):
        self.setWindowTitle("Breakout Game")
        self.setLayout(QVBoxLayout())

        self.menu_bar = QMenuBar(self)
        self.menu = QMenu("Menu", self)
        self.menu_bar.addMenu(self.menu)

        start_action = QAction("Start Game", self)
        start_action.triggered.connect(self.startGame)
        self.menu.addAction(start_action)

        pause_action = QAction("Pause Game", self)
        pause_action.triggered.connect(self.pauseGame)
        self.menu.addAction(pause_action)

        restart_action = QAction("Restart Game", self)
        restart_action.triggered.connect(self.restartGame)
        self.menu.addAction(restart_action)

        controls_action = QAction("Show Controls", self)
        controls_action.triggered.connect(self.showControls)
        self.menu.addAction(controls_action)

        self.layout().setMenuBar(self.menu_bar)

        button_layout = QHBoxLayout()
        self.start_button = QPushButton("Start")
        self.start_button.clicked.connect(self.startGame)
        button_layout.addWidget(self.start_button)
        
        self.pause_button = QPushButton("Pause")
        self.pause_button.clicked.connect(self.pauseGame)
        button_layout.addWidget(self.pause_button)
        
        self.restart_button = QPushButton("Restart")
        self.restart_button.clicked.connect(self.restartGame)
        button_layout.addWidget(self.restart_button)
        
        self.layout().addLayout(button_layout)

        self.game_surface = pygame.Surface((WINDOW_WIDTH, WINDOW_HEIGHT - HUD_HEIGHT))
        self.hud_surface = pygame.Surface((WINDOW_WIDTH, HUD_HEIGHT))

    def initGame(self):
        self.score = 0
        self.lives = 3
        self.level = 1
        self.bricks = []
        self.power_ups = []
        self.ball_speed_x = 5
        self.ball_speed_y = -5
        self.create_bricks()
        self.paddle = pygame.Rect(WINDOW_WIDTH // 2 - 50, WINDOW_HEIGHT - 100, 100, 20)
        self.ball = pygame.Rect(WINDOW_WIDTH // 2 - 7, WINDOW_HEIGHT - 120, 15, 15)
        self.running = False
        self.start_time = time.time()
        self.play_time = 0
        self.paddle_width = 100
        self.ball_size = 15
        self.multiball = False
        self.balls = [self.ball]
        self.high_score = 0

    def create_bricks(self):
        self.bricks.clear()
        rows = min(self.level + 2, 10)
        cols = 10
        brick_width = (WINDOW_WIDTH - 20) // cols
        brick_height = 20

        for row in range(rows):
            for col in range(cols):
                brick_x = col * brick_width + 10
                brick_y = row * (brick_height + 5) + HUD_HEIGHT
                color = COLORS[row % len(COLORS)]
                points = (rows - row) * 10
                health = random.randint(1, min(3, (self.level + 1) // 2))
                moving = random.random() < 0.1 * self.level

                brick = Brick(brick_x, brick_y, brick_width - 5, brick_height, color, points, health, moving)
                self.bricks.append(brick)

    def run(self):
        try:
            if self.running:
                self.handleEvents()
                self.update()
                self.draw()
        except Exception as e:
            print(f"Error in game loop: {e}")
            self.running = False
            self.timer.stop()
            pygame.quit()

    def handleEvents(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.closeGame()

        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT] and self.paddle.left > 0:
            self.paddle.left -= self.paddle_speed
        if keys[pygame.K_RIGHT] and self.paddle.right < WINDOW_WIDTH:
            self.paddle.right += self.paddle_speed
        if keys[pygame.K_SPACE]:
            if self.active_power_up:
                self.activate_power_up(self.active_power_up)
                self.active_power_up = None

    def update(self):
        self.play_time = int(time.time() - self.start_time)

        for brick in self.bricks:
            if brick.moving:
                brick.update()

        for power_up in self.power_ups[:]:
            power_up.update()
            if power_up.top > WINDOW_HEIGHT:
                self.power_ups.remove(power_up)
            elif power_up.colliderect(self.paddle):
                self.active_power_up = power_up.type
                self.power_ups.remove(power_up)
                self.display_powerup_message(self.active_power_up)

        for ball in self.balls[:]:
            self.update_ball(ball)

        if len(self.balls) == 0:
            self.lives -= 1
            self.notifyHUD("Life lost! Lives remaining: " + str(self.lives))
            if self.lives == 0:
                self.gameOver()
            else:
                self.resetBall()

        if len(self.bricks) == 0:
            self.level_up()

        # Update particles
        for particle in self.particles[:]:
            particle.update()
            if not particle.is_alive():
                self.particles.remove(particle)

        # Update powerup timer
        if self.powerup_timer > 0:
            self.powerup_timer -= 1
            if self.powerup_timer == 0:
                self.border_color = None

    def update_ball(self, ball):
        ball.x += self.ball_speed_x
        ball.y += self.ball_speed_y

        if ball.top <= 0:
            self.ball_speed_y *= -1
        if ball.right >= WINDOW_WIDTH or ball.left <= 0:
            self.ball_speed_x *= -1

        if ball.colliderect(self.paddle):
            self.ball_speed_y *= -1
            self.ball_speed_x += (ball.centerx - self.paddle.centerx) / (self.paddle.width // 2)
            self.ball_speed_x = max(min(self.ball_speed_x, 8), -8)

        for brick in self.bricks[:]:
            if ball.colliderect(brick):
                brick.health -= 1
                if brick.health <= 0:
                    self.bricks.remove(brick)
                    self.score += brick.points
                    if random.random() < 0.1:
                        self.spawn_power_up(brick.centerx, brick.centery)
                    self.play_break_effect(brick.centerx, brick.centery)
                self.ball_speed_y *= -1

        if ball.top >= WINDOW_HEIGHT:
            self.balls.remove(ball)

    def spawn_power_up(self, x, y):
        power_up_type = random.choice(['expand', 'shrink', 'multiball', 'slow', 'fast'])
        power_up = PowerUp(x, y, 30, 30, power_up_type)
        self.power_ups.append(power_up)

    def activate_power_up(self, power_up_type):
        if power_up_type == 'expand':
            self.paddle_width = min(200, self.paddle_width + 20)
            self.paddle.width = self.paddle_width
        elif power_up_type == 'shrink':
            self.paddle_width = max(60, self.paddle_width - 20)
            self.paddle.width = self.paddle_width
        elif power_up_type == 'multiball':
            self.multiball = True
            new_ball = pygame.Rect(self.paddle.centerx, self.paddle.top - 15, self.ball_size, self.ball_size)
            self.balls.append(new_ball)
        elif power_up_type == 'slow':
            self.ball_speed_x *= 0.8
            self.ball_speed_y *= 0.8
        elif power_up_type == 'fast':
            self.ball_speed_x *= 1.2
            self.ball_speed_y *= 1.2
        self.border_color = self.get_powerup_color(power_up_type)
        self.powerup_timer = 600  # 10 seconds at 60 FPS

        if power_up_type == 'ice':
            self.apply_ice_effect()
        elif power_up_type == 'fire':
            self.apply_fire_effect()            

        # Visual cue for power-up
        self.display_powerup_message(power_up_type)

    def apply_ice_effect(self):
        for brick in self.bricks:
            if self.ball.colliderect(brick):
                brick.health -= 1
                if brick.health <= 0:
                    self.bricks.remove(brick)
                    self.score += brick.points
                    self.freeze_adjacent_bricks(brick)

    def apply_fire_effect(self):
        for brick in self.bricks:
            if self.ball.colliderect(brick):
                brick.health -= 1
                if brick.health <= 0:
                    self.bricks.remove(brick)
                    self.score += brick.points
                    self.burn_random_bricks(brick)

    def freeze_adjacent_bricks(self, brick):
        adjacent_bricks = [b for b in self.bricks if abs(b.centerx - brick.centerx) <= brick.width and abs(b.centery - brick.centery) <= brick.height]
        for adj_brick in adjacent_bricks:
            adj_brick.color = (0, 255, 255)  # Light blue for frozen bricks
            QTimer.singleShot(3000, lambda b=adj_brick: self.break_frozen_brick(b))

    def burn_random_bricks(self, brick):
        num_affected = random.randint(2, 5)
        affected_bricks = random.sample(self.bricks, min(num_affected, len(self.bricks)))
        for affected_brick in affected_bricks:
            affected_brick.color = (255, 165, 0)  # Orange for burning bricks
            QTimer.singleShot(3000, lambda b=affected_brick: self.break_burning_brick(b))

    def break_frozen_brick(self, brick):
        if brick in self.bricks:
            self.bricks.remove(brick)
            self.score += brick.points
            self.play_break_effect(brick.centerx, brick.centery)

    def break_burning_brick(self, brick):
        if brick in self.bricks:
            self.bricks.remove(brick)
            self.score += brick.points
            self.play_break_effect(brick.centerx, brick.centery)

    def display_powerup_message(self, power_up_type):
        if power_up_type == 'expand':
            self.notifyHUD("Expand Power-up Obtained!")
        elif power_up_type == 'shrink':
            self.notifyHUD("Shrink Power-up Obtained!")
        elif power_up_type == 'multiball':
            self.notifyHUD("Multiball Power-up Obtained!")
        elif power_up_type == 'slow':
            self.notifyHUD("Slow Ball Power-up Obtained!")
        elif power_up_type == 'fast':
            self.notifyHUD("Fast Ball Power-up Obtained!")
        # Add screen border color change
        self.screen_border_color = self.get_powerup_color(power_up_type)

    def get_powerup_color(self, power_up_type):
        if power_up_type == 'expand':
            return (0, 255, 0)
        elif power_up_type == 'shrink':
            return (255, 0, 0)
        elif power_up_type == 'multiball':
            return (0, 0, 255)
        elif power_up_type == 'slow':
            return (255, 255, 0)
        elif power_up_type == 'fast':
            return (255, 0, 255)

    def draw(self):
        self.game_surface.fill(BLACK)
        self.hud_surface.fill(BLACK)

        # Draw game elements on game_surface
        pygame.draw.rect(self.game_surface, WHITE, self.paddle)
        for ball in self.balls:
            pygame.draw.circle(self.game_surface, WHITE, (ball.centerx, ball.centery), ball.width // 2)
        for brick in self.bricks:
            pygame.draw.rect(self.game_surface, brick.color, brick)
        for power_up in self.power_ups:
            pygame.draw.rect(self.game_surface, self.get_powerup_color(power_up.type), power_up)
        for particle in self.particles:
            pygame.draw.rect(self.game_surface, particle.color, particle)

        # Draw HUD elements on hud_surface
        score_text = self.font.render(f"Score: {self.score}", True, WHITE)
        lives_text = self.font.render(f"Lives: {self.lives}", True, WHITE)
        high_score_text = self.font.render(f"High Score: {self.high_score}", True, WHITE)
        level_text = self.font.render(f"Level: {self.level}", True, WHITE)
        time_text = self.font.render(f"Time: {self.play_time}s", True, WHITE)

        self.hud_surface.blit(score_text, (10, 10))
        self.hud_surface.blit(lives_text, (10, 40))
        self.hud_surface.blit(high_score_text, (WINDOW_WIDTH - 200, 10))
        self.hud_surface.blit(level_text, (WINDOW_WIDTH - 200, 40))
        self.hud_surface.blit(time_text, (WINDOW_WIDTH // 2 - 50, 10))

        # Combine surfaces
        self.window.blit(self.hud_surface, (0, 0))
        self.window.blit(self.game_surface, (0, HUD_HEIGHT))

        # Draw border if active
        if self.border_color:
            pygame.draw.rect(self.window, self.border_color, self.window.get_rect(), 10)

        pygame.display.flip()

    def resetBall(self):
        self.balls = [pygame.Rect(WINDOW_WIDTH // 2 - 7, WINDOW_HEIGHT - 120, self.ball_size, self.ball_size)]
        self.ball_speed_x = 5
        self.ball_speed_y = -5
        self.multiball = False

    def level_up(self):
        self.level += 1
        self.create_bricks()
        self.resetBall()
        self.paddle_width = 100
        self.paddle.width = self.paddle_width
        self.ball_speed_x *= 1.1
        self.ball_speed_y *= 1.1
        self.notifyHUD("Level up! Level: " + str(self.level))

    def gameOver(self):
        self.running = False
        self.timer.stop()
        print(f"Game Over! Final Score: {self.score}")
        if self.score > self.high_score:
            self.high_score = self.score
            self.save_settings()
        self.gameClosed.emit(self.high_score)
        self.notifyHUD("Game Over! Final Score: " + str(self.score))

    def play_break_effect(self, x, y):
        for _ in range(20):  # Number of particles
            particle = Particle(x, y, random.choice(COLORS))
            self.particles.append(particle)

    def launchGame(self):
        self.startGame()

    def startGame(self):
        pygame.init()
        self.window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(None, 36)
        self.running = True
        self.start_time = time.time()
        self.timer.start(16)

    def pauseGame(self):
        if self.running:
            self.running = False
            self.timer.stop()
        else:
            self.running = True
            self.start_time += time.time() - (self.start_time + self.play_time)
            self.timer.start(16)
        self.notifyHUD("Game Paused" if not self.running else "Game Resumed")

    def restartGame(self):
        self.stopGame()
        self.initGame()
        self.startGame()
        self.notifyHUD("Game Restarted")

    def stopGame(self):
        self.running = False
        self.timer.stop()
        pygame.quit()

    def closeEvent(self, event):
        self.stopGame()
        event.accept()
        
    def closeGame(self):
        self.running = False
        self.timer.stop()
        pygame.quit()
        self.close()

    def load_settings(self):
        if os.path.exists('breakout_settings.json'):
            with open('breakout_settings.json', 'r') as f:
                settings = json.load(f)
                self.high_score = settings.get('high_score', 0)
        else:
            self.high_score = 0

    def save_settings(self):
        settings = {
            'high_score': self.high_score
        }
        with open('breakout_settings.json', 'w') as f:
            json.dump(settings, f)

    def showControls(self):
        QMessageBox.information(self, "Controls", 
                                "Left Arrow: Move paddle left\n"
                                "Right Arrow: Move paddle right\n"
                                "Space: Launch power-up\n"
                                "Pause: Pause/Resume game\n"
                                "Restart: Restart game")

    def notifyHUD(self, message):
        # Implement HUD notification system
        print(message)

    def extreme_error_handling(self):
        try:
            # Ensure pygame resources are initialized properly
            pygame.display.init()
            pygame.font.init()
        except pygame.error as e:
            print(f"Error initializing pygame: {e}")
            self.running = False
            self.timer.stop()
            pygame.quit()

class PopOutWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Breakout Game (Pop Out)")
        self.game_widget = BreakoutGame(self)
        self.game_widget.gameClosed.connect(self.onGameClosed)
        layout = QVBoxLayout()
        layout.addWidget(self.game_widget)
        self.setLayout(layout)

    def showEvent(self, event):
        self.game_widget.startGame()

    def closeEvent(self, event):
        self.game_widget.stopGame()
        self.parent().updateHighScore(self.game_widget.high_score)
        event.accept()

    def onGameClosed(self, high_score):
        self.close()

class BaseGame(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.high_score = self.load_high_score()
        self.current_score = 0
        self.is_running = False
        self.init_ui()

    def init_ui(self):
        layout = QGridLayout()
        self.score_label = QLabel(f"Score: {self.current_score} | High Score: {self.high_score}")
        layout.addWidget(self.score_label, 0, 0, 1, 3)

        self.start_button = QPushButton("Start")
        self.start_button.clicked.connect(self.start_game)
        layout.addWidget(self.start_button, 1, 0)

        self.pause_button = QPushButton("Pause")
        self.pause_button.clicked.connect(self.pause_game)
        layout.addWidget(self.pause_button, 1, 1)

        self.reset_button = QPushButton("Reset")
        self.reset_button.clicked.connect(self.reset_game)
        layout.addWidget(self.reset_button, 1, 2)

        self.controls_button = QPushButton("Controls")
        self.controls_button.clicked.connect(self.show_controls)
        layout.addWidget(self.controls_button, 2, 0)

        self.pop_out_button = QPushButton("Pop Out")
        self.pop_out_button.clicked.connect(self.pop_out)
        layout.addWidget(self.pop_out_button, 2, 1)

        self.game_widget = QWidget()
        self.game_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        layout.addWidget(self.game_widget, 3, 0, 1, 3)

        self.level_label = QLabel(f"Level: 1")
        layout.addWidget(self.level_label, 4, 0, 1, 3)

        self.setLayout(layout)

        self.game_timer = QTimer(self)
        self.game_timer.timeout.connect(self.update_game)

    def start_game(self):
        self.is_running = True
        self.game_timer.start(16)  # ~60 FPS
        self.setFocus()

    def pause_game(self):
        self.is_running = not self.is_running
        if self.is_running:
            self.game_timer.start(16)
        else:
            self.game_timer.stop()

    def reset_game(self):
        self.current_score = 0
        self.update_score_display()
        # Additional reset logic here

    def update_game(self):
        if self.is_running:
            # Game logic here
            pass

    def update_score_display(self):
        self.score_label.setText(f"Score: {self.current_score} | High Score: {self.high_score}")

    def load_high_score(self):
        try:
            with open('game_settings.json', 'r') as f:
                settings = json.load(f)
                return settings.get(self.__class__.__name__, 0)
        except FileNotFoundError:
            return 0

    def save_high_score(self):
        try:
            with open('game_settings.json', 'r') as f:
                settings = json.load(f)
        except FileNotFoundError:
            settings = {}
        
        settings[self.__class__.__name__] = self.high_score
        
        with open('game_settings.json', 'w') as f:
            json.dump(settings, f)

    def show_controls(self):
        QMessageBox.information(self, "Controls",
                                "Arrow keys: Move snake\n"
                                "P: Pause/Resume game\n"
                                "R: Reset game\n"
                                "Space: Activate power-up (if available)")

    def pop_out(self):
        self.pop_out_window = SnakeGamePopOut(self)
        self.pop_out_window.showMaximized()

    def closeEvent(self, event):
        self.save_high_score()
        super().closeEvent(event)

class SnakeGame(BaseGame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.grid_size = 20
        self.cell_size = 20
        self.snake = [(self.grid_size // 2, self.grid_size // 2)]
        self.power_up = None
        self.direction = (1, 0)
        self.colors = [QColor(255, 0, 0), QColor(0, 255, 0), QColor(0, 0, 255),
                       QColor(255, 255, 0), QColor(255, 0, 255), QColor(0, 255, 255)]
        self.dark_colors = [QColor(0, 0, 0), QColor(0, 0, 139), QColor(85, 26, 139)]
        self.snake_color = self.get_different_color(self.dark_colors)
        self.food_color = self.get_different_color([self.snake_color] + self.dark_colors)
        self.power_up_color = self.get_different_color([self.snake_color, self.food_color] + self.dark_colors)
        self.background_color = self.get_different_dark_color([self.snake_color, self.food_color, self.power_up_color])
        self.border_color = QColor(255, 255, 255)
        self.food = self.spawn_food()
        self.power_up_timer = 0
        self.level = 1
        self.speed = 150  # milliseconds
        self.rainbow_mode = False
        self.active_power_up = None
        self.init_game_ui()

    def get_different_color(self, exclude_colors=[]):
        available_colors = [color for color in self.colors if color not in exclude_colors]
        return random.choice(available_colors) if available_colors else random.choice(self.colors)

    def get_different_dark_color(self, exclude_colors=[]):
        available_colors = [color for color in self.dark_colors if color not in exclude_colors]
        return random.choice(available_colors) if available_colors else random.choice(self.dark_colors)

    def init_game_ui(self):
        self.game_widget = GameWidget(self)
        self.layout().addWidget(self.game_widget, 3, 0, 1, 3)

        self.level_label = QLabel(f"Level: {self.level}")
        self.layout().addWidget(self.level_label, 4, 0, 1, 3)

        self.power_up_label = QLabel(f"Power-up: None")
        self.layout().addWidget(self.power_up_label, 5, 0, 1, 3)

    def start_game(self):
        super().start_game()
        self.game_timer.start(self.speed)
        self.setFocus()

    def update_game(self):
        if not self.is_running:
            return

        new_head = (self.snake[0][0] + self.direction[0], self.snake[0][1] + self.direction[1])

        # Allow snake to go through walls
        new_head = (new_head[0] % self.grid_size, new_head[1] % self.grid_size)

        # Check for collisions with itself
        if new_head in self.snake:
            self.game_over()
            return

        self.snake.insert(0, new_head)

        # Check for food
        if new_head == self.food:
            self.current_score += 1
            self.food = self.spawn_food()
            self.update_score_display()
            self.check_level_up()
        else:
            self.snake.pop()

        # Check for power-up
        if self.power_up and new_head == self.power_up:
            self.activate_power_up()

        # Update power-up timer
        if self.power_up_timer > 0:
            self.power_up_timer -= 1
            if self.power_up_timer == 0:
                self.deactivate_power_up()

        # Spawn new power-up
        if not self.power_up and random.random() < 0.02:  # 2% chance each update
            self.power_up = self.spawn_power_up()

        self.game_widget.update()

    def spawn_food(self):
        while True:
            food = (random.randint(0, self.grid_size - 1), random.randint(0, self.grid_size - 1))
            if food not in self.snake and food != self.power_up:
                self.food_color = self.get_different_color([self.snake_color, self.background_color, self.power_up_color])
                return food

    def spawn_power_up(self):
        while True:
            power_up = (random.randint(0, self.grid_size - 1), random.randint(0, self.grid_size - 1))
            if power_up not in self.snake and power_up != self.food:
                self.power_up_color = self.get_different_color([self.snake_color, self.background_color, self.food_color])
                return power_up

    def activate_power_up(self):
        power_up_type = random.choice(['snake_color', 'background_color', 'border_color', 'rainbow', 'add_segment'])
        self.active_power_up = power_up_type
        self.power_up_label.setText(f"Power-up: {power_up_type.replace('_', ' ').capitalize()}")

        if power_up_type == 'snake_color':
            self.snake_color = self.get_different_color([self.background_color, self.food_color, self.power_up_color])
        elif power_up_type == 'background_color':
            self.background_color = self.get_different_dark_color([self.snake_color, self.food_color, self.power_up_color])
        elif power_up_type == 'border_color':
            self.border_color = self.get_different_color([self.snake_color, self.food_color, self.power_up_color])
        elif power_up_type == 'rainbow':
            self.rainbow_mode = True
        elif power_up_type == 'add_segment':
            self.snake.append(self.snake[-1])  # Add a segment to the snake

        self.power_up = None
        self.power_up_timer = 100  # Active for 100 updates

    def deactivate_power_up(self):
        self.snake_color = self.get_different_color([self.background_color, self.food_color, self.power_up_color])
        self.background_color = self.get_different_dark_color([self.snake_color, self.food_color, self.power_up_color])
        self.border_color = self.get_different_color([self.snake_color, self.food_color, self.power_up_color])
        self.rainbow_mode = False
        self.active_power_up = None
        self.power_up_label.setText("Power-up: None")

    def check_level_up(self):
        if self.current_score > 0 and self.current_score % 5 == 0:
            self.level += 1
            self.speed = max(50, self.speed - 10)
            self.game_timer.setInterval(self.speed)
            self.level_label.setText(f"Level: {self.level}")

    def game_over(self):
        self.is_running = False
        self.game_timer.stop()
        if self.current_score > self.high_score:
            self.high_score = self.current_score
            self.save_high_score()
        self.update_score_display()
        QMessageBox.information(self, "Game Over", f"Your score: {self.current_score}\nHigh score: {self.high_score}")

    def reset_game(self):
        super().reset_game()
        self.snake = [(self.grid_size // 2, self.grid_size // 2)]
        self.direction = (1, 0)
        self.food = self.spawn_food()
        self.power_up = None
        self.power_up_timer = 0
        self.level = 1
        self.speed = 150
        self.game_timer.setInterval(self.speed)
        self.level_label.setText(f"Level: {self.level}")
        self.deactivate_power_up()
        self.game_widget.update()

    def keyPressEvent(self, event: QEvent):
        key = event.key()
        if key == Qt.Key_Left and self.direction != (1, 0):
            self.direction = (-1, 0)
        elif key == Qt.Key_Right and self.direction != (-1, 0):
            self.direction = (1, 0)
        elif key == Qt.Key_Up and self.direction != (0, 1):
            self.direction = (0, -1)
        elif key == Qt.Key_Down and self.direction != (0, -1):
            self.direction = (0, 1)

    def pop_out(self):
        self.pop_out_window = SnakeGamePopOut(self)
        self.pop_out_window.showMaximized()

class GameWidget(QWidget):
    def __init__(self, game):
        super().__init__()
        self.game = game

    def paintEvent(self, event):
        painter = QPainter(self)
        
        # Draw background
        painter.fillRect(event.rect(), QBrush(self.game.background_color))
        
        # Draw snake
        for i, segment in enumerate(self.game.snake):
            if hasattr(self.game, 'rainbow_mode') and self.game.rainbow_mode:
                color = self.game.colors[i % len(self.game.colors)]
            else:
                color = self.game.snake_color
            painter.fillRect(QRect(segment[0] * self.game.cell_size, segment[1] * self.game.cell_size,
                                   self.game.cell_size, self.game.cell_size), QBrush(color))
        
        # Draw food
        painter.fillRect(QRect(self.game.food[0] * self.game.cell_size, self.game.food[1] * self.game.cell_size,
                               self.game.cell_size, self.game.cell_size), QBrush(self.game.food_color))
        
        # Draw power-up
        if self.game.power_up:
            painter.fillRect(QRect(self.game.power_up[0] * self.game.cell_size, self.game.power_up[1] * self.game.cell_size,
                                   self.game.cell_size, self.game.cell_size), QBrush(self.game.power_up_color))
        
        # Draw border
        painter.setPen(self.game.border_color)
        painter.drawRect(0, 0, self.game.grid_size * self.game.cell_size - 1, self.game.grid_size * self.game.cell_size - 1)

class SnakeGamePopOut(QMainWindow):
    def __init__(self, game, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Snake Game")
        self.setCentralWidget(game)
        self.resize(800, 800)  # Set initial size

    def resizeEvent(self, event):
        self.centralWidget().setFixedSize(event.size())
        super().resizeEvent(event)

    def closeEvent(self, event):
        self.centralWidget().setParent(self.centralWidget().parent())
        event.accept()
################################ OMNI OMEGA END ################################

################################ SCREEN TOOL START ################################

def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    base_path = getattr(sys, '_MEIPASS', os.getcwd())
    final_path = os.path.join(base_path, relative_path)
    if not os.path.exists(final_path):
        # This fallback assumes the image is in the same directory as the script when running in VS
        final_path = os.path.join(os.path.dirname(__file__), relative_path)
    return final_path

def create_config_file(config_path, default_config):
    if not os.path.exists(config_path):
        os.makedirs(os.path.dirname(config_path), exist_ok=True)
        with open(config_path, 'w') as config_file:
            json.dump(default_config, config_file, indent=4)

def read_config_file(config_path):
    if os.path.exists(config_path):
        with open(config_path, 'r') as config_file:
            return json.load(config_file)
    return {}

def update_config_file(config_path, new_config):
    with open(config_path, 'w') as config_file:
        json.dump(new_config, config_file, indent=4)

def init_config_db(db_path, default_config):
    # Ensure the directory exists
    os.makedirs(os.path.dirname(db_path), exist_ok=True)
    
    # Connect to the SQLite database (this creates it if it doesn't exist)
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    
    # Create the config table if it doesn't exist
    c.execute('''CREATE TABLE IF NOT EXISTS config
                 (key TEXT PRIMARY KEY, value TEXT)''')
    
    # Check if the table is empty; if so, insert default configuration
    c.execute('SELECT * FROM config')
    if not c.fetchall():
        for key, value in default_config.items():
            c.execute('INSERT INTO config (key, value) VALUES (?, ?)', (key, str(value)))
        conn.commit()
    
    conn.close()

def read_config(db_path):
    config = {}
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    
    c.execute('SELECT * FROM config')
    rows = c.fetchall()
    for row in rows:
        config[row[0]] = row[1]
    
    conn.close()
    return config

def update_config(db_path, new_config):
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    
    for key, value in new_config.items():
        c.execute('UPDATE config SET value = ? WHERE key = ?', (str(value), key))
    
    conn.commit()
    conn.close()

def get_monitors_info():
    # Constants from the Windows API
    CCHDEVICENAME = 32
    MONITORINFOF_PRIMARY = 1

    class MONITORINFOEXW(ctypes.Structure):
        _fields_ = [
            ("cbSize", ctypes.c_ulong),
            ("rcMonitor", ctypes.wintypes.RECT),
            ("rcWork", ctypes.wintypes.RECT),
            ("dwFlags", ctypes.c_ulong),
            ("szDevice", ctypes.c_wchar * CCHDEVICENAME)
        ]

    monitors = []

    def monitor_enum_proc(hMonitor, hdcMonitor, lprcMonitor, dwData):
        mi = MONITORINFOEXW()
        mi.cbSize = ctypes.sizeof(MONITORINFOEXW)
        ctypes.windll.user32.GetMonitorInfoW(hMonitor, ctypes.byref(mi))
        is_primary = (mi.dwFlags & MONITORINFOF_PRIMARY) != 0
        monitors.append({
            "Name": mi.szDevice, 
            "Width": mi.rcMonitor.right - mi.rcMonitor.left, 
            "Height": mi.rcMonitor.bottom - mi.rcMonitor.top,
            "X": mi.rcMonitor.left,
            "Y": mi.rcMonitor.top,
            "IsPrimary": is_primary  # Indicates if this is the primary monitor
        })
        return True

    # Define a callable object matching the prototype of MonitorEnumProc
    ENUMPROC = ctypes.WINFUNCTYPE(
        ctypes.c_bool, ctypes.c_ulong, ctypes.c_ulong,
        ctypes.POINTER(ctypes.wintypes.RECT), ctypes.c_double
    )

    # Enumerate monitors
    ctypes.windll.user32.EnumDisplayMonitors(None, None, ENUMPROC(monitor_enum_proc), 0)
    return monitors
    
def get_config_value(db_path, key):
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute("SELECT value FROM config WHERE key=?", (key,))
    result = c.fetchone()
    conn.close()
    if result:
        return result[0]
    return None

def get_default_save_path():
    # This will return the path to the user's desktop, regardless of the operating system
    return os.path.join(os.path.expanduser('~'), 'Desktop')

def add_context_menu_options():
    commands = {
        'TSTP:SC - Snip': r'C:\TSTP\ScreenTool\tstp-screen_tool.exe --snip',
        'TSTP:SC - Screen Capture': r'C:\TSTP\ScreenTool\tstp-screen_tool.exe --quick-capture'
    }

    for option_name, command in commands.items():
        key_path = r'Directory\Background\shell\{}'.format(option_name.replace(" ", "_"))
        command_key_path = r'Directory\Background\shell\{}\command'.format(option_name.replace(" ", "_"))

        key = reg.CreateKey(reg.HKEY_CLASSES_ROOT, key_path)
        reg.SetValue(key, '', reg.REG_SZ, option_name)
        reg.CloseKey(key)

        command_key = reg.CreateKey(reg.HKEY_CLASSES_ROOT, command_key_path)
        reg.SetValue(command_key, '', reg.REG_SZ, command)
        reg.CloseKey(command_key)

    print('Desktop context menu options added successfully.')

def remove_context_menu_options():
    option_names = [
        'TSTP:SC - Snip',
        'TSTP:SC - Screen Capture'
    ]

    for option_name in option_names:
        key_path = r'Directory\Background\shell\{}'.format(option_name.replace(" ", "_"))

        try:
            reg.DeleteKey(reg.HKEY_CLASSES_ROOT, key_path + r'\command')
            reg.DeleteKey(reg.HKEY_CLASSES_ROOT, key_path)
            print(f'Removed context menu option: {option_name}')
        except WindowsError as e:
            print(f'Failed to remove context menu option {option_name}: {e}')
    
class SnippingWidget(QWidget):
    def __init__(self, pixmap, mainWindow):
        super().__init__()
        self.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint)
        self.setWindowOpacity(0.3)
        self.db_path = "C:\\TSTP\\OmniOmega\\Settings\\config.db"
        self.begin = QPoint()
        self.end = QPoint()
        self.pixmap = self.captureDesktop()
        self.setGeometry(self.calculateCombinedGeometry())
        self.setDefaultSavePathAndMonitor()
        self.last_point = QPoint()
        self.annotation_color = Qt.red
        self.annotation_thickness = 2
        self.snippingAnnotateBeforeSaving = True
        self.mainWindow = mainWindow

    def mousePressEvent(self, event):
        self.begin = event.pos()
        self.end = self.begin
        self.update()

    def mouseMoveEvent(self, event):
        self.end = event.pos()
        self.update()

    def mouseReleaseEvent(self, event):
        self.saveSelectedArea()
        self.close()

    def paintEvent(self, event):
        qp = QPainter(self)
        qp.setPen(QPen(Qt.red, 2, Qt.SolidLine))
        rect = QRect(self.begin, self.end).normalized()
        qp.drawRect(rect)

    def calculateCombinedGeometry(self):
        combined_rect = QRect()
        for screen in QGuiApplication.screens():
            combined_rect = combined_rect.united(screen.geometry())
        return combined_rect

    def saveSelectedArea(self):
        try:
            # Calculate the region to be cropped
            combined_geometry = self.calculateCombinedGeometry()
            begin_global = self.mapToGlobal(self.begin) - combined_geometry.topLeft()
            end_global = self.mapToGlobal(self.end) - combined_geometry.topLeft()
            rect = QRect(begin_global, end_global).normalized()

            # Copy the specified area from the pixmap
            cropped = self.pixmap.copy(rect)

            # Generate the save path and filename using saveFile method logic
            save_path = get_config_value(db_path, "savePath") or get_default_save_path()
            file_path = self.saveFile("snipped", "png")

            if self.mainWindow.snippingAnnotateBeforeSaving:  # Check the setting from MainWindow
                annotated_pixmap = self.annotateScreenshot(cropped)
                annotated_pixmap.save(file_path, 'PNG')
            else:
                cropped.save(file_path, 'PNG')
            print(f"Saved snip to: {file_path}")
        except Exception as e:
            print(f"Failed to save snip: {e}")

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Escape:
            self.close()
            
    def captureDesktop(self):
        total_rect = self.calculateCombinedGeometry()
        desktop_pixmap = QPixmap(total_rect.size())
        desktop_pixmap.fill(Qt.black)  # Fill the pixmap with black
        painter = QPainter(desktop_pixmap)

        for screen in QGuiApplication.screens():
            screen_pixmap = screen.grabWindow(0)
            screen_geo = screen.geometry()
            virtual_top_left = screen_geo.topLeft() - total_rect.topLeft()
            painter.drawPixmap(virtual_top_left, screen_pixmap)

        painter.end()
        return desktop_pixmap
    
    def saveFile(self, prefix, extension):
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        filename = f"{prefix}_{timestamp}.{extension}"
        return os.path.join(self.mainWindow.savePath, filename)
    
    def setDefaultSavePathAndMonitor(self):
        self.savePath = config.get("savePath", os.path.join(os.path.expanduser("~"), "Documents"))
        monitor_info = get_monitors_info()
        if monitor_info:
            # Assuming primary monitor has (0,0) starting coordinates.
            primary_monitor = next((monitor for monitor in monitor_info if monitor["X"] == 0 and monitor["Y"] == 0), monitor_info[0])
            self.selectedMonitor = primary_monitor
        else:
            logging.error('No monitors detected.')
            self.selectedMonitor = None
            
    def selectAnnotationColor(self):
        color = QColorDialog.getColor(self.annotation_color, self)
        if color.isValid():
            self.annotation_color = color 
            
    def annotateScreenshot(self, pixmap):
        dialog = QDialog(self)
        dialog.setWindowTitle("Annotate Screenshot")

        # Initialize QLabel for the pixmap
        label = QLabel(dialog)
        label.setAlignment(Qt.AlignCenter)
        label.setScaledContents(False)

        # Check if pixmap dimensions exceed the specified limits
        max_width = 1080
        max_height = 1920
        if pixmap.width() > max_width or pixmap.height() > max_height:
            scale_factor = min(max_width / pixmap.width(), max_height / pixmap.height())
            scaled_pixmap = pixmap.scaled(int(pixmap.width() * scale_factor), int(pixmap.height() * scale_factor), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        else:
            scaled_pixmap = pixmap

        label.setPixmap(scaled_pixmap)

        # Calculate the size of the window based on the pixmap size with additional padding
        extra_padding = 25  # Amount of extra space around the pixmap
        window_width = scaled_pixmap.width() + (2 * extra_padding)
        window_height = scaled_pixmap.height() + (2 * extra_padding)

        # Set the dialog size to ensure it shows the entire pixmap plus padding
        dialog.resize(window_width, window_height)

        # Set layout for the dialog and add label to it
        layout = QVBoxLayout(dialog)
        layout.addWidget(label)
        dialog.setLayout(layout)
        
        original_pixmap = pixmap  # Use the original pixmap instead of the scaled one
        annotation_pixmap = original_pixmap.copy()

        self.label = label
        self.original_pixmap = original_pixmap

        self.watermark_scale = 1.0
        self.annotation_color = QColor('red')
        self.annotation_thickness = 3
        self.text_font_size = 12
        self.drawing = False
        self.last_point = None
        self.current_shape = None
        self.current_highlight = None
        self.annotation_items = []
        self.selected_item = None
        self.watermark_image = None
        self.watermark_location = None
        self.timestamp_enabled = False
        self.timestamp_positions = [
            "Top Left", "Top Center", "Top Right",
            "Center Left", "Center", "Center Right",
            "Bottom Left", "Bottom Center", "Bottom Right", None
        ]
        self.timestamp_index = 0  # Start at the first position
        self.undo_stack = []
        self.redo_stack = []
        self.mode = None # Initialize the mode attribute to None
       
        def resizeEvent(event):
            if self.label and self.original_pixmap:
                scaled_pixmap = self.original_pixmap.scaled(self.label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.label.setPixmap(scaled_pixmap)
            super(QDialog, dialog).resizeEvent(event)

        dialog.resizeEvent = resizeEvent        

        def addToUndoStack():
            self.undo_stack.append(annotation_pixmap.copy())
            self.redo_stack.clear()

        def undo():
            nonlocal annotation_pixmap  # Add this line
            if self.undo_stack:
                self.redo_stack.append(annotation_pixmap.copy())
                annotation_pixmap = self.undo_stack.pop()
                updateAnnotationPixmap()

        def redo():
            nonlocal annotation_pixmap  # Add this line
            if self.redo_stack:
                self.undo_stack.append(annotation_pixmap.copy())
                annotation_pixmap = self.redo_stack.pop()
                updateAnnotationPixmap()

        def setupPainter(pixmap, transparency=False):
            painter = QPainter(pixmap)
            if transparency:
                color = QColor(self.annotation_color)
                color.setAlphaF(0.2)
                painter.setBrush(color)
                painter.setPen(Qt.NoPen)
            else:
                painter.setPen(QPen(self.annotation_color, self.annotation_thickness, Qt.SolidLine))
            painter.setFont(QFont("Arial", self.text_font_size))
            return painter

        def point_to_line_distance(p1, p2, p):
            num = abs((p2.y() - p1.y()) * p.x() - (p2.x() - p1.x()) * p.y() + p2.x() * p1.y() - p2.y() * p1.x())
            den = ((p2.y() - p1.y())**2 + (p2.x() - p1.x())**2)**0.5
            return num / den if den != 0 else 0

        def labelToPixmapPos(pos):
            return QPoint(int(pos.x() * original_pixmap.width() / label.width()), int(pos.y() * original_pixmap.height() / label.height()))

        def mousePressEvent(event):
            if event.button() == Qt.LeftButton:
                self.drawing = True
                self.last_point = labelToPixmapPos(event.pos())
                if hasattr(self, 'mode'):  # Check if the mode attribute exists
                    if self.mode == 'text':
                        if not any(QRect(labelToPixmapPos(item['pos']), QFontMetrics(item['font']).size(0, item['text'])).contains(labelToPixmapPos(event.pos())) for item in self.annotation_items if item['type'] == 'text'):
                            text_item = {'type': 'text', 'text': '', 'pos': self.last_point, 'font': QFont("Arial", self.text_font_size), 'color': self.annotation_color}
                            text_edit = QLineEdit(dialog)
                            text_edit.setGeometry(QRect(event.pos(), QSize(200, 30)))
                            text_edit.setFocus()
                            text_edit.show()
                            def handleTextEditEditingFinished():
                                nonlocal text_item, text_edit
                                text_item['text'] = text_edit.text()
                                if text_item['text']:
                                    self.annotation_items.append(text_item)
                                    updateAnnotationPixmap()
                                    addToUndoStack()
                                text_edit.deleteLater()
                            text_edit.editingFinished.connect(handleTextEditEditingFinished)
                    elif self.mode == 'highlight_rectangle':
                        self.current_highlight = {'type': self.mode, 'start': self.last_point, 'end': self.last_point, 'color': self.annotation_color}
                    elif self.mode in ['line', 'rectangle', 'circle', 'arrow']:
                        self.current_shape = {'type': self.mode, 'start': self.last_point, 'end': self.last_point, 'color': self.annotation_color, 'thickness': self.annotation_thickness}
                    elif self.mode == 'watermark':
                        if self.mode == 'watermark' and self.watermark_image:
                            self.watermark_location = labelToPixmapPos(event.pos())
                            updateAnnotationPixmap()
                else:
                    self.selected_item = None
                    for item in reversed(self.annotation_items):
                        if item['type'] == 'text' and QRect(item['pos'], QFontMetrics(item['font']).size(0, item['text'])).contains(labelToPixmapPos(event.pos())):
                            self.selected_item = item
                            break
                        elif item['type'] in ['line', 'rectangle', 'circle', 'arrow'] and distanceToShape(item, labelToPixmapPos(event.pos())) < 5:
                            self.selected_item = item
                            break
                        elif item['type'] == 'highlight_rectangle' and QRectF(item['start'], item['end']).normalized().contains(labelToPixmapPos(event.pos())):
                            self.selected_item = item
                            break

        def mouseMoveEvent(event):
            if event.buttons() & Qt.LeftButton and self.drawing:
                if hasattr(self, 'mode'):  # Check if the mode attribute exists
                    if self.mode in ['line', 'rectangle', 'circle', 'arrow']:
                        self.current_shape['end'] = labelToPixmapPos(event.pos())
                        updateAnnotationPixmap()
                    elif self.mode == 'draw':
                        self.annotation_items.append({'type': 'draw', 'points': [self.last_point, labelToPixmapPos(event.pos())], 'color': self.annotation_color, 'thickness': self.annotation_thickness})
                        self.last_point = labelToPixmapPos(event.pos())
                        updateAnnotationPixmap()
                    elif self.mode == 'highlight_rectangle':
                        self.current_highlight['end'] = labelToPixmapPos(event.pos())
                        updateAnnotationPixmap()
                    elif self.mode == 'watermark':
                        if self.mode == 'watermark' and self.watermark_image:
                            self.watermark_location = labelToPixmapPos(event.pos())
                            updateAnnotationPixmap()
                elif self.selected_item:
                    if self.selected_item['type'] == 'text':
                        self.selected_item['pos'] += labelToPixmapPos(event.pos()) - self.last_point
                    elif self.selected_item['type'] in ['line', 'rectangle', 'circle', 'arrow']:
                        self.selected_item['start'] += labelToPixmapPos(event.pos()) - self.last_point
                        self.selected_item['end'] += labelToPixmapPos(event.pos()) - self.last_point
                    elif self.selected_item['type'] == 'highlight_rectangle':
                        self.selected_item['start'] += labelToPixmapPos(event.pos()) - self.last_point
                        self.selected_item['end'] += labelToPixmapPos(event.pos()) - self.last_point
                    self.last_point = labelToPixmapPos(event.pos())
                    updateAnnotationPixmap()

        def mouseReleaseEvent(event):
            if event.button() == Qt.LeftButton and self.drawing:
                if hasattr(self, 'mode'):  # Check if the mode attribute exists
                    if self.mode in ['line', 'rectangle', 'circle', 'arrow']:
                        self.annotation_items.append(self.current_shape)
                        self.current_shape = None
                    elif self.mode == 'highlight_rectangle':
                        self.annotation_items.append(self.current_highlight)
                        self.current_highlight = None
                    elif self.mode == 'watermark' and self.watermark_image:
                        if self.mode == 'watermark' and self.watermark_image:
                            addToUndoStack()
                self.drawing = False
                updateAnnotationPixmap()
                addToUndoStack()
                
        def wheelEvent(event):
            if self.mode == 'watermark' and self.watermark_image:
                # Adjust the scale factor based on the wheel direction
                delta = event.angleDelta().y() / 120  # Each step is 15 degrees
                self.watermark_scale += delta * 0.1
                self.watermark_scale = max(0.1, min(5, self.watermark_scale))  # Limit scale range
                updateAnnotationPixmap()

        def updateAnnotationPixmap():
            nonlocal annotation_pixmap
            annotation_pixmap = original_pixmap.copy()
            painter = setupPainter(annotation_pixmap)
            for item in self.annotation_items:
                if item['type'] == 'draw':
                    painter.setPen(QPen(item['color'], item['thickness'], Qt.SolidLine, Qt.RoundCap, Qt.RoundJoin))
                    painter.drawLines(item['points'])
                elif item['type'] == 'text':
                    painter.setPen(item['color'])
                    painter.setFont(item['font'])
                    painter.drawText(item['pos'], item['text'])
                elif item['type'] == 'highlight_rectangle':
                    drawHighlight(painter, item)
                else:
                    drawShape(painter, item)
            if self.current_shape:
                drawShape(painter, self.current_shape)
            if self.current_highlight:
                drawHighlight(painter, self.current_highlight)
            if self.watermark_image and self.watermark_location:
                # Apply scaling to the watermark image
                scaled_watermark = self.watermark_image.scaled(self.watermark_image.size() * self.watermark_scale, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                painter.drawPixmap(self.watermark_location, scaled_watermark)
            if self.timestamp_enabled:
                painter.setPen(self.annotation_color)
                painter.setFont(QFont("Arial", 12))
                drawTimestamp(painter, self.timestamp_position)
            painter.end()
            scaled_pixmap = annotation_pixmap.scaled(self.label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
            label.setPixmap(scaled_pixmap)
            
        def drawTimestamp(painter, position):
            timestamp_text = QDateTime.currentDateTime().toString("yyyy-MM-dd HH:mm:ss")
            painter.setPen(self.annotation_color)
            painter.setFont(QFont("Arial", 12))
            x, y = calculatePosition(annotation_pixmap, position, painter, timestamp_text)
            painter.drawText(int(x), int(y), timestamp_text)

        def calculatePosition(pixmap, position, painter, timestamp_text):
            painter.setFont(QFont("Arial", 12))  # Ensure the font is set to calculate metrics
            metrics = painter.fontMetrics()
            text_width = metrics.width(timestamp_text)
            text_height = metrics.height()

            # Define x coordinate based on position
            if "Left" in position:
                x = 5
            elif "Right" in position:
                x = pixmap.width() - text_width - 5
            elif "Center" in position:
                x = (pixmap.width() - text_width) // 2

            # Define y coordinate based on position
            if "Top" in position:
                y = 5 + text_height  # Add text height to avoid cutting off at top
            elif "Bottom" in position:
                y = pixmap.height() - text_height - 5
            elif "Center" in position:
                y = (pixmap.height() - text_height) // 2  # Center alignment for vertical

            return x, y

        def updateTimestampPosition(position):
            if position:
                # Get the position and adjust the drawing of the timestamp accordingly
                self.timestamp_position = position

        def distanceToShape(shape, point):
            point = QPointF(point)
            if shape['type'] in ['line', 'arrow']:
                return point_to_line_distance(point, QPointF(shape['start']), QPointF(shape['end']))
            elif shape['type'] == 'rectangle':
                rect = QRectF(shape['start'], shape['end']).normalized()
                return rect.contains(point) and min(abs(point.x() - rect.left()), abs(point.x() - rect.right()), abs(point.y() - rect.top()), abs(point.y() - rect.bottom()))
            elif shape['type'] == 'circle':
                center = shape['start']
                radius = (shape['end'] - center).manhattanLength()
                return abs((point - center).manhattanLength() - radius)
            elif shape['type'] == 'arrow':
                line = QLineF(shape['start'], shape['end'])
                if line.distance(QPointF(point)) < 5:
                    return line.distance(QPointF(point))
                arrow_head_size = 10
                angle = math.acos(line.dx() / line.length())
                if line.dy() >= 0:
                    angle = 2 * math.pi - angle
                arrow_p1 = shape['end'] - QPointF(math.sin(angle + math.pi / 3) * arrow_head_size, math.cos(angle + math.pi / 3) * arrow_head_size)
                arrow_p2 = shape['end'] - QPointF(math.sin(angle + math.pi - math.pi / 3) * arrow_head_size, math.cos(angle + math.pi - math.pi / 3) * arrow_head_size)
                return min(QLineF(shape['end'], arrow_p1).distance(QPointF(point)), QLineF(shape['end'], arrow_p2).distance(QPointF(point)))

        def drawShape(painter, shape):
            if shape['type'] == 'line':
                painter.drawLine(shape['start'], shape['end'])
            elif shape['type'] == 'rectangle':
                painter.drawRect(QRectF(shape['start'], shape['end']).normalized())
            elif shape['type'] == 'circle':
                radius = (shape['start'] - shape['end']).manhattanLength()
                painter.setPen(QPen(shape['color'], shape['thickness'], Qt.SolidLine))
                painter.drawEllipse(shape['start'], radius, radius)
            elif shape['type'] == 'arrow':
                arrow_head_size = 10
                line = QLineF(shape['start'], shape['end'])
                angle = math.acos(line.dx() / line.length())
                if line.dy() >= 0:
                    angle = 2 * math.pi - angle
                arrow_p1 = line.p2() - QPointF(math.sin(angle + math.pi / 3) * arrow_head_size, math.cos(angle + math.pi / 3) * arrow_head_size)
                arrow_p2 = line.p2() - QPointF(math.sin(angle + math.pi - math.pi / 3) * arrow_head_size, math.cos(angle + math.pi - math.pi / 3) * arrow_head_size)
                painter.drawLine(line)
                painter.drawPolygon(QPolygonF([line.p2(), arrow_p1, arrow_p2]))

        def drawHighlight(painter, highlight):
            color = QColor(highlight['color'])
            color.setAlphaF(0.2)
            painter.setBrush(color)
            painter.setPen(Qt.NoPen)
            rect = QRectF(highlight['start'], highlight['end']).normalized()
            painter.drawRect(rect)

        def clearAnnotations():
            self.annotation_items.clear()
            self.undo_stack.clear()
            self.redo_stack.clear()
            updateAnnotationPixmap()

        def changeTextSize():
            size, ok = QInputDialog.getInt(dialog, "Text Size", "Enter text size:", self.text_font_size, 1, 100)
            if ok:
                self.text_font_size = size

        def openWatermarkImage():
            file_dialog = QFileDialog()
            image_file, _ = file_dialog.getOpenFileName(dialog, "Select Watermark Image", "", "Image Files (*.png *.jpg *.bmp)")
            if image_file:
                self.watermark_image = QPixmap(image_file)
                updateAnnotationPixmap()

        def changeWatermarkImage():
            openWatermarkImage()

        def saveWatermark():
            if self.watermark_image and self.watermark_location:
                watermark_file = self.watermark_image.toImage()
                watermark_file.save("watermark.png")
                watermark_location = f"{self.watermark_location.x()},{self.watermark_location.y()}"
                conn = sqlite3.connect(self.db_path)
                cursor = conn.cursor()
                cursor.execute("CREATE TABLE IF NOT EXISTS settings (watermark_file TEXT, watermark_location TEXT)")
                cursor.execute("INSERT OR REPLACE INTO settings (watermark_file, watermark_location) VALUES (?, ?)", ("watermark.png", watermark_location))
                conn.commit()
                conn.close()

        def toggleTimestamp():
            position = self.timestamp_positions[self.timestamp_index]
            self.timestamp_index = (self.timestamp_index + 1) % len(self.timestamp_positions)
            if position is None:
                self.timestamp_enabled = False
            else:
                self.timestamp_enabled = True
                updateTimestampPosition(position)
            updateAnnotationPixmap()

        label.mousePressEvent = mousePressEvent
        label.mouseMoveEvent = mouseMoveEvent
        label.mouseReleaseEvent = mouseReleaseEvent
        label.wheelEvent = wheelEvent

        layout.addWidget(label)

        button_layout = QGridLayout()

        def add_button(text, function, row, col, span=1):
            button = QPushButton(text)
            button.clicked.connect(function)
            button_layout.addWidget(button, row, col, 1, span)

        add_button("Text", lambda: setattr(self, 'mode', 'text'), 0, 0)
        add_button("Draw", lambda: setattr(self, 'mode', 'draw'), 0, 1)
        add_button("Select Color", self.selectAnnotationColor, 0, 2)
        add_button("Text Size", changeTextSize, 0, 3)

        shape_button = QPushButton("Shapes")
        shape_menu = QMenu()
        for shape in ["Line", "Rectangle", "Circle", "Arrow", "Highlight Rectangle"]:
            action = QAction(shape, dialog)
            action.triggered.connect(lambda _, s=shape: setattr(self, 'mode', s.lower().replace(' ', '_')))
            shape_menu.addAction(action)
        shape_button.setMenu(shape_menu)
        button_layout.addWidget(shape_button, 1, 0)

        add_button("Clear", clearAnnotations, 1, 1)
        add_button("Undo", undo, 1, 2)
        add_button("Redo", redo, 1, 3)

        watermark_button = QPushButton("Watermark")
        watermark_menu = QMenu()
        watermark_menu.addAction("Add Watermark", lambda: setattr(self, 'mode', 'watermark'))
        watermark_menu.addAction("Change Watermark", changeWatermarkImage)
        watermark_menu.addAction("Save Watermark", saveWatermark)
        watermark_button.setMenu(watermark_menu)
        button_layout.addWidget(watermark_button, 2, 0)

        timestamp_button = QPushButton("Timestamp")
        timestamp_button.setCheckable(True)
        timestamp_button.clicked.connect(toggleTimestamp)
        button_layout.addWidget(timestamp_button, 2, 1)

        add_button("Save", dialog.accept, 2, 2)
        add_button("Cancel", dialog.reject, 2, 3)

        layout.addLayout(button_layout)

        if dialog.exec_() == QDialog.Accepted:
            return annotation_pixmap
        else:
            return original_pixmap

class ScreenToolAboutDialog(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowTitle("TSTP:ST - About")
        self.setWindowIcon(QIcon(icon_path))
        self.setGeometry(300, 300, 300, 200)
        layout = QVBoxLayout()
        self.setFixedSize(self.size())
        
        layout.addWidget(QLabel("Company Name: The Solutions To Problems, LLC"))
        layout.addWidget(QLabel("Product Name: TSTP:Screen Tool"))
        #layout.addWidget(QLabel("Product Version: " + version_number))
        #layout.addWidget(QLabel("Release Date: " + last_update_date))
        link = QLabel('<a href="https://www.tstp.xyz/programs/tstp-st">Product Page</a>')
        link.setOpenExternalLinks(True)
        layout.addWidget(link)

        self.setLayout(layout)

class ScreenToolSettingsDialog(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowTitle("TSTP:ST Settings")
        self.setGeometry(100, 100, 310, 320)
        layout = QVBoxLayout()
        self.setFixedSize(self.size())

        # Initialize QSettings
        settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")

        # Load settings
        save_path = settings.value("savePath", "")
        recording_quality = settings.value("recordingQuality", "High")
        gif_resolution = settings.value("gifResolution", (640, 480))
        annotate_before_saving = settings.value("annotateBeforeSaving", False, type=bool)
        snipping_annotate_before_saving = settings.value("snippingAnnotateBeforeSaving", False, type=bool)

        # Save Path
        pathLayout = QHBoxLayout()
        layout.addWidget(QLabel("Save Path:"))
        self.savePathLineEdit = QLineEdit(save_path)
        pathLayout.addWidget(self.savePathLineEdit)

        # Browse Button
        browseButton = QPushButton("Browse")
        browseButton.clicked.connect(self.openFolderDialog)
        pathLayout.addWidget(browseButton)
        layout.addLayout(pathLayout)  # Add the QHBoxLayout to the main QVBoxLayout

        # Recording Quality
        layout.addWidget(QLabel("Recording Quality:"))
        self.recordingQualityComboBox = QComboBox()
        self.recordingQualityComboBox.addItems(["High", "Medium", "Low"])
        self.recordingQualityComboBox.setCurrentText(recording_quality)
        layout.addWidget(self.recordingQualityComboBox)

        # GIF Resolution
        layout.addWidget(QLabel("GIF Resolution:"))
        self.gifResolutionComboBox = QComboBox()
        self.gifResolutionComboBox.addItem("640x480", (640, 480))
        self.gifResolutionComboBox.addItem("800x600", (800, 600))
        self.gifResolutionComboBox.addItem("1024x768", (1024, 768))
        currentIndex = self.gifResolutionComboBox.findData(gif_resolution)
        if currentIndex >= 0:
            self.gifResolutionComboBox.setCurrentIndex(currentIndex)
        layout.addWidget(self.gifResolutionComboBox)
    
        # Checkbox for annotation setting
        self.annotateCheckbox = QCheckBox("Enable Annotations Before Saving")
        self.annotateCheckbox.setChecked(annotate_before_saving)
        layout.addWidget(self.annotateCheckbox)
    
        # Checkbox for snipping widget annotation setting
        self.snippingAnnotateCheckbox = QCheckBox("Enable Annotations in Snipping Widget")
        self.snippingAnnotateCheckbox.setChecked(snipping_annotate_before_saving)
        layout.addWidget(self.snippingAnnotateCheckbox)
    
        # Save Button
        saveButton = QPushButton("Save")
        saveButton.clicked.connect(self.saveSettings)
        layout.addWidget(saveButton)
    
        self.setLayout(layout)

    def openFolderDialog(self):
        directory = QFileDialog.getExistingDirectory(self, "Select Save Directory")
        if directory:  # Make sure the user didn't cancel the dialog
            self.savePathLineEdit.setText(directory)
            print("New Save Path: " + directory)

    def saveSettings(self):
        potentialPath = self.savePathLineEdit.text()
        recordingQuality = self.recordingQualityComboBox.currentText()
        gifResolution = self.gifResolutionComboBox.currentData()
        self.parent().annotateBeforeSaving = self.annotateCheckbox.isChecked()
        self.parent().snippingAnnotateBeforeSaving = self.snippingAnnotateCheckbox.isChecked()

        if os.path.isdir(potentialPath):
            # Initialize QSettings
            settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")

            # Save settings
            settings.setValue("savePath", potentialPath)
            settings.setValue("recordingQuality", recordingQuality)
            settings.setValue("gifResolution", gifResolution)
            settings.setValue("annotateBeforeSaving", self.annotateCheckbox.isChecked())
            settings.setValue("snippingAnnotateBeforeSaving", self.snippingAnnotateCheckbox.isChecked())

            # Update parent attributes
            self.parent().savePath = potentialPath
            self.parent().gifResolution = gifResolution

            # Inform user of success
            self.accept()
            print("Settings have been saved")
        else:
            QMessageBox.warning(self, "Error", "The path does not exist.")

class WindowSelectionDialog(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowTitle("TSTP:ST - Monitor/Window Select")
        self.setFixedSize(300, 120)
        layout = QVBoxLayout()
        self.tabWidget = QTabWidget()
        self.windowsTab = QWidget()
        self.monitorsTab = QWidget()
        self.tabWidget.addTab(self.windowsTab, "Windows")
        self.tabWidget.addTab(self.monitorsTab, "Monitors")
        layout.addWidget(self.tabWidget)

        self.setupWindowsTab()
        self.setupMonitorsTab()

        self.setLayout(layout)

    def setupWindowsTab(self):
        layout = QVBoxLayout()
        self.comboBox = QComboBox()
        self.updateWindowList()
        layout.addWidget(self.comboBox)

        selectButton = QPushButton("Select Window")
        selectButton.clicked.connect(self.selectWindow)
        layout.addWidget(selectButton)

        self.windowsTab.setLayout(layout)

    def setupMonitorsTab(self):
        layout = QVBoxLayout()
        self.monitorsComboBox = QComboBox()
        self.updateMonitorList()
        layout.addWidget(self.monitorsComboBox)
        self.setFixedSize(300, 150)
        
        selectAllMonitorsButton = QPushButton("Select All Monitors")
        selectAllMonitorsButton.clicked.connect(self.selectAllMonitors)
        layout.addWidget(selectAllMonitorsButton)

        selectMonitorButton = QPushButton("Select Monitor")
        selectMonitorButton.clicked.connect(self.selectMonitor)
        layout.addWidget(selectMonitorButton)

        self.monitorsTab.setLayout(layout)

    def updateWindowList(self):
        self.comboBox.clear()
        windows = gw.getAllWindows()
        for window in windows:
            if window.title:
                self.comboBox.addItem(window.title[:30], window)

    def updateMonitorList(self):
        self.monitorsComboBox.clear()
        monitors = get_monitors()
        for monitor in monitors:
            monitor_name = f"{monitor.name} ({monitor.width}x{monitor.height})" if monitor.name else f"Monitor {monitor.id} ({monitor.width}x{monitor.height})"
            self.monitorsComboBox.addItem(monitor_name, monitor)

    def selectWindow(self):
        selected_index = self.comboBox.currentIndex()
        window = self.comboBox.itemData(selected_index)
        if window:
            self.parent().selectedWindow = window
            self.parent().selectedMonitor = None
            self.accept()

    def selectMonitor(self):
        selectedMonitorIndex = self.monitorsComboBox.currentIndex()
        self.parent().selectedMonitor = self.monitorsComboBox.itemData(selectedMonitorIndex)
        self.parent().selectedWindow = None
        self.parent().selectedMonitorIndex = selectedMonitorIndex  # Save the index
        self.accept()
        
    def selectAllMonitors(self):
        self.parent().selectedWindow = None
        self.parent().selectedMonitor = None
        self.accept()

class TransparentOverlay(QDialog):
    selectionComplete = pyqtSignal(QRect)
    def __init__(self, parent=None):
        super().__init__(parent, Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint)
        self.setWindowOpacity(0.3)
        self.setMouseTracking(True)
        self.rect = QRect(100, 100, 200, 200)  # Initial size
        self.origin = None
        self.resizing = False
        self.moving = False
        self.border_color = Qt.red
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setGeometry(QApplication.desktop().screenGeometry())  # Set geometry to span all screens
        self.show()
        
    def resetSelection(self):
        self.rect = QRect(100, 100, 200, 200)  # Reset to an empty rectangle
        self.update()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            if self.rect.contains(event.pos()):
                # Check if click is near the border for resizing
                self.origin = event.pos()
                if abs(self.rect.right() - event.pos().x()) < 10 and abs(self.rect.bottom() - event.pos().y()) < 10:
                    self.resizing = True
                else:
                    self.moving = True

    def mouseMoveEvent(self, event):
        globalPos = self.mapToGlobal(event.pos())
        if self.resizing:
            # Resize the rectangle based on global coordinates
            new_bottom_right = self.mapFromGlobal(globalPos)
            self.rect.setBottomRight(new_bottom_right)
            self.update()
        elif self.moving:
            # Calculate the movement based on global cursor position
            globalOrigin = self.mapToGlobal(self.origin)
            offset = globalPos - globalOrigin
            self.rect.translate(offset.x(), offset.y())
            self.origin = self.mapFromGlobal(globalPos)
            self.update()

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            if self.resizing:
                self.resizing = False
            if self.moving:
                self.moving = False
            self.selectionComplete.emit(self.rect)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setPen(QPen(self.border_color, 5))
        painter.drawRect(self.rect.adjusted(5, 5, -5, -5))

    def setBorderColor(self, color):
        self.border_color = color
        self.update()

class RecordingControlDialog(QDialog):
    def __init__(self, parent=None):
        super(RecordingControlDialog, self).__init__(parent)
        self.setWindowTitle("Screen Recording Options")
        self.setGeometry(300, 300, 400, 600)
        self.setFixedSize(self.size())
        self.selectedArea = QRect()
        self.lastSelectedIndex = -1

        mainLayout = QVBoxLayout(self)
        self.keepWindowAliveCheckBox = QCheckBox("Keep Window Alive")
        mainLayout.addWidget(self.keepWindowAliveCheckBox)

        self.screenComboBox = QComboBox()
        self.populateScreens()  # This will now add an empty initial option
        self.screenComboBox.currentIndexChanged.connect(self.updatePreview)
        mainLayout.addWidget(QLabel("Select Screen:"))
        mainLayout.addWidget(self.screenComboBox)

        self.previewLabel = QLabel("Screen preview here")
        self.previewLabel.setAlignment(Qt.AlignCenter)
        self.previewLabel.setStyleSheet("QLabel { background-color: black; color: white; }")
        self.previewLabel.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        mainLayout.addWidget(self.previewLabel)

        self.updateButton = QPushButton("Update Preview")
        self.updateButton.clicked.connect(self.updatePreview)  # Connect the update button
        mainLayout.addWidget(self.updateButton)

        self.sectionRecordingCheckBox = QCheckBox("Record Specific Section")
        self.sectionRecordingCheckBox.stateChanged.connect(self.handleSectionRecordingCheckbox)
        mainLayout.addWidget(self.sectionRecordingCheckBox)

        self.formatComboBox = QComboBox()
        self.formatComboBox.addItems(["AVI (XVID)", "MP4 (AVC1)"])
        mainLayout.addWidget(QLabel("Select Format:"))
        mainLayout.addWidget(self.formatComboBox)

        self.frameRateSpinBox = QSpinBox()
        self.frameRateSpinBox.setRange(1, 60)
        self.frameRateSpinBox.setValue(20)
        mainLayout.addWidget(QLabel("Frame Rate (FPS):"))
        mainLayout.addWidget(self.frameRateSpinBox)

        self.toggleRecordingBtn = QPushButton("Start Recording")
        self.toggleRecordingBtn.clicked.connect(self.toggleRecording)
        mainLayout.addWidget(self.toggleRecordingBtn)

        self.overlay = None

        self.recordingTimer = None
        self.isRecording = False
        self.videoWriter = None

        self.keepWindowAliveCheckBox.stateChanged.connect(self.handleKeepAlive)

    def handleSectionRecordingCheckbox(self, state):
        if state == Qt.Checked:
            if not self.overlay:
                self.overlay = TransparentOverlay(self)
                self.overlay.selectionComplete.connect(self.onSelectionComplete)
            self.overlay.showFullScreen()
        else:
            if self.overlay:
                self.overlay.hide()
                self.overlay.resetSelection()
                self.overlay = None
            # Clear the selected area when the checkbox is unchecked
            self.selectedArea = QRect()

    def onSelectionComplete(self, selectionRect):
        self.selectedArea = selectionRect
        self.updatePreview()

    def updatePreview(self):
        selected_index = self.screenComboBox.currentIndex()
        if selected_index > 0 and selected_index != self.lastSelectedIndex:
            self.lastSelectedIndex = selected_index
            screen = QGuiApplication.screens()[selected_index - 1]  # Adjust for empty option
            pixmap = screen.grabWindow(0)
            self.previewLabel.setPixmap(pixmap.scaled(self.previewLabel.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))
            self.previewLabel.update()
            
    def showOverlay(self):
        if not self.overlay:
            self.overlay = TransparentOverlay(self)
            self.overlay.selectionComplete.connect(self.onSelectionComplete)
        self.overlay.showFullScreen()
        self.overlay.raise_()
        self.overlay.activateWindow()

    def toggleRecording(self):
        if self.isRecording:
            self.stopRecording()
        else:
            self.startRecording()

    def startRecording(self):
        selected_screen = self.screenComboBox.currentData()
        if not selected_screen:
            QMessageBox.warning(self, "Selection Error", "Please select a valid screen before starting the recording.")
            return  # Abort the recording setup

        if self.overlay:
            self.overlay.hide()
            self.showOverlay()
            self.overlay.setBorderColor(Qt.green)

        screen_geometry = selected_screen.geometry()

        if self.sectionRecordingCheckBox.isChecked() and not self.selectedArea.isEmpty():
            recording_area = self.selectedArea
        else:
            recording_area = QRect(0, 0, screen_geometry.width(), screen_geometry.height())

        format_text = self.formatComboBox.currentText()
        codec, file_extension = self.getCodecAndExt(format_text)
        filename = f"recording_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}{file_extension}"
        full_save_path = os.path.join(self.parent().savePath, filename)

        self.videoWriter = cv2.VideoWriter(full_save_path, codec, self.frameRateSpinBox.value(), (recording_area.width(), recording_area.height()))
        self.isRecording = True
        self.toggleRecordingBtn.setText("Stop Recording")

        self.recordingTimer = QTimer(self)
        self.recordingTimer.timeout.connect(lambda: self.captureFrame(selected_screen, recording_area))
        self.recordingTimer.start(1000 // self.frameRateSpinBox.value())

    def captureFrame(self, screen, recording_area):
        pixmap = screen.grabWindow(0, recording_area.x(), recording_area.y(), recording_area.width(), recording_area.height())
        image = pixmap.toImage()
        frame = np.array(image.constBits().asarray(image.byteCount())).reshape((image.height(), image.width(), 4))
        frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2BGR)
        self.videoWriter.write(frame)

    def stopRecording(self):
        # Stop recording logic
        if self.overlay and self.sectionRecordingCheckBox.isChecked():
            self.overlay.show()		
            self.overlay.setBorderColor(Qt.red)
        if self.recordingTimer is not None:
            self.recordingTimer.stop()
            self.videoWriter.release()
            self.videoWriter = None
            self.isRecording = False
            self.toggleRecordingBtn.setText("Start Recording")
        else:
            print("Recording timer is not initialized.")
            
    def populateScreens(self):
        self.screenComboBox.clear()
        self.screenComboBox.addItem("Select a screen", None)
        screens = QGuiApplication.screens()
        if not screens:
            self.screenComboBox.addItem("No screens detected", None)
            return

        for i, screen in enumerate(screens):
            screen_info = f"Screen {i + 1}: {screen.size().width()}x{screen.size().height()}"
            self.screenComboBox.addItem(screen_info, screen)
            
    def handleKeepAlive(self, state):
        if state == Qt.Checked:
            self.setAttribute(Qt.WA_DeleteOnClose, False)
        else:
            self.setAttribute(Qt.WA_DeleteOnClose, True)

    def getCodecAndExt(self, format_text):
        if format_text == "AVI (XVID)":
            codec = cv2.VideoWriter_fourcc(*'XVID')
            ext = '.avi'
        elif format_text == "MP4 (AVC1)":
            codec = cv2.VideoWriter_fourcc(*'AVC1')
            ext = '.mp4'
        else:
            codec = cv2.VideoWriter_fourcc(*'XVID')
            ext = '.avi'
        return codec, ext
    
    def closeEvent(self, event):
        if self.keepWindowAliveCheckBox.isChecked():
            event.ignore()  # Ignore the close event
            self.hide()  # Hide the window instead of closing
        else:
            if self.overlay:
                self.overlay.close()

class AreaSelectDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("TSTP:ST Area Screenshot")
        self.setGeometry(100, 100, 300, 200)
        layout = QVBoxLayout()
        self.setFixedSize(self.size())
        self.db_path = "C:\\TSTP\\ScreenTool\\config.db"

        layout.addWidget(QLabel("Select area for capturing the screenshot:"))

        # Line edits for startX, startY, width, height
        self.startXLineEdit = QLineEdit()
        self.startYLineEdit = QLineEdit()
        self.widthLineEdit = QLineEdit()
        self.heightLineEdit = QLineEdit()

        # Layout for startX
        startXLayout = QHBoxLayout()
        startXLayout.addWidget(QLabel("Start X:"))
        startXLayout.addWidget(self.startXLineEdit)
        layout.addLayout(startXLayout)

        # Layout for startY
        startYLayout = QHBoxLayout()
        startYLayout.addWidget(QLabel("Start Y:"))
        startYLayout.addWidget(self.startYLineEdit)
        layout.addLayout(startYLayout)

        # Layout for width
        widthLayout = QHBoxLayout()
        widthLayout.addWidget(QLabel("Width:"))
        widthLayout.addWidget(self.widthLineEdit)
        layout.addLayout(widthLayout)

        # Layout for height
        heightLayout = QHBoxLayout()
        heightLayout.addWidget(QLabel("Height:"))
        heightLayout.addWidget(self.heightLineEdit)
        layout.addLayout(heightLayout)

        # Capture and Cancel buttons
        captureButton = QPushButton("Capture")
        captureButton.clicked.connect(self.accept)
        cancelButton = QPushButton("Cancel")
        cancelButton.clicked.connect(self.reject)

        buttonsLayout = QHBoxLayout()
        buttonsLayout.addWidget(captureButton)
        buttonsLayout.addWidget(cancelButton)
        layout.addLayout(buttonsLayout)

        self.setLayout(layout)

    def captureArea(self):
        # Implement logic to capture the screenshot of the overlay area
        region = (self.overlay.x(), self.overlay.y(), self.overlay.width(), self.overlay.height())
        screenshot = pyautogui.screenshot(region=region)
        
        # Get the default or database-configured save path
        savePath = self.get_save_path()
        filterTypes = "PNG (*.png);;JPEG (*.jpg *.jpeg);;All Files (*)"
        filePath, _ = QFileDialog.getSaveFileName(self, "Save Screenshot", savePath, filterTypes)
        
        if filePath:  # Only save if a file path was selected
            screenshot.save(filePath)
            QMessageBox.information(self, "Screenshot Saved", f"Screenshot saved to {filePath}")
    
    def get_save_path(self):
        savePath = self.get_config_value("savePath")
        if not savePath:
            savePath = os.path.join(os.path.expanduser("~"), "Desktop")
        return savePath

    def get_config_value(self, key):
        """Fetch a configuration value from the SQLite database."""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT value FROM config WHERE key = ?", (key,))
            value = cursor.fetchone()
            if value:
                return value[0]
            return None
        except Exception as e:
            print(f"Failed to fetch '{key}' from the database: {e}")
            return None
        finally:
            conn.close()

    def updateCoordinates(self, startX, startY, width, height):
        self.startXLineEdit.setText(str(startX))
        self.startYLineEdit.setText(str(startY))
        self.widthLineEdit.setText(str(width))
        self.heightLineEdit.setText(str(height))

    def getSelectedArea(self):
        try:
            startX = int(self.startXLineEdit.text())
            startY = int(self.startYLineEdit.text())
            width = int(self.widthLineEdit.text())
            height = int(self.heightLineEdit.text())
            return (startX, startY, width, height)
        except ValueError:
            return None
        
class GifCreationDialog(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowTitle("TSTP:ST GIF Creator")
        self.setGeometry(100, 100, 300, 150)
        layout = QVBoxLayout()

        # Capture Area
        capture_area_layout = QHBoxLayout()
        self.capture_area_combo = QComboBox()
        self.capture_area_combo.addItems(["Full Screen", "Select Area"])
        capture_area_layout.addWidget(QLabel("Capture Area:"))
        capture_area_layout.addWidget(self.capture_area_combo)
        layout.addLayout(capture_area_layout)

        # Capture Duration
        duration_layout = QHBoxLayout()
        self.duration_spinbox = QSpinBox()
        self.duration_spinbox.setMinimum(1)
        self.duration_spinbox.setMaximum(60)
        self.duration_spinbox.setValue(5)
        duration_layout.addWidget(QLabel("Duration (seconds):"))
        duration_layout.addWidget(self.duration_spinbox)
        layout.addLayout(duration_layout)

        # Capture Interval
        interval_layout = QHBoxLayout()
        self.interval_spinbox = QSpinBox()
        self.interval_spinbox.setMinimum(100)
        self.interval_spinbox.setMaximum(1000)
        self.interval_spinbox.setValue(200)
        interval_layout.addWidget(QLabel("Interval (milliseconds):"))
        interval_layout.addWidget(self.interval_spinbox)
        layout.addLayout(interval_layout)

        # Create and Cancel Buttons
        button_layout = QHBoxLayout()
        self.create_button = QPushButton("Create GIF")
        self.create_button.clicked.connect(self.createGif)
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(self.create_button)
        button_layout.addWidget(self.cancel_button)
        layout.addLayout(button_layout)

        self.setLayout(layout)

    def createGif(self):
        capture_area = self.capture_area_combo.currentText()
        duration = self.duration_spinbox.value()
        interval = self.interval_spinbox.value()

        if capture_area == "Full Screen":
            capture_region = None
        else:
            # Display an overlay for the user to select the capture area
            overlay = SelectionOverlay(self)
            overlay.exec_()
            capture_region = overlay.selectedRect().getRect()

        images = []
        start_time = time.time()
        while time.time() - start_time < duration:
            if capture_region:
                screenshot = pyautogui.screenshot(region=capture_region)
            else:
                screenshot = pyautogui.screenshot()
            images.append(cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR))
            QApplication.processEvents()  # Process GUI events
            time.sleep(interval / 1000)  # Convert milliseconds to seconds

        save_path, _ = QFileDialog.getSaveFileName(self, "Save GIF", "", "GIF Files (*.gif);;All Files (*)")
        if save_path:
            images_rgb = [cv2.cvtColor(img, cv2.COLOR_BGR2RGB) for img in images]
            imageio.mimsave(save_path, images_rgb, duration=interval / 1000)
            if notifications_toggle:
                QMessageBox.information(self, "GIF Created", f"GIF saved to {save_path}")
        else:
            QMessageBox.warning(self, "Error", "Failed to create GIF.")
        self.accept()

class SelectionOverlay(QWidget):
    selectionComplete = pyqtSignal(QRect)
    selectionAdjusted = pyqtSignal(QRect)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint)
        self.setWindowOpacity(0.5)  # Semi-transparency for the selection rectangle
        self.begin = QPoint()
        self.end = QPoint()
        self.isSelecting = False
        self.isMoving = False
        self.showFullScreen()
        self.setCursor(Qt.CrossCursor)
        self.rect = QRect()
        self.movingOffset = QPoint()
        combined_rect = self.calculateCombinedGeometry()
        self.setGeometry(combined_rect)
        self.setCursor(Qt.CrossCursor)
        
    def calculateCombinedGeometry(self):
        screens = QGuiApplication.screens()
        min_x, min_y, max_x, max_y = 0, 0, 0, 0
        
        for screen in screens:
            geometry = screen.geometry()
            min_x = min(min_x, geometry.x())
            min_y = min(min_y, geometry.y())
            max_x = max(max_x, geometry.x() + geometry.width())
            max_y = max(max_y, geometry.y() + geometry.height())
        
        return QRect(min_x, min_y, max_x - min_x, max_y - min_y)

    def mousePressEvent(self, event):
        if self.rect.contains(event.pos()):
            # Start moving the rectangle
            self.isMoving = True
            self.movingOffset = event.pos() - self.rect.topLeft()
        else:
            # Start a new selection
            self.isSelecting = True
            self.begin = event.pos()
            self.end = self.begin
            self.rect = QRect()
        self.update()

    def mouseMoveEvent(self, event):
        if self.isMoving:
            self.rect.moveTo(event.pos() - self.movingOffset)
            self.selectionAdjusted.emit(self.rect.normalized())
        elif self.isSelecting:
            self.end = event.pos()
            self.rect = QRect(self.begin, self.end).normalized()
        self.update()

    def mouseReleaseEvent(self, event):
        if self.isSelecting:
            self.isSelecting = False
            self.rect = QRect(self.begin, self.end).normalized()
            self.selectionComplete.emit(self.rect)
        elif self.isMoving:
            self.isMoving = False
            self.selectionAdjusted.emit(self.rect.normalized())
            self.setWindowOpacity(0)
        self.update()

    def paintEvent(self, event):
        super().paintEvent(event)
        painter = QPainter(self)
        painter.setPen(QPen(Qt.red, 2))
        painter.drawRect(self.rect)

        # Set text color
        painter.setPen(QColor(Qt.white))
    
        # Set font
        font = painter.font()
        font.setPointSize(12)  # Adjust the size as needed
        painter.setFont(font)

        # Draw instructions
        instructions = "Drag to select an area. Press 'Esc' to cancel."
        textRect = QRect(10, 10, self.width() - 20, 100)  # Adjust as needed to position the text
        painter.drawText(textRect, Qt.AlignLeft | Qt.AlignTop, instructions)

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Escape:
            self.selectionComplete.emit(QRect())  # Emit an empty rect if escape is pressed
            self.close()
            
class AnnotationWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(300, 500)
        self.setWindowTitle("Annotation Tools")
        
        layout = QVBoxLayout()
        
        # Tool Selection
        tool_layout = QHBoxLayout()
        self.tool_combo = QComboBox()
        self.tool_combo.addItems(["Freehand", "Line", "Rectangle", "Circle", "Arrow", "Text", "Highlighter", "Eraser"])
        self.tool_combo.currentTextChanged.connect(self.tool_changed)
        tool_layout.addWidget(QLabel("Tool:"))
        tool_layout.addWidget(self.tool_combo)
        layout.addLayout(tool_layout)
        
        # Color and Thickness
        color_layout = QHBoxLayout()
        self.color_button = QPushButton()
        self.color_button.setFixedSize(QSize(20, 20))
        self.color_button.clicked.connect(self.choose_color)
        self.thickness_spinbox = QSpinBox()
        self.thickness_spinbox.setMinimum(1)
        self.thickness_spinbox.setMaximum(20)
        self.thickness_spinbox.setValue(2)
        color_layout.addWidget(QLabel("Color:"))
        color_layout.addWidget(self.color_button)
        color_layout.addWidget(QLabel("Thickness:"))
        color_layout.addWidget(self.thickness_spinbox)
        layout.addLayout(color_layout)
        
        # Font Settings (for Text tool)
        font_layout = QHBoxLayout()
        self.font_combo = QFontComboBox()
        self.font_size_spinbox = QSpinBox()
        self.font_size_spinbox.setMinimum(1)
        self.font_size_spinbox.setMaximum(100)
        self.font_size_spinbox.setValue(12)
        font_layout.addWidget(QLabel("Font:"))
        font_layout.addWidget(self.font_combo)
        font_layout.addWidget(QLabel("Size:"))
        font_layout.addWidget(self.font_size_spinbox)
        layout.addLayout(font_layout)
        
        # Undo/Redo Buttons
        undo_redo_layout = QHBoxLayout()
        self.undo_button = QPushButton("Undo")
        self.undo_button.clicked.connect(self.undo)
        self.redo_button = QPushButton("Redo")
        self.redo_button.clicked.connect(self.redo)
        undo_redo_layout.addWidget(self.undo_button)
        undo_redo_layout.addWidget(self.redo_button)
        layout.addLayout(undo_redo_layout)
        
        # Selection and Cropping
        selection_layout = QHBoxLayout()
        self.selection_button = QPushButton("Select")
        self.selection_button.clicked.connect(self.select_region)
        self.crop_button = QPushButton("Crop")
        self.crop_button.clicked.connect(self.crop_image)
        selection_layout.addWidget(self.selection_button)
        selection_layout.addWidget(self.crop_button)
        layout.addLayout(selection_layout)
        
        # Watermark
        watermark_layout = QHBoxLayout()
        self.watermark_checkbox = QCheckBox("Add Watermark")
        self.watermark_checkbox.stateChanged.connect(self.toggle_watermark)
        self.watermark_button = QToolButton()
        self.watermark_button.setToolTip("Select Watermark Image")
        self.watermark_button.clicked.connect(self.choose_watermark)
        watermark_layout.addWidget(self.watermark_checkbox)
        watermark_layout.addWidget(self.watermark_button)
        layout.addLayout(watermark_layout)
        
        # Stamps
        stamp_layout = QHBoxLayout()
        self.stamp_combo = QComboBox()
        self.stamp_combo.addItems(["Approved", "Draft", "Confidential", "Urgent"])
        stamp_layout.addWidget(QLabel("Stamps:"))
        stamp_layout.addWidget(self.stamp_combo)
        layout.addLayout(stamp_layout)
        
        # OK and Cancel Buttons
        button_layout = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(self.ok_button)
        button_layout.addWidget(self.cancel_button)
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
        
        # Initialize variables
        self.current_tool = "Freehand"
        self.current_color = Qt.red
        self.thickness_spinbox.setValue(2)
        self.font_combo.setCurrentFont(QFont("Arial"))
        self.font_size_spinbox.setValue(12)
        self.watermark_image = None
        self.watermark_checkbox.setChecked(False)
        
        # Video Editing
        video_editing_layout = QHBoxLayout()
        self.trim_start_button = QPushButton("Trim Start")
        self.trim_start_button.clicked.connect(self.trim_start)
        self.trim_end_button = QPushButton("Trim End")
        self.trim_end_button.clicked.connect(self.trim_end)
        self.split_button = QPushButton("Split")
        self.split_button.clicked.connect(self.split_video)
        video_editing_layout.addWidget(self.trim_start_button)
        video_editing_layout.addWidget(self.trim_end_button)
        video_editing_layout.addWidget(self.split_button)
        layout.addLayout(video_editing_layout)
        
        self.update_color_button()
    
    def tool_changed(self, tool):
        self.current_tool = tool
    
    def choose_color(self):
        color = QColorDialog.getColor(self.current_color, self)
        if color.isValid():
            self.current_color = color
            self.update_color_button()
    
    def update_color_button(self):
        pixmap = QPixmap(20, 20)
        pixmap.fill(self.current_color)
        self.color_button.setIcon(pixmap)
    
    def undo(self):
        # Implement undo functionality here
        pass
    
    def redo(self):
        # Implement redo functionality here
        pass
    
    def select_region(self):
        # Implement region selection functionality here
        pass
    
    def crop_image(self):
        # Implement image cropping functionality here
        pass
    
    def toggle_watermark(self, state):
        if state == Qt.Checked:
            # Enable watermark
            pass
        else:
            # Disable watermark
            pass
        
    def trim_start(self):
        # Get the current video position as the start time
        start_time = self.get_current_video_position()
        
        # Emit the videoEditingApplied signal with the trim_start type and start time
        self.videoEditingApplied.emit("trim_start", start_time, None)

    def trim_end(self):
        # Get the current video position as the end time
        end_time = self.get_current_video_position()
        
        # Emit the videoEditingApplied signal with the trim_end type and end time
        self.videoEditingApplied.emit("trim_end", None, end_time)

    def split_video(self):
        # Get the current video position as the split time
        split_time = self.get_current_video_position()
        
        # Emit the videoEditingApplied signal with the split type and split time
        self.videoEditingApplied.emit("split", split_time, split_time)

    def get_current_video_position(self):
        # Implement logic to retrieve the current position of the video player
        # Return the current position in seconds
        current_position = 0.0  # Replace with the actual current position
        return current_position
    
    def choose_watermark(self):
        file_dialog = QFileDialog()
        image_file, _ = file_dialog.getOpenFileName(self, "Select Watermark Image", "", "Image Files (*.png *.jpg *.bmp)")
        if image_file:
            self.watermark_image = QImage(image_file)
    
    def accept(self):
        # Perform actions when OK button is clicked
        pass
    
    def reject(self):
        # Perform actions when Cancel button is clicked
        pass   
################################ SCREEN TOOL START ################################

################################ DUPLICATE REMOVER START ################################
class DuplicateRemoverUserSettings:
    def __init__(self):
        self.last_opened_files = []
        self.window_size = QSize(800, 600)
        self.window_position = None
        self.duplicate_highlight_color = QColor("yellow")

    def load_settings(self, settings):
        self.last_opened_files = settings.value("last_opened_files", [])
        self.window_size = settings.value("window_size", QSize(800, 600))
        self.window_position = settings.value("window_position")
        self.duplicate_highlight_color = settings.value("duplicate_highlight_color", QColor("yellow"))

    def save_settings(self, settings):
        settings.setValue("last_opened_files", self.last_opened_files)
        settings.setValue("window_size", self.window_size)
        settings.setValue("window_position", self.window_position)
        settings.setValue("duplicate_highlight_color", self.duplicate_highlight_color)

class DuplicateRemoverLogger:
    def __init__(self, log_file):
        self.logger = logging.getLogger("TextEditorLogger")
        self.logger.setLevel(logging.DEBUG)

        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(logging.DEBUG)

        formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
        file_handler.setFormatter(formatter)

        self.logger.addHandler(file_handler)

    def log(self, level, message):
        self.logger.log(level, message)  

class DuplicateRemoverDuplicateConfirmDialog(QDialog):
    def __init__(self, duplicates, merge_duplicates=False, parent=None):
        super().__init__(parent)
        self.duplicates = duplicates
        self.selected_lines = []
        self.criteria = "exact"
        self.case_sensitive = True
        self.ignore_whitespace = False
        self.merge_duplicates = merge_duplicates
        self.initUI()

    def initUI(self):
        self.setWindowTitle("Confirm Duplicate Removal")
        layout = QVBoxLayout(self)

        criteria_layout = QHBoxLayout()
        criteria_label = QLabel("Duplicate Criteria:")
        criteria_layout.addWidget(criteria_label)

        self.criteria_combo = QComboBox()
        self.criteria_combo.addItems(["Exact Match", "Similar Text", "Regular Expression"])
        self.criteria_combo.currentTextChanged.connect(self.update_criteria)
        criteria_layout.addWidget(self.criteria_combo)

        self.case_check = QCheckBox("Case Sensitive")
        self.case_check.setChecked(self.case_sensitive)
        self.case_check.stateChanged.connect(self.update_case_sensitive)
        criteria_layout.addWidget(self.case_check)

        self.whitespace_check = QCheckBox("Ignore Whitespace")
        self.whitespace_check.setChecked(self.ignore_whitespace)
        self.whitespace_check.stateChanged.connect(self.update_ignore_whitespace)
        criteria_layout.addWidget(self.whitespace_check)

        layout.addLayout(criteria_layout)

        self.regex_input = QLineEdit()
        self.regex_input.setPlaceholderText("Enter regular expression")
        self.regex_input.setVisible(False)
        layout.addWidget(self.regex_input)

        self.tableWidget = QTableWidget()
        self.tableWidget.setColumnCount(2)
        self.tableWidget.setHorizontalHeaderLabels(['Select', 'Duplicate Line'])
        self.tableWidget.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)

        self.loadTableData()

        layout.addWidget(self.tableWidget)

        button_layout = QHBoxLayout()

        self.selectAllButton = QPushButton("Select All")
        self.selectAllButton.clicked.connect(self.selectAll)
        button_layout.addWidget(self.selectAllButton)

        self.deselectAllButton = QPushButton("Deselect All")
        self.deselectAllButton.clicked.connect(self.deselectAll)
        button_layout.addWidget(self.deselectAllButton)

        self.merge_check = QCheckBox("Merge Duplicates")
        self.merge_check.setChecked(self.merge_duplicates)
        self.merge_check.stateChanged.connect(self.update_merge_duplicates)
        button_layout.addWidget(self.merge_check)

        self.okButton = QPushButton("OK")
        self.okButton.clicked.connect(self.accept)
        button_layout.addWidget(self.okButton)

        self.cancelButton = QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.reject)
        button_layout.addWidget(self.cancelButton)

        layout.addLayout(button_layout)

    def loadTableData(self):
        self.tableWidget.setRowCount(len(self.duplicates))
        for i, (line, _) in enumerate(self.duplicates):
            checkbox = QTableWidgetItem()
            checkbox.setCheckState(Qt.Checked)
            self.tableWidget.setItem(i, 0, checkbox)
            self.tableWidget.setItem(i, 1, QTableWidgetItem(line))

    def selectAll(self):
        for i in range(self.tableWidget.rowCount()):
            self.tableWidget.item(i, 0).setCheckState(Qt.Checked)

    def deselectAll(self):
        for i in range(self.tableWidget.rowCount()):
            self.tableWidget.item(i, 0).setCheckState(Qt.Unchecked)

    def update_criteria(self, text):
        self.criteria = text.lower().replace(" ", "_")
        self.regex_input.setVisible(self.criteria == "regular_expression")

    def update_case_sensitive(self, state):
        self.case_sensitive = state == Qt.Checked

    def update_ignore_whitespace(self, state):
        self.ignore_whitespace = state == Qt.Checked

    def update_merge_duplicates(self, state):
        self.merge_duplicates = state == Qt.Checked

    def accept(self):
        self.selected_lines = [self.tableWidget.item(i, 1).text() for i in range(self.tableWidget.rowCount()) if self.tableWidget.item(i, 0).checkState() == Qt.Checked]
        if self.merge_duplicates:
            self.selected_lines = list(set(self.selected_lines))  # Ensure unique lines
        super().accept()

class DuplicateRemoverContextualDuplicateDialog(QDialog):
    def __init__(self, duplicates, parent=None):
        super().__init__(parent)
        self.duplicates = duplicates
        self.initUI()

    def initUI(self):
        self.setWindowTitle("Contextual Duplicate Analysis")
        layout = QVBoxLayout(self)

        self.tableWidget = QTableWidget()
        self.tableWidget.setColumnCount(3)
        self.tableWidget.setHorizontalHeaderLabels(['Duplicate Line', 'Previous Context', 'Next Context'])
        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        self.loadTableData()

        layout.addWidget(self.tableWidget)

        self.closeButton = QPushButton("Close")
        self.closeButton.clicked.connect(self.accept)
        layout.addWidget(self.closeButton)

    def loadTableData(self):
        self.tableWidget.setRowCount(len(self.duplicates))
        for i, (line, context) in enumerate(self.duplicates):
            self.tableWidget.setItem(i, 0, QTableWidgetItem(line))
            self.tableWidget.setItem(i, 1, QTableWidgetItem('\n'.join(context['previous'])))
            self.tableWidget.setItem(i, 2, QTableWidgetItem('\n'.join(context['next'])))

class DuplicateRemoverBatchRemovalWindow(QWidget):
    def __init__(self, parent=None):
        super(DuplicateRemoverBatchRemovalWindow, self).__init__(parent)
        self.setWindowTitle("Batch Duplicate Removal")
        self.setGeometry(100, 100, 600, 400)
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout()

        self.fileListWidget = QListWidget()
        layout.addWidget(self.fileListWidget)

        button_layout = QHBoxLayout()

        self.addButton = QPushButton("Add Files")
        self.addButton.clicked.connect(self.add_files)
        button_layout.addWidget(self.addButton)

        self.removeButton = QPushButton("Remove Files")
        self.removeButton.clicked.connect(self.remove_files)
        button_layout.addWidget(self.removeButton)

        layout.addLayout(button_layout)

        self.progressBar = QProgressBar()
        self.progressBar.setRange(0, 100)
        layout.addWidget(self.progressBar)

        self.startButton = QPushButton("Start Batch Removal")
        self.startButton.clicked.connect(self.start_batch_removal)
        layout.addWidget(self.startButton)

        self.setLayout(layout)

    def add_files(self):
        file_paths, _ = QFileDialog.getOpenFileNames(self, "Select Files", "", "Text Files (*.txt);;Python Files (*.py);;C++ Files (*.cpp *.h);;Java Files (*.java)")
        self.fileListWidget.addItems(file_paths)

    def remove_files(self):
        current_item = self.fileListWidget.currentItem()
        if current_item:
            self.fileListWidget.takeItem(self.fileListWidget.row(current_item))

    def start_batch_removal(self):
        file_paths = [self.fileListWidget.item(i).text() for i in range(self.fileListWidget.count())]
        total_files = len(file_paths)
    
        duplicates_report = []
    
        for i, file_path in enumerate(file_paths):
            progress = (i + 1) / total_files * 100
            self.progressBar.setValue(progress)
        
            try:
                with open(file_path, 'r') as file:
                    lines = file.read().splitlines()
            
                duplicates = self.find_duplicates(lines)
                unique_lines = list(set(lines))
            
                if duplicates:
                    with open(file_path, 'w') as file:
                        file.write('\n'.join(unique_lines))
                
                    duplicates_report.extend([(duplicate, file_path, "Removed") for duplicate in duplicates])
                else:
                    duplicates_report.extend([(line, file_path, "No duplicates found") for line in unique_lines])
        
            except Exception as e:
                QMessageBox.critical(self, "Error", f"An error occurred while processing {file_path}: {str(e)}")
                return
    
        # Display the duplicate report
        report_window = DuplicateRemoverDuplicateReportWindow(duplicates_report, self)
        report_window.show()
    
        QMessageBox.information(self, "Batch Removal Complete", "Batch duplicate removal completed successfully.")

class DuplicateRemoverDuplicateReportWindow(QWidget):
    def __init__(self, duplicates, parent=None):
        super(DuplicateRemoverDuplicateReportWindow, self).__init__(parent)
        self.setWindowTitle("Duplicate Report")
        self.setGeometry(100, 100, 800, 600)
        self.duplicates = duplicates
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout()

        self.reportTextEdit = QTextEdit()
        self.reportTextEdit.setReadOnly(True)
        layout.addWidget(self.reportTextEdit)

        button_layout = QHBoxLayout()

        self.exportButton = QPushButton("Export Report")
        self.exportButton.clicked.connect(self.export_report)
        button_layout.addWidget(self.exportButton)

        self.closeButton = QPushButton("Close")
        self.closeButton.clicked.connect(self.close)
        button_layout.addWidget(self.closeButton)

        layout.addLayout(button_layout)

        self.setLayout(layout)

        self.generate_report()

    def generate_report(self):
        report = "Duplicate Report\n\n"
        for i, (line, location, action) in enumerate(self.duplicates, start=1):
            report += f"Duplicate {i}:\n"
            report += f"Line: {line}\n"
            report += f"Location: {location}\n"
            report += f"Action: {action}\n\n"

        self.reportTextEdit.setPlainText(report)

    def export_report(self):
        file_path, _ = QFileDialog.getSaveFileName(self, "Export Report", "", "Text Files (*.txt)")
        if file_path:
            try:
                with open(file_path, 'w') as file:
                    file.write(self.reportTextEdit.toPlainText())
                QMessageBox.information(self, "Export Successful", "Duplicate report exported successfully.")
            except Exception as e:
                QMessageBox.critical(self, "Export Error", f"An error occurred while exporting the report: {str(e)}")

class DuplicateRemoverTabPage(QWidget):
    def __init__(self, logger, parent=None):
        super(DuplicateRemoverTabPage, self).__init__(parent)
        self.logger = logger        
        self.layout = QVBoxLayout(self)

        self.textEdit = CustomPlainTextEdit()
        self.textEdit.textChanged.connect(self.prevent_duplicates)
        self.textEdit.textChanged.connect(self.update_word_count)
        self.textEdit.textChanged.connect(self.update_line_count)
        self.layout.addWidget(self.textEdit)

        button_layout = QHBoxLayout()

        self.undoButton = QPushButton("Undo")
        self.undoButton.setShortcut(QKeySequence.Undo)
        self.undoButton.clicked.connect(self.textEdit.undo)
        button_layout.addWidget(self.undoButton)

        self.redoButton = QPushButton("Redo")
        self.redoButton.setShortcut(QKeySequence.Redo)
        self.redoButton.clicked.connect(self.textEdit.redo)
        button_layout.addWidget(self.redoButton)

        self.searchButton = QPushButton("Search")
        self.searchButton.clicked.connect(self.search_text)
        button_layout.addWidget(self.searchButton)

        self.replaceButton = QPushButton("Replace")
        self.replaceButton.clicked.connect(self.replace_text)
        button_layout.addWidget(self.replaceButton)

        self.bookmarkButton = QPushButton("Bookmark Duplicates")
        self.bookmarkButton.clicked.connect(self.bookmark_duplicates)
        button_layout.addWidget(self.bookmarkButton)

        self.contextButton = QPushButton("Duplicate Context")
        self.contextButton.clicked.connect(self.show_duplicate_context)
        button_layout.addWidget(self.contextButton)

        self.removeDuplicatesButton = QPushButton("Remove Duplicates")
        self.removeDuplicatesButton.clicked.connect(self.remove_duplicates)
        button_layout.addWidget(self.removeDuplicatesButton)

        # Add close button to the tab
        self.close_button = QPushButton("Close Tab")
        #self.close_button.setFixedSize(20, 20)
        self.close_button.clicked.connect(self.close_tab)
        button_layout.addWidget(self.close_button)

        self.layout.addLayout(button_layout)

        self.file_path = None

        self.highlighter = PythonHighlighter(self.textEdit.document())
        self.highlighter.setDocument(None)

    def remove_duplicates(self):
        lines = self.get_text_lines()
        duplicates = self.find_duplicates(lines)
        if duplicates:
            dialog = DuplicateRemoverDuplicateConfirmDialog([(duplicate, None) for duplicate in duplicates], self)
            if dialog.exec_() == QDialog.Accepted:
                selected_duplicates = dialog.selected_lines
                unique_lines = [line for line in lines if line not in selected_duplicates]
                self.set_text_lines(unique_lines)
                self.logger.log(logging.INFO, f"Removed duplicates: {selected_duplicates}")
        else:
            QMessageBox.information(self, "No Duplicates", "No duplicate lines found.")

    def close_tab(self):
        parent = self.parent()
        while parent:
            if isinstance(parent, QTabWidget):
                parent.removeTab(parent.indexOf(self))
                break
            parent = parent.parent()

    def toggle_syntax_highlighting(self, enable):
        if enable:
            self.highlighter.setDocument(self.textEdit.document())
        else:
            self.highlighter.setDocument(None)

    def update_word_count(self):
        text = self.textEdit.toPlainText()
        word_count = len(text.split())
        main_window = self.get_main_window()
        if main_window:
            main_window.statusBar().showMessage(f"Word Count: {word_count}")

    def update_line_count(self):
        line_count = self.textEdit.blockCount()
        main_window = self.get_main_window()
        if main_window:
            main_window.statusBar().showMessage(f"Line Count: {line_count}")

    def get_main_window(self):
        parent = self.parentWidget()
        while parent:
            if isinstance(parent, DuplicateRemoverMainWindow):
                return parent
            parent = parent.parentWidget()
        return None

    def toggle_line_numbers(self, show_line_numbers):
        self.textEdit.lineNumberArea.setVisible(show_line_numbers)

    def update_line_number_area_width(self):
        self.textEdit.setViewportMargins(self.textEdit.line_number_area_width(), 0, 0, 0)

    def update_line_number_area(self, rect, dy):
        if dy:
            self.textEdit.lineNumberArea.scroll(0, dy)
        else:
            self.textEdit.lineNumberArea.update(0, rect.y(), self.textEdit.lineNumberArea.width(), rect.height())

        if rect.contains(self.textEdit.viewport().rect()):
            self.update_line_number_area_width()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        cr = self.textEdit.contentsRect()
        self.textEdit.lineNumberArea.setGeometry(QRect(cr.left(), cr.top(), self.textEdit.line_number_area_width(), cr.height()))

    def highlight_search_text(self, text):
        cursor = self.textEdit.textCursor()
        format = QTextCharFormat()
        format.setBackground(QColor("lightblue"))

        cursor.beginEditBlock()
        self.textEdit.moveCursor(QTextCursor.Start)
        while self.textEdit.find(text):
            cursor = self.textEdit.textCursor()
            cursor.mergeCharFormat(format)
        cursor.endEditBlock()

    def highlight_current_line(self):
        if self.textEdit.document().blockCount() == 1 and self.textEdit.toPlainText().strip() == "":
            return

        extraSelections = []

        if not self.textEdit.isReadOnly():
            selection = QTextEdit.ExtraSelection()

            lineColor = QColor(Qt.yellow).lighter(160)
            selection.format.setBackground(lineColor)
            selection.format.setProperty(QTextFormat.FullWidthSelection, True)
            selection.cursor = self.textEdit.textCursor()
            selection.cursor.clearSelection()
            extraSelections.append(selection)

        self.textEdit.setExtraSelections(extraSelections)

    def get_text_lines(self):
        return self.textEdit.toPlainText().split('\n')

    def set_text_lines(self, lines):
        self.textEdit.setPlainText('\n'.join(lines))

    def prevent_duplicates(self):
        lines = self.get_text_lines()
        duplicates = self.find_duplicates(lines)
        if duplicates:
            pass

    def bookmark_duplicates(self):
        lines = self.get_text_lines()
        duplicates = self.find_duplicates(lines)
        if not duplicates:
            QMessageBox.information(self, "No Duplicates", "No duplicate lines found.")
            return

        options, ok = QInputDialog.getItem(self, "Bookmark Options", "Choose the type of duplicates to bookmark:", ["Exact Duplicates", "Close Duplicates", "Lines that start the same"], 0, False)
        if not ok:
            return

        self.worker = DuplicateRemoverBookmarkWorker(lines, options)
        self.thread = QThread()
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)

        # Connect progress signal to update UI
        self.worker.progress.connect(self.update_bookmark_progress)

        self.thread.start()

    def update_bookmark_progress(self, progress, total):
        cursor = self.textEdit.textCursor()
        format = QTextCharFormat()
        format.setBackground(QColor("yellow"))
        position = progress  # Assuming progress is the position of the line to highlight
        cursor.movePosition(QTextCursor.Start)
        cursor.movePosition(QTextCursor.Down, QTextCursor.MoveAnchor, position)
        cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)
        cursor.setCharFormat(format)

    def show_duplicate_context(self):
        lines = self.get_text_lines()
        duplicates_with_context = self.find_duplicates_with_context(lines)
        dialog = DuplicateRemoverContextualDuplicateDialog(duplicates_with_context, self)
        dialog.exec_()

    def find_duplicates(self, lines):
        duplicates = []
        seen = set()
        for line in lines:
            if line in seen:
                duplicates.append(line)
            else:
                seen.add(line)
        return duplicates

    def find_duplicates_with_context(self, lines, context_size=2):
        duplicates_with_context = []
        seen = set()
        for i, line in enumerate(lines):
            if line in seen:
                previous_context = lines[max(0, i - context_size):i]
                next_context = lines[i + 1:i + context_size + 1]
                duplicates_with_context.append((line, {'previous': previous_context, 'next': next_context}))
            else:
                seen.add(line)
        return duplicates_with_context

    def search_text(self):
        search_dialog = DuplicateRemoverSearchDialog(self)
        if search_dialog.exec_() == QDialog.Accepted:
            search_text = search_dialog.search_input.text()
            self.highlight_search_text(search_text)

    def replace_text(self):
        replace_dialog = DuplicateRemoverReplaceDialog(self)
        if replace_dialog.exec_() == QDialog.Accepted:
            search_text = replace_dialog.search_input.text()
            replace_text = replace_dialog.replace_input.text()
            use_regex = replace_dialog.regex_check.isChecked()
            self.replace_text(search_text, replace_text, use_regex)

    def sortLines(self, sort_type):
        lines = self.get_text_lines()
        if sort_type == 'line_size_asc':
            sorted_lines = sorted(lines, key=len)
        elif sort_type == 'line_size_desc':
            sorted_lines = sorted(lines, key=len, reverse=True)
        elif sort_type == 'alphabetical':
            sorted_lines = sorted(lines)
        self.set_text_lines(sorted_lines)

class DuplicateRemoverBookmarkWorker(QObject):
    finished = pyqtSignal()
    progress = pyqtSignal(int, int)  # Signal to report progress

    def __init__(self, lines, option):
        super().__init__()
        self.lines = lines
        self.option = option

    @pyqtSlot()
    def run(self):
        duplicates = self.find_duplicates(self.lines)
        cursor_positions = []

        if self.option == "Exact Duplicates":
            for line in duplicates:
                line_positions = [i for i, l in enumerate(self.lines) if l == line]
                for position in line_positions:
                    cursor_positions.append(position)
                    self.progress.emit(len(cursor_positions), len(self.lines))

        elif self.option == "Close Duplicates":
            # Implement close duplicates logic here
            pass

        elif self.option == "Lines that start the same":
            starts = [line.split()[0] for line in self.lines if line.split()]
            for start in set(starts):
                start_positions = [i for i, l in enumerate(self.lines) if l.startswith(start)]
                for position in start_positions:
                    cursor_positions.append(position)
                    self.progress.emit(len(cursor_positions), len(self.lines))

        self.finished.emit()

    def find_duplicates(self, lines):
        # Placeholder for duplicate finding logic
        return list(set([line for line in lines if lines.count(line) > 1]))
        
class PythonHighlighter(QSyntaxHighlighter):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.highlight_rules = []

        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor("blue"))
        keyword_format.setFontWeight(QFont.Bold)
        keywords = ["and", "as", "assert", "break", "class", "continue", "def",
                    "del", "elif", "else", "except", "False", "finally", "for",
                    "from", "global", "if", "import", "in", "is", "lambda", "None",
                    "nonlocal", "not", "or", "pass", "raise", "return", "True",
                    "try", "while", "with", "yield"]
        self.highlight_rules.append((QRegularExpression(r"\b(" + "|".join(keywords) + r")\b"), keyword_format))

        # Add more highlighting rules for other syntax elements

    def highlightBlock(self, text):
        for pattern, format in self.highlight_rules:
            expression = QRegularExpression(pattern)
            match_iterator = expression.globalMatch(text)
            while match_iterator.hasNext():
                match = match_iterator.next()
                self.setFormat(match.capturedStart(), match.capturedLength(), format)

class CustomPlainTextEdit(QPlainTextEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.lineNumberArea = LineNumberArea(self)
        self.blockCountChanged.connect(self.update_line_number_area_width)
        self.updateRequest.connect(self.update_line_number_area)
        self.cursorPositionChanged.connect(self.highlight_current_line)
        self.update_line_number_area_width()

    def line_number_area_width(self):
        digits = len(str(max(1, self.blockCount())))
        space = 3 + self.fontMetrics().width('9') * digits
        return space

    def update_line_number_area_width(self):
        self.setViewportMargins(self.line_number_area_width(), 0, 0, 0)

    def update_line_number_area(self, rect, dy):
        if dy:
            self.lineNumberArea.scroll(0, dy)
        else:
            self.lineNumberArea.update(0, rect.y(), self.lineNumberArea.width(), rect.height())

        if rect.contains(self.viewport().rect()):
            self.update_line_number_area_width()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        cr = self.contentsRect()
        self.lineNumberArea.setGeometry(QRect(cr.left(), cr.top(), self.line_number_area_width(), cr.height()))

    def highlight_current_line(self):
        if self.document().blockCount() == 1 and self.toPlainText().strip() == "":
            return

        extraSelections = []

        if not self.isReadOnly():
            selection = QTextEdit.ExtraSelection()

            lineColor = QColor(Qt.yellow).lighter(160)

            selection.format.setBackground(lineColor)
            selection.format.setProperty(QTextFormat.FullWidthSelection, True)
            selection.cursor = self.textCursor()
            selection.cursor.clearSelection()
            extraSelections.append(selection)

        self.setExtraSelections(extraSelections)

    def lineNumberAreaPaintEvent(self, event):
        painter = QPainter(self.lineNumberArea)
        painter.fillRect(event.rect(), Qt.lightGray)

        block = self.firstVisibleBlock()
        blockNumber = block.blockNumber()
        top = int(self.blockBoundingGeometry(block).translated(self.contentOffset()).top())
        bottom = top + int(self.blockBoundingRect(block).height())

        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                number = str(blockNumber + 1)
                painter.setPen(Qt.black)
                painter.drawText(0, top, self.lineNumberArea.width(), self.fontMetrics().height(),
                                 Qt.AlignRight, number)

            block = block.next()
            top = bottom
            bottom = top + int(self.blockBoundingRect(block).height())
            blockNumber += 1

class LineNumberArea(QWidget):
    def __init__(self, editor):
        super().__init__(editor)
        self.editor = editor

    def sizeHint(self):
        return QSize(self.editor.line_number_area_width(), 0)

    def paintEvent(self, event):
        self.editor.lineNumberAreaPaintEvent(event)

class DuplicateRemoverSearchDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Search")
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Enter search text")
        layout.addWidget(self.search_input)

        button_layout = QHBoxLayout()

        self.searchButton = QPushButton("Search")
        self.searchButton.clicked.connect(self.accept)
        button_layout.addWidget(self.searchButton)

        self.cancelButton = QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.reject)
        button_layout.addWidget(self.cancelButton)

        layout.addLayout(button_layout)

class DuplicateRemoverReplaceDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Replace")
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Enter search text")
        layout.addWidget(self.search_input)

        self.replace_input = QLineEdit()
        self.replace_input.setPlaceholderText("Enter replace text")
        layout.addWidget(self.replace_input)
        
        self.regex_check = QCheckBox("Use Regular Expression")
        layout.addWidget(self.regex_check)

        button_layout = QHBoxLayout()

        self.replaceButton = QPushButton("Replace")
        self.replaceButton.clicked.connect(self.accept)
        button_layout.addWidget(self.replaceButton)

        self.cancelButton = QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.reject)
        button_layout.addWidget(self.cancelButton)

        layout.addLayout(button_layout)

class DuplicateRemoverMainWindow(QMainWindow):
    def __init__(self, parent=None):
        super(DuplicateRemoverMainWindow, self).__init__()
        self.setWindowFlags(Qt.Window)
        self.setWindowTitle("TSTP:Duplicate Deleter")
        self.setGeometry(100, 100, 800, 600)

        self.tabWidget = QTabWidget()
        self.setCentralWidget(self.tabWidget)

        self.user_settings = DuplicateRemoverUserSettings()
        self.logger = DuplicateRemoverLogger("app.log")

        self.load_settings()
        self.initUI()

        # Apply the same stylesheet as the main program and connect to theme changes
        if parent:
            self.setStyleSheet(parent.styleSheet())
            parent.themeChanged.connect(self.updateStyleSheet)

    def updateStyleSheet(self, styleSheet):
        self.setStyleSheet(styleSheet)

    def initUI(self):
        self.menuBar().setNativeMenuBar(False)
        self.setupMenuBar()

        # Set up the status bar
        self.statusBar().showMessage("Ready")

        # Set up the progress bar in the status bar
        self.progressBar = QProgressBar()
        self.progressBar.setRange(0, 100)
        self.statusBar().addPermanentWidget(self.progressBar)

        # Set up the compare files feature
        self.compareFilesButton = QPushButton("Compare Files")
        self.compareFilesButton.clicked.connect(self.compare_files)
        self.statusBar().addPermanentWidget(self.compareFilesButton)

        # Set up the main layout
        main_layout = QVBoxLayout()
        central_widget = QWidget()
        central_widget.setLayout(main_layout)
        main_layout.addWidget(self.tabWidget)
        self.setCentralWidget(central_widget)

        # Set up tooltips and help texts
        self.setToolTip("Multiple File Editor")
        self.tabWidget.setToolTip("Edit multiple files in separate tabs")

        # Set up the tutorial
        self.tutorialWindow = DuplicateRemoverTutorialWindow(self)
        #self.tutorialWindow.show()

        # Restore the window size and position
        if self.user_settings.window_size:
            self.resize(self.user_settings.window_size)
        if self.user_settings.window_position:
            self.move(self.user_settings.window_position)

        # Open the last opened files
        #for file_path in self.user_settings.last_opened_files:
        #    self.openFile(file_path)

    def setupMenuBar(self):
        menuBar = self.menuBar()
        fileMenu = menuBar.addMenu('File')

        newTabAction = QAction('New Tab', self)
        newTabAction.triggered.connect(self.newTab)
        fileMenu.addAction(newTabAction)

        openAction = QAction('Open', self)
        openAction.triggered.connect(self.openFile)
        fileMenu.addAction(openAction)

        saveAction = QAction('Save', self)
        saveAction.triggered.connect(self.saveFile)
        fileMenu.addAction(saveAction)

        saveAsAction = QAction('Save As', self)
        saveAsAction.triggered.connect(self.saveFileAs)
        fileMenu.addAction(saveAsAction)

        settingsAction = QAction('Settings', self)
        settingsAction.triggered.connect(self.openSettings)
        fileMenu.addAction(settingsAction)

        toggleDarkModeAction = QAction('Toggle Dark Mode', self)
        toggleDarkModeAction.triggered.connect(self.apply_dark_mode)
        fileMenu.addAction(toggleDarkModeAction)

        exitAction = QAction('Exit', self)
        exitAction.triggered.connect(self.close)
        fileMenu.addAction(exitAction)

        editMenu = menuBar.addMenu('Edit')

        removeDuplicatesAction = QAction('Remove Duplicates', self)
        removeDuplicatesAction.triggered.connect(self.removeDuplicates)
        editMenu.addAction(removeDuplicatesAction)

        mergeDuplicatesAction = QAction('Merge Duplicates', self)
        mergeDuplicatesAction.triggered.connect(self.mergeDuplicates)
        editMenu.addAction(mergeDuplicatesAction)

        sortMenu = editMenu.addMenu('Sort')

        sortAscLineSizeAction = QAction('Sort by Line Size (Ascending)', self)
        sortAscLineSizeAction.triggered.connect(lambda: self.sortLines('line_size_asc'))
        sortMenu.addAction(sortAscLineSizeAction)

        sortDescLineSizeAction = QAction('Sort by Line Size (Descending)', self)
        sortDescLineSizeAction.triggered.connect(lambda: self.sortLines('line_size_desc'))
        sortMenu.addAction(sortDescLineSizeAction)

        sortAlphabeticalAction = QAction('Sort Alphabetically', self)
        sortAlphabeticalAction.triggered.connect(lambda: self.sortLines('alphabetical'))
        sortMenu.addAction(sortAlphabeticalAction)

        goToLineAction = QAction('Go to Line', self)
        goToLineAction.triggered.connect(self.go_to_line)
        editMenu.addAction(goToLineAction)

        viewMenu = menuBar.addMenu('View')
        self.show_line_numbers_action = QAction('Show Line Numbers', self, checkable=True)
        self.show_line_numbers_action.triggered.connect(self.toggle_line_numbers)
        viewMenu.addAction(self.show_line_numbers_action)

        self.word_wrap_action = QAction('Word Wrap', self, checkable=True)
        self.word_wrap_action.triggered.connect(self.toggle_word_wrap)
        viewMenu.addAction(self.word_wrap_action)

        self.syntax_highlighting_action = QAction('Toggle Syntax Highlighting', self, checkable=True)
        self.syntax_highlighting_action.triggered.connect(self.toggle_syntax_highlighting)
        self.syntax_highlighting_action.setChecked(False)  # Disable by default
        viewMenu.addAction(self.syntax_highlighting_action)

        zoomInAction = QAction('Zoom In', self)
        zoomInAction.triggered.connect(self.zoom_in)
        viewMenu.addAction(zoomInAction)

        zoomOutAction = QAction('Zoom Out', self)
        zoomOutAction.triggered.connect(self.zoom_out)
        viewMenu.addAction(zoomOutAction)

        batchMenu = menuBar.addMenu('Batch')

        batchRemoveAction = QAction('Batch Duplicate Removal', self)
        batchRemoveAction.triggered.connect(self.batchRemoveDuplicates)
        batchMenu.addAction(batchRemoveAction)

        batchMergeAction = QAction('Batch Merge Files', self)
        batchMergeAction.triggered.connect(self.batchMergeFiles)
        batchMenu.addAction(batchMergeAction)

        helpMenu = menuBar.addMenu('Help')

        tutorialAction = QAction('Tutorial', self)
        tutorialAction.triggered.connect(self.showTutorial)
        helpMenu.addAction(tutorialAction)
        
    def apply_dark_mode(self):
        dark_stylesheet = """
        QWidget {
            background-color: #333333;
            color: #ffffff;
        }
        QPlainTextEdit {
            background-color: #1e1e1e;
            color: #dcdcdc;
        }
        QPushButton {
            background-color: #555555;
            border: 1px solid #666666;
            color: white;
        }
        QPushButton:hover {
            background-color: #777777;
        }
        QTabWidget::pane {
            border-top: 2px solid #555555;
        }
        QTabBar::tab {
            background-color: #555555;
            padding: 5px;
        }
        QTabBar::tab:selected {
            background: #333333;
            margin-bottom: -1px;
        }
        QMenuBar {
            background-color: #333333;
            color: #ffffff;
        }
        QMenuBar::item {
            background-color: #333333;
            color: #ffffff;
        }
        QMenuBar::item:selected {
            background-color: #555555;
        }
        QMenu {
            background-color: #333333;
            color: #ffffff;
        }
        QMenu::item:selected {
            background-color: #555555;
        }
        """
        self.setStyleSheet(dark_stylesheet)
        
    def toggle_syntax_highlighting(self):
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            current_tab.toggle_syntax_highlighting(self.syntax_highlighting_action.isChecked())

    def newTab(self, file_name="Untitled"):
        # Log the type and value of file_name
        print(f"Creating a new tab with file name: {file_name} (type: {type(file_name)})")

        # Ensure file_name is a valid string and not a boolean string or other invalid values
        if not isinstance(file_name, str) or file_name.lower() in ["false", "true", "", "none"]:
            print(f"Invalid file_name '{file_name}', resetting to 'Untitled'")
            file_name = "Untitled"

        tab = DuplicateRemoverTabPage(self.logger)
    
        # Add the tab with the correct file name
        self.tabWidget.addTab(tab, file_name)
        self.tabWidget.setCurrentWidget(tab)

    def openFile(self):
        try:
            file_dialog = QFileDialog()
            file_dialog.setNameFilters(["UTF-8 (*.txt)", "UTF-16 (*.txt)", "ISO-8859-1 (*.txt)", "Windows-1252 (*.txt)", "All Files (*)"])
            file_dialog.selectNameFilter("UTF-8 (*.txt)")

            if file_dialog.exec_():
                selected_file = file_dialog.selectedFiles()[0]
                encoding = file_dialog.selectedNameFilter().split(" ")[0]

                with open(selected_file, 'r', encoding=encoding) as file:
                    content = file.read()

                current_tab = self.tabWidget.currentWidget()
                current_tab_index = self.tabWidget.currentIndex()
                file_name = selected_file.split('/')[-1]

                # If no tabs are open, open a new tab and load the file
                if self.tabWidget.count() == 0:
                    if file_dialog:
                        self.newTab(file_name)
                    else:
                        self.newTab("Untitled")
                    current_tab = self.tabWidget.currentWidget()
                    current_tab_index = self.tabWidget.currentIndex()
                    current_tab.textEdit.setPlainText(content)
                    current_tab.file_path = selected_file
                # If the current tab is empty and named "Untitled", load the file in the current tab
                elif current_tab.textEdit.toPlainText() == "" and self.tabWidget.tabText(current_tab_index) == "Untitled":
                    current_tab.textEdit.setPlainText(content)
                    self.tabWidget.setTabText(current_tab_index, file_name)
                    current_tab.file_path = selected_file
                else:
                    # Open the file in a new tab
                    self.newTab(file_name)
                    new_tab = self.tabWidget.currentWidget()
                    new_tab.textEdit.setPlainText(content)
                    new_tab.file_path = selected_file

                # Ensure the new tab has the cursor at the start
                current_tab.textEdit.moveCursor(QTextCursor.Start)
                cursor = current_tab.textEdit.textCursor()
                cursor.movePosition(QTextCursor.Start)
                cursor.clearSelection()
                cursor.setCharFormat(QTextCharFormat())  # Clear any unwanted formatting
                self.logger.log(logging.INFO, f"Opened file: {selected_file} with encoding: {encoding}")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while opening the file: {str(e)}")
            self.logger.log(logging.ERROR, f"Error opening file: {selected_file} - {str(e)}")

    def saveFile(self):
        current_tab = self.tabWidget.currentWidget()
        if current_tab and current_tab.file_path:
            self.save_file(current_tab.file_path)

    def saveFileAs(self):
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            file_path, _ = QFileDialog.getSaveFileName(self, "Save File As", "", "Text Files (*.txt);;Python Files (*.py);;C++ Files (*.cpp *.h);;Java Files (*.java)")
            if file_path:
                self.save_file(file_path)

    def save_file(self, file_path):
        try:
            file_dialog = QFileDialog()
            file_dialog.setNameFilters(["UTF-8 (*.txt)", "UTF-16 (*.txt)", "ISO-8859-1 (*.txt)", "Windows-1252 (*.txt)", "All Files (*)"])
            file_dialog.selectNameFilter("UTF-8 (*.txt)")
        
            if file_dialog.exec_():
                selected_file = file_dialog.selectedFiles()[0]
                encoding = file_dialog.selectedNameFilter().split(" ")[0]
            
                with open(selected_file, 'w', encoding=encoding) as file:
                    file.write(self.tabWidget.currentWidget().textEdit.toPlainText())
                self.tabWidget.setTabText(self.tabWidget.currentIndex(), selected_file.split('/')[-1])
                self.logger.log(logging.INFO, f"Saved file: {selected_file} with encoding: {encoding}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while saving the file: {str(e)}")
            self.logger.log(logging.ERROR, f"Error saving file: {file_path} - {str(e)}")
            
    def removeDuplicates(self):
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            lines = current_tab.get_text_lines()
            duplicates = current_tab.find_duplicates(lines)
            if duplicates:
                dialog = DuplicateRemoverDuplicateConfirmDialog([(duplicate, None) for duplicate in duplicates], merge_duplicates=False, parent=self)
                if dialog.exec_() == QDialog.Accepted:
                    selected_duplicates = dialog.selected_lines
                    unique_lines = [line for line in lines if line not in selected_duplicates]
                    current_tab.set_text_lines(unique_lines)
                    self.logger.log(logging.INFO, f"Removed duplicates: {selected_duplicates}")
            else:
                QMessageBox.information(self, "No Duplicates", "No duplicate lines found.")
                
    def mergeDuplicates(self):
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            lines = current_tab.get_text_lines()
            duplicates = current_tab.find_duplicates(lines)
            if duplicates:
                dialog = DuplicateRemoverDuplicateConfirmDialog([(duplicate, None) for duplicate in duplicates], merge_duplicates=True, parent=self)
                dialog.merge_check.setChecked(True)
                if dialog.exec_() == QDialog.Accepted:
                    selected_duplicates = dialog.selected_lines
                    merged_lines = self.merge_lines(lines, selected_duplicates)
                    current_tab.set_text_lines(merged_lines)
                    self.logger.log(logging.INFO, f"Merged duplicates: {selected_duplicates}")
            else:
                QMessageBox.information(self, "No Duplicates", "No duplicate lines found.")

    def merge_lines(self, lines, duplicates):
        merged_lines = []
        for line in lines:
            if line in duplicates:
                if line not in merged_lines:
                    merged_lines.append(line)
            else:
                merged_lines.append(line)
        return merged_lines
        
    def sortLines(self, sort_type):
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            current_tab.sortLines(sort_type)
            
    def go_to_line(self):
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            line_number, ok = QInputDialog.getInt(self, "Go to Line", "Enter line number:", min=1, max=current_tab.textEdit.blockCount())
            if ok:
                cursor = current_tab.textEdit.textCursor()
                cursor.movePosition(QTextCursor.Start)
                cursor.movePosition(QTextCursor.Down, QTextCursor.MoveAnchor, line_number - 1)
                current_tab.textEdit.setTextCursor(cursor)
                current_tab.textEdit.centerCursor()
                
    def toggle_line_numbers(self):
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            current_tab.toggle_line_numbers(self.show_line_numbers_action.isChecked())
            
    def toggle_word_wrap(self):
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            if self.word_wrap_action.isChecked():
                current_tab.textEdit.setLineWrapMode(QPlainTextEdit.WidgetWidth)
            else:
                current_tab.textEdit.setLineWrapMode(QPlainTextEdit.NoWrap)
                
    def zoom_in(self):
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            font = current_tab.textEdit.font()
            font.setPointSize(font.pointSize() + 1)
            current_tab.textEdit.setFont(font)

    def zoom_out(self):
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            font = current_tab.textEdit.font()
            font.setPointSize(max(1, font.pointSize() - 1))
            current_tab.textEdit.setFont(font)
            
    def batchRemoveDuplicates(self):
        batch_window = DuplicateRemoverBatchRemovalWindow(self)
        batch_window.show()

    def batchMergeFiles(self):
        file_paths, _ = QFileDialog.getOpenFileNames(self, "Select Files to Merge", "", "Text Files (*.txt);;Python Files (*.py);;C++ Files (*.cpp *.h);;Java Files (*.java)")
        if file_paths:
            merged_lines = []
            for file_path in file_paths:
                try:
                    with open(file_path, 'r') as file:
                        lines = file.read().splitlines()
                    merged_lines.extend(lines)
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"An error occurred while reading file {file_path}: {str(e)}")
                    self.logger.log(logging.ERROR, f"Error reading file for merging: {file_path} - {str(e)}")
                    return

            merged_lines = list(set(merged_lines))  # Remove duplicates
            merged_file_path, _ = QFileDialog.getSaveFileName(self, "Save Merged File", "", "Text Files (*.txt);;Python Files (*.py);;C++ Files (*.cpp *.h);;Java Files (*.java)")
            if merged_file_path:
                try:
                    with open(merged_file_path, 'w') as file:
                        file.write('\n'.join(merged_lines))
                    self.logger.log(logging.INFO, f"Merged files: {file_paths} into {merged_file_path}")
                    QMessageBox.information(self, "Merge Complete", "Files merged successfully.")
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"An error occurred while saving the merged file: {str(e)}")
                    self.logger.log(logging.ERROR, f"Error saving merged file: {merged_file_path} - {str(e)}")

    def compare_files(self):
        file_paths, _ = QFileDialog.getOpenFileNames(self, "Select Files to Compare", "", "Text Files (*.txt);;Python Files (*.py);;C++ Files (*.cpp *.h);;Java Files (*.java)")
        if len(file_paths) == 2:
            try:
                with open(file_paths[0], 'r') as file1, open(file_paths[1], 'r') as file2:
                    lines1 = file1.readlines()
                    lines2 = file2.readlines()

                diff_dialog = DuplicateRemoverFileDiffDialog(lines1, lines2, file_paths[0], file_paths[1], self)
                diff_dialog.exec_()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"An error occurred while comparing the files: {str(e)}")
                self.logger.log(logging.ERROR, f"Error comparing files: {file_paths} - {str(e)}")
        else:
            QMessageBox.warning(self, "Invalid Selection", "Please select exactly two files for comparison.")

    def openSettings(self):
        settings_dialog = DuplicateRemoverSettingsDialog(self.user_settings, self)
        if settings_dialog.exec_() == QDialog.Accepted:
            self.user_settings = settings_dialog.user_settings
            self.logger.log(logging.INFO, "User settings updated")

    def showTutorial(self):
        self.tutorialWindow.show()

    def closeEvent(self, event):
        self.save_settings()
        event.accept()

    def load_settings(self):
        settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
        self.user_settings.load_settings(settings)

    def save_settings(self):
        settings = QSettings("The Solutions To Problems, LLC", "TSTP:Omni Omega")
        self.user_settings.window_size = self.size()
        self.user_settings.window_position = self.pos()
        self.user_settings.last_opened_files = [self.tabWidget.widget(i).file_path for i in range(self.tabWidget.count()) if self.tabWidget.widget(i).file_path]
        self.user_settings.save_settings(settings)

    def replace_text(self, search_text, replace_text, use_regex=False):
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            if use_regex:
                current_tab.textEdit.setPlainText(re.sub(search_text, replace_text, current_tab.textEdit.toPlainText()))
            else:
                current_tab.textEdit.setPlainText(current_tab.textEdit.toPlainText().replace(search_text, replace_text))

    def replace_text_dialog(self):
        replace_dialog = DuplicateRemoverReplaceDialog(self)
        if replace_dialog.exec_() == QDialog.Accepted:
            search_text = replace_dialog.search_input.text()
            replace_text = replace_dialog.replace_input.text()
            use_regex = replace_dialog.regex_check.isChecked()
            self.replace_text(search_text, replace_text, use_regex)

class DuplicateRemoverFileDiffDialog(QDialog):
    def __init__(self, lines1, lines2, file1_path, file2_path, parent=None):
        super().__init__(parent)
        self.setWindowTitle("File Comparison")
        self.setGeometry(100, 100, 800, 600)
        self.initUI(lines1, lines2, file1_path, file2_path)

    def initUI(self, lines1, lines2, file1_path, file2_path):
        layout = QVBoxLayout(self)

        # Create text edits for displaying file contents
        text_edit1 = QPlainTextEdit()
        text_edit1.setPlainText(''.join(lines1))
        text_edit1.setReadOnly(True)

        text_edit2 = QPlainTextEdit()
        text_edit2.setPlainText(''.join(lines2))
        text_edit2.setReadOnly(True)

        # Create a splitter to hold the text edits side by side
        splitter = QSplitter()
        splitter.addWidget(text_edit1)
        splitter.addWidget(text_edit2)
        layout.addWidget(splitter)

        # Create a label to display the file paths
        file_label = QLabel(f"Comparing: {file1_path} <-> {file2_path}")
        layout.addWidget(file_label)

        # Create a button box with Close button
        button_box = QDialogButtonBox(QDialogButtonBox.Close)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

class DuplicateRemoverSettingsDialog(QDialog):
    def __init__(self, user_settings, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Settings")
        self.user_settings = user_settings
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)

        # Create a form layout for settings fields
        form_layout = QFormLayout()

        # Add settings fields
        self.highlight_color_button = QPushButton()
        self.highlight_color_button.setStyleSheet(f"background-color: {self.user_settings.duplicate_highlight_color.name()}")
        self.highlight_color_button.clicked.connect(self.choose_highlight_color)
        form_layout.addRow("Duplicate Highlight Color:", self.highlight_color_button)

        layout.addLayout(form_layout)

        # Create a button box with OK and Cancel buttons
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

    def choose_highlight_color(self):
        color = QColorDialog.getColor(self.user_settings.duplicate_highlight_color, self, "Choose Duplicate Highlight Color")
        if color.isValid():
            self.user_settings.duplicate_highlight_color = color
            self.highlight_color_button.setStyleSheet(f"background-color: {color.name()}")

    def accept(self):
        super().accept()
        
class DuplicateRemoverTutorialWindow(QDialog):
    def __init__(self, parent=None):
        super(DuplicateRemoverTutorialWindow, self).__init__(parent)
        self.setWindowTitle("Interactive Tutorial")
        self.setGeometry(100, 100, 800, 600)
        self.setWindowModality(Qt.ApplicationModal)

        self.layout = QVBoxLayout()

        self.webView = QWebEngineView()
        self.layout.addWidget(self.webView)

        self.navigation_layout = QHBoxLayout()
        self.back_button = QPushButton("Previous")
        self.back_button.clicked.connect(self.go_to_previous_page)
        self.navigation_layout.addWidget(self.back_button)

        self.forward_button = QPushButton("Next")
        self.forward_button.clicked.connect(self.go_to_next_page)
        self.navigation_layout.addWidget(self.forward_button)

        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.navigation_layout.addWidget(self.progress_bar)

        self.start_button = QPushButton("Start Editing")
        self.start_button.clicked.connect(self.close)
        self.navigation_layout.addWidget(self.start_button)

        self.layout.addLayout(self.navigation_layout)
        self.setLayout(self.layout)

        self.current_page_index = 0
        self.tutorial_pages = [
            self.create_welcome_page(),
            self.create_opening_files_page(),
            self.create_editing_files_page(),
            self.create_saving_files_page(),
            self.create_removing_duplicates_page(),
            self.create_sorting_and_merging_page(),
            self.create_batch_operations_page(),
            self.create_additional_features_page(),
        ]

        self.load_tutorial_page(self.current_page_index)

    def create_welcome_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: 'Arial', sans-serif;
                    margin: 20px;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #f4f4f4;
                    color: #333;
                }
                h1 {
                    color: #026be4;
                    text-align: center;
                }
                p {
                    margin: 10px 0;
                }
                .button {
                    background-color: #4CAF50;
                    border: none;
                    color: white;
                    padding: 15px 32px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    font-size: 16px;
                    margin: 4px 2px;
                    cursor: pointer;
                    border-radius: 5px;
                }
            </style>
        </head>
        <body>
            <h1>Welcome to the TSTP:Duplicate Deleter Tutorial</h1>
            <p>In this interactive tutorial, you will learn how to use the key features of the TSTP:Duplicate Deleter application.</p>
            <p>Let's get started!</p>
        </body>
        </html>
        """

    def create_opening_files_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: 'Arial', sans-serif;
                    margin: 20px;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #f4f4f4;
                    color: #333;
                }
                h2 {
                    color: #0294a5;
                }
                p {
                    margin: 10px 0;
                }
                ol {
                    padding: 20px;
                }
                li {
                    margin: 10px 0;
                    font-size: 16px;
                }
                code {
                    font-family: 'Courier New', monospace;
                    background-color: #eaeaea;
                    padding: 2px 5px;
                    border-radius: 3px;
                }
                .button {
                    background-color: #4CAF50;
                    border: none;
                    color: white;
                    padding: 15px 32px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    font-size: 16px;
                    margin: 4px 2px;
                    cursor: pointer;
                    border-radius: 5px;
                }
            </style>
        </head>
        <body>
            <h2>Opening Files</h2>
            <p>To open a file, follow these steps:</p>
            <ol>
                <li>Click on the <code>File</code> menu in the top-left corner.</li>
                <li>Select the <code>Open</code> option.</li>
                <li>In the file dialog, navigate to the file you want to open and click <code>Open</code>.</li>
            </ol>
            <p>Each file you open will be displayed in a new tab.</p>
        </body>
        </html>
        """

    def create_editing_files_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: 'Arial', sans-serif;
                    margin: 20px;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #f4f4f4;
                    color: #333;
                }
                h2 {
                    color: #0294a5;
                }
                p {
                    margin: 10px 0;
                }
                .button {
                    background-color: #4CAF50;
                    border: none;
                    color: white;
                    padding: 15px 32px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    font-size: 16px;
                    margin: 4px 2px;
                    cursor: pointer;
                    border-radius: 5px;
                }
            </style>
        </head>
        <body>
            <h2>Editing Files</h2>
            <p>To edit the contents of a file, simply make changes directly in the text editor provided in each tab.</p>
            <p>You can use the standard keyboard shortcuts for common editing operations, such as:</p>
            <ul>
                <li><code>Ctrl+Z</code> to undo your changes</li>
                <li><code>Ctrl+Y</code> to redo your changes</li>
                <li><code>Ctrl+F</code> to search for text within the file</li>
                <li><code>Ctrl+H</code> to replace text within the file</li>
            </ul>
        </body>
        </html>
        """

    def create_saving_files_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: 'Arial', sans-serif;
                    margin: 20px;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #f4f4f4;
                    color: #333;
                }
                h2 {
                    color: #0294a5;
                }
                p {
                    margin: 10px 0;
                }
                ol {
                    padding: 20px;
                }
                li {
                    margin: 10px 0;
                    font-size: 16px;
                }
                code {
                    font-family: 'Courier New', monospace;
                    background-color: #eaeaea;
                    padding: 2px 5px;
                    border-radius: 3px;
                }
                .button {
                    background-color: #4CAF50;
                    border: none;
                    color: white;
                    padding: 15px 32px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    font-size: 16px;
                    margin: 4px 2px;
                    cursor: pointer;
                    border-radius: 5px;
                }
            </style>
        </head>
        <body>
            <h2>Saving Files</h2>
            <p>To save your changes, you can use the following options:</p>
            <ol>
                <li>Click on the <code>Save</code> button in the toolbar to save the current file.</li>
                <li>Go to the <code>File</code> menu and select <code>Save</code> to save the current file.</li>
                <li>To save a file with a new name or in a different location, go to the <code>File</code> menu and select <code>Save As</code>.</li>
            </ol>
        </body>
        </html>
        """

    def create_removing_duplicates_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: 'Arial', sans-serif;
                    margin: 20px;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #f4f4f4;
                    color: #333;
                }
                h2 {
                    color: #0294a5;
                }
                p {
                    margin: 10px 0;
                }
                ol {
                    padding: 20px;
                }
                li {
                    margin: 10px 0;
                    font-size: 16px;
                }
                code {
                    font-family: 'Courier New', monospace;
                    background-color: #eaeaea;
                    padding: 2px 5px;
                    border-radius: 3px;
                }
                .button {
                    background-color: #4CAF50;
                    border: none;
                    color: white;
                    padding: 15px 32px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    font-size: 16px;
                    margin: 4px 2px;
                    cursor: pointer;
                    border-radius: 5px;
                }
            </style>
        </head>
        <body>
            <h2>Removing Duplicates</h2>
            <p>To remove duplicate lines from your file, follow these steps:</p>
            <ol>
                <li>Go to the <code>Edit</code> menu and select the <code>Remove Duplicates</code> option.</li>
                <li>A dialog will appear, allowing you to choose which duplicate lines to remove. You can select the specific lines you want to remove or choose to remove all duplicates.</li>
                <li>Once you've made your selection, click <code>OK</code> to apply the changes.</li>
            </ol>
        </body>
        </html>
        """

    def create_sorting_and_merging_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: 'Arial', sans-serif;
                    margin: 20px;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #f4f4f4;
                    color: #333;
                }
                h2 {
                    color: #0294a5;
                }
                p {
                    margin: 10px 0;
                }
                ol {
                    padding: 20px;
                }
                li {
                    margin: 10px 0;
                    font-size: 16px;
                }
                code {
                    font-family: 'Courier New', monospace;
                    background-color: #eaeaea;
                    padding: 2px 5px;
                    border-radius: 3px;
                }
                .button {
                    background-color: #4CAF50;
                    border: none;
                    color: white;
                    padding: 15px 32px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    font-size: 16px;
                    margin: 4px 2px;
                    cursor: pointer;
                    border-radius: 5px;
                }
            </style>
        </head>
        <body>
            <h2>Sorting and Merging</h2>
            <p>The TSTP:Duplicate Deleter application also provides the following features:</p>
            <ol>
                <li>Sorting: You can sort the lines in your file in ascending or descending order. Go to the <code>Edit</code> menu and select either <code>Sort Ascending</code> or <code>Sort Descending</code>.</li>
                <li>Merging: If you have duplicate lines that you want to keep, you can merge them into a single line. Go to the <code>Edit</code> menu and select <code>Merge Duplicates</code>.</li>
            </ol>
        </body>
        </html>
        """
    def create_batch_operations_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: 'Arial', sans-serif;
                    margin: 20px;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #f4f4f4;
                    color: #333;
                }
                h2 {
                    color: #0294a5;
                }
                p {
                    margin: 10px 0;
                }
                ol {
                    padding: 20px;
                }
                li {
                    margin: 10px 0;
                    font-size: 16px;
                }
                code {
                    font-family: 'Courier New', monospace;
                    background-color: #eaeaea;
                    padding: 2px 5px;
                    border-radius: 3px;
                }
                .button {
                    background-color: #4CAF50;
                    border: none;
                    color: white;
                    padding: 15px 32px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    font-size: 16px;
                    margin: 4px 2px;
                    cursor: pointer;
                    border-radius: 5px;
                }
            </style>
        </head>
        <body>
            <h2>Batch Operations</h2>
            <p>The TSTP:Duplicate Deleter application also supports batch operations, allowing you to process multiple files at once.</p>
            <ol>
                <li>
                    <strong>Batch Duplicate Removal:</strong>
                    <ul>
                        <li>Go to the <code>Batch</code> menu and select <code>Batch Duplicate Removal</code>.</li>
                        <li>In the Batch Duplicate Removal window, click the <code>Add Files</code> button to select the files you want to process.</li>
                        <li>Once you've added the files, click the <code>Start Batch Removal</code> button to remove duplicates from all the files.</li>
                    </ul>
                </li>
                <li>
                    <strong>Batch File Merging:</strong>
                    <ul>
                        <li>Go to the <code>Batch</code> menu and select <code>Batch Merge Files</code>.</li>
                        <li>In the file dialog, select the files you want to merge.</li>
                        <li>The application will combine the contents of all the selected files into a single file, which you can then save.</li>
                    </ul>
                </li>
            </ol>
        </body>
        </html>
        """

    def create_additional_features_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: 'Arial', sans-serif;
                    margin: 20px;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #f4f4f4;
                    color: #333;
                }
                h2 {
                    color: #0294a5;
                }
                p {
                    margin: 10px 0;
                }
                ul {
                    padding: 20px;
                }
                li {
                    margin: 10px 0;
                    font-size: 16px;
                }
                code {
                    font-family: 'Courier New', monospace;
                    background-color: #eaeaea;
                    padding: 2px 5px;
                    border-radius: 3px;
                }
                .button {
                    background-color: #4CAF50;
                    border: none;
                    color: white;
                    padding: 15px 32px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    font-size: 16px;
                    margin: 4px 2px;
                    cursor: pointer;
                    border-radius: 5px;
                }
            </style>
        </head>
        <body>
            <h2>Additional Features</h2>
            <p>The TSTP:Duplicate Deleter application also includes the following additional features:</p>
            <ul>
                <li>
                    <strong>File Comparison:</strong>
                    <ul>
                        <li>You can compare the contents of two files side-by-side.</li>
                        <li>Go to the <code>File</code> menu and select <code>Compare Files</code>.</li>
                    </ul>
                </li>
                <li>
                    <strong>Dark Mode:</strong>
                    <ul>
                        <li>The application supports a dark mode theme to reduce eye strain.</li>
                        <li>Toggle dark mode by going to the <code>File</code> menu and selecting <code>Toggle Dark Mode</code>.</li>
                    </ul>
                </li>
            </ul>
            <button class="button previous-button">Previous</button>
            <button class="button start-button">Start Editing</button>
        </body>
        </html>
        """

    def load_tutorial_page(self, index):
        self.webView.setHtml(self.tutorial_pages[index])
        self.progress_bar.setValue(int((index + 1) / len(self.tutorial_pages) * 100))

    def go_to_previous_page(self):
        if self.current_page_index > 0:
            self.current_page_index -= 1
            self.load_tutorial_page(self.current_page_index)

    def go_to_next_page(self):
        if self.current_page_index < len(self.tutorial_pages) - 1:
            self.current_page_index += 1
            self.load_tutorial_page(self.current_page_index)      

################################ DUPLICATE REMOVER END ################################

################################ FILE SORTER START ################################

FileSorterdirectory_path = 'C:\\TSTP\\FileSorter'  

FileSorterdb = SqliteDatabase(os.path.join(FileSorterdirectory_path, 'file_sorter.db'))  

class FileSorterMainForm(QMainWindow):
    logs_updated_signal = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__()
        self.bg_theme = QWidget()
        self.setWindowFlags(Qt.Window)
        self.desktop_path = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop')
        folder_setup_window = FileSorterFolderSetupWindow(self.desktop_path, self)
        self.initUI()
        self.sorting_thread = None
        self.populate_logs()
        self.populate_rules()
        self.centerWindow()
        self.area.setWidget(self.bg_theme)
        self.logs_updated_signal.connect(self.populate_logs)
        self.app_icon = QIcon(resource_path('app_icon.ico'))

        if parent:
            self.setStyleSheet(parent.styleSheet())
            parent.themeChanged.connect(self.updateStyleSheet)

    def initUI(self):
        current_dir = os.path.dirname(os.path.realpath(__file__))
        icon_path = os.path.join(current_dir, 'app_icon.ico')
        self.setWindowIcon(QIcon(icon_path))
        self.setWindowTitle('TSTP:File Sorter')
        self.setGeometry(600, 600, 850, 600)
        self.statusbar = self.statusBar()
        self.statusLabel = QLabel("Ready")
        self.statusbar.addWidget(self.statusLabel)
        self.setupMenuBar()
        self.setupToolBar()
        self.setupCentralWidget()
        self.area = QScrollArea(self)
        self.area.setWidgetResizable(True)
        self.setCentralWidget(self.area)
        self.area.setWidget(self.bg_theme)

    def createTrayMenu(self):
        trayMenu = QMenu(self)

        openAction = QAction("Open", self)
        openAction.triggered.connect(self.show)

        toggleSortingAction = QAction("Toggle Sorting", self)
        toggleSortingAction.triggered.connect(self.toggle_sorting)

        runRulesNowAction = QAction("Run Rules Now", self)
        runRulesNowAction.triggered.connect(self.run_rules_now)

        addRuleAction = QAction("Add Rule", self)
        addRuleAction.triggered.connect(self.add_rule)

        removeRuleAction = QAction("Remove Rule", self)
        removeRuleAction.triggered.connect(self.remove_rule)

        editRuleAction = QAction("Edit Rule", self)
        editRuleAction.triggered.connect(self.edit_rule)

        toggleRuleAction = QAction("Toggle Rule", self)
        toggleRuleAction.triggered.connect(self.toggle_rule)

        setFolderAction = QAction("&Set Default Folder", self)
        setFolderAction.triggered.connect(self.set_default_folder)

        filePreviewAction = QAction("Create Defaults", self)
        filePreviewAction.triggered.connect(self.show_folder_setup_window)

        importLogsAction = QAction('&Import Logs', self)
        importLogsAction.triggered.connect(self.import_logs)

        importRulesAction = QAction('&Import Rules', self)
        importRulesAction.triggered.connect(self.import_rules)

        exportLogsAction = QAction('&Export Logs', self)
        exportLogsAction.triggered.connect(self.export_logs)

        exportRulesAction = QAction('&Export Rules', self)
        exportRulesAction.triggered.connect(self.export_rules)

        aboutAction = QAction('&About', self)
        aboutAction.triggered.connect(self.about_show)

        donateAction = QAction('&Donate', self)
        donateAction.triggered.connect(self.donate_show)

        tutorialAction = QAction('&Tutorial', self)
        tutorialAction.triggered.connect(self.tutorial_show)

        closeAction = QAction("Close", self)
        closeAction.triggered.connect(qApp.quit)

        trayMenu.addAction(openAction)
        trayMenu.addSeparator()
        trayMenu.addAction(toggleSortingAction)
        trayMenu.addAction(runRulesNowAction)
        trayMenu.addSeparator()
        trayMenu.addAction(addRuleAction)
        trayMenu.addAction(removeRuleAction)
        trayMenu.addAction(editRuleAction)
        trayMenu.addAction(toggleRuleAction)
        trayMenu.addSeparator()
        trayMenu.addAction(setFolderAction)
        trayMenu.addAction(filePreviewAction)
        trayMenu.addSeparator()
        trayMenu.addAction(importLogsAction)
        trayMenu.addAction(importRulesAction)
        trayMenu.addAction(exportLogsAction)
        trayMenu.addAction(exportRulesAction)
        trayMenu.addSeparator()
        trayMenu.addAction(aboutAction)
        trayMenu.addAction(donateAction)
        trayMenu.addAction(tutorialAction)
        trayMenu.addSeparator()
        trayMenu.addAction(closeAction)

        return trayMenu

    def updateStyleSheet(self, styleSheet):
        self.setStyleSheet(styleSheet)
        
    @pyqtSlot()
    def run_rules_now(self):
        if self.sorting_thread and self.sorting_thread.isRunning():
            self.sorting_thread.stop()
            while self.sorting_thread.isRunning():
                QApplication.processEvents()
        self.sorting_thread = FileSorterSortingThread(self.desktop_path, self.logs_updated_signal, run_once=True)
        self.sorting_thread.start()
        self.statusLabel.setText("Running rules once")
        logging.debug("Rules running once")

    def onTrayIconActivated(self, reason):
        if reason == QSystemTrayIcon.Trigger:
            self.show()
            
    def trayIconClicked(self, reason):
        if reason == QSystemTrayIcon.Trigger:
            self.show()
            
    def centerWindow(self):
        # Retrieve the screen resolution from the app
        screen = QDesktopWidget().screenGeometry()
        # Get the size of the QMainWindow
        size = self.geometry()
        # Calculate the center position
        self.move((screen.width() - size.width()) // 2, (screen.height() - size.height()) // 2)
            
    def closeEvent(self, event):
        event.ignore()
        self.hide()
        self.trayIcon.showMessage("TSTP:File Sorter", "File Sorter is running in System Tray.  Click icon to open program.", self.app_icon)
        
    def setupMenuBar(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu('&File')
        
        exit_action = QAction(QIcon(), '&Exit', self)
        exit_action.setShortcut('Ctrl+Q')
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        import_logs_action = QAction(QIcon(), '&Import Logs', self)
        import_logs_action.triggered.connect(self.import_logs)
        file_menu.addAction(import_logs_action)

        import_rules_action = QAction(QIcon(), '&Import Rules', self)
        import_rules_action.triggered.connect(self.import_rules)
        file_menu.addAction(import_rules_action)

        export_logs_action = QAction(QIcon(), '&Export Logs', self)
        export_logs_action.triggered.connect(self.export_logs)
        file_menu.addAction(export_logs_action)

        export_rules_action = QAction(QIcon(), '&Export Rules', self)
        export_rules_action.triggered.connect(self.export_rules)
        file_menu.addAction(export_rules_action)
        
        reportAction = QAction("File Movement Report", self)
        reportAction.triggered.connect(self.showReportWindow)
        file_menu.addAction(reportAction)
        
        help_menu = menubar.addMenu('&Help')
        
        about_action = QAction(QIcon(), '&About', self)
        about_action.triggered.connect(self.about_show)
        help_menu.addAction(about_action)

        donate_action = QAction(QIcon(), '&Donate', self)
        donate_action.triggered.connect(self.donate_show)
        help_menu.addAction(donate_action)

        help_menu.addAction(QAction('&Tutorial', self, triggered=self.tutorial_show))
        
    def showReportWindow(self):
        self.reportWindow = FileSorterReportWindow(self)
        self.reportWindow.show()

    def setupToolBar(self):
        self.toolbar = self.addToolBar('General')
        add_rule_action = QAction(QIcon(), 'Add Rule', self)
        add_rule_action.triggered.connect(self.add_rule)
        self.toolbar.addAction(add_rule_action)

        remove_rule_action = QAction(QIcon(), 'Remove Rule', self)
        remove_rule_action.triggered.connect(self.remove_rule)
        self.toolbar.addAction(remove_rule_action)

        edit_rule_action = QAction(QIcon(), 'Edit Rule', self)
        edit_rule_action.triggered.connect(self.edit_rule)
        self.toolbar.addAction(edit_rule_action)

        toggle_sorting_action = QAction(QIcon(), 'Toggle Sorting', self)
        toggle_sorting_action.triggered.connect(self.toggle_sorting)
        self.toolbar.addAction(toggle_sorting_action)
        
        run_rules_now_action = QAction(QIcon(), 'Run Rules Now', self)
        run_rules_now_action.triggered.connect(self.run_rules_now)
        self.toolbar.addAction(run_rules_now_action)

        toggle_rule_action = QAction(QIcon(), 'Toggle Rule', self)
        toggle_rule_action.triggered.connect(self.toggle_rule)
        self.toolbar.addAction(toggle_rule_action)

        setfolder_action = QAction(QIcon(), '&Set Default Folder', self)
        setfolder_action.triggered.connect(self.set_default_folder)
        self.toolbar.addAction(setfolder_action)

        file_preview_action = QAction(QIcon(), 'Create Defaults', self)
        file_preview_action.triggered.connect(self.show_folder_setup_window)
        self.toolbar.addAction(file_preview_action)

        file_types_action = QAction(QIcon(), 'Edit File Types', self)
        file_types_action.triggered.connect(self.manage_file_types)
        self.toolbar.addAction(file_types_action)
        
        # Theme selection combo box
        #themes_combo = QComboBox()
        #self.themes_combo = themes_combo
        #theme_names = fetch_theme_names()
        #self.themes_combo.addItems(theme_names)
        #self.themes_combo.currentTextChanged.connect(self.apply_theme)
        #self.toolbar.addWidget(themes_combo)

    def setupCentralWidget(self):
        central_widget_layout = QVBoxLayout(self.bg_theme)
        self.tab_widget = QTabWidget()
        self.rules_tab = QTableWidget()
        self.log_tab = QTableWidget()
        self.setupRulesTab()
        self.setupLogsTab()
        central_widget_layout.addWidget(self.tab_widget)

    def manage_file_types(self):
        dialog = FileSorterFileTypeDialog()
        if dialog.exec_() == QDialog.Accepted:
            self.updateFileTypes()

    def about_show(self):
        dialog = FileSorterAboutDialog(self)
        dialog.exec_()

    def donate_show(self):
        dialog = FileSorterDonateDialog(self)
        dialog.exec_()

    def tutorial_show(self):
        dialog = FileSorterTutorialDialog(self)
        dialog.exec_()
            
    def show_folder_setup_window(self):
        self.folder_setup_window = FileSorterFolderSetupWindow(os.path.expanduser("~/Desktop"), self)
        self.folder_setup_window.show()

    def setupLogsTab(self):
        self.log_tab.setRowCount(0)
        self.log_tab.setColumnCount(3)
        self.log_tab.setHorizontalHeaderLabels(['Timestamp', 'Title', 'Message'])
        self.log_tab.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        self.log_tab.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.log_tab.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)
        self.tab_widget.addTab(self.log_tab, "Log")
        self.tab_widget.setTabText(self.tab_widget.indexOf(self.log_tab), "Log")
        self.tab_widget.setStyleSheet("QTabBar::tab { width: 100px; }")

    def setupRulesTab(self):
        self.rules_tab.setRowCount(0)
        self.rules_tab.setColumnCount(5)
        self.rules_tab.setHorizontalHeaderLabels(['Keyword', 'File Type', 'Destination', 'Enabled', 'Priority'])
        self.rules_tab.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tab_widget.addTab(self.rules_tab, "Rules")
        self.tab_widget.setTabText(self.tab_widget.indexOf(self.rules_tab), "Rules")
        self.tab_widget.setStyleSheet("QTabBar::tab { width: 100px; }")

    def populate_rules(self):
        self.rules_tab.setRowCount(0)
        for rule in FileSorterSortingRule.select().order_by(FileSorterSortingRule.priority.asc()):
            row = self.rules_tab.rowCount()
            self.rules_tab.insertRow(row)
            # Set rule_id as data for each QTableWidgetItem
            item = QTableWidgetItem(rule.keyword)
            item.setData(Qt.UserRole, rule.id)
            self.rules_tab.setHorizontalHeaderLabels(['Keyword', 'File Type', 'Source', 'Destination', 'Enabled', 'Priority'])
            self.rules_tab.setItem(row, 0, item)
            self.rules_tab.setItem(row, 1, QTableWidgetItem(rule.file_type))
            self.rules_tab.setItem(row, 2, QTableWidgetItem(rule.source))
            self.rules_tab.setItem(row, 3, QTableWidgetItem(rule.destination))
            self.rules_tab.setItem(row, 4, QTableWidgetItem('Yes' if rule.enabled else 'No'))
            self.rules_tab.setItem(row, 5, QTableWidgetItem(str(rule.priority)))

    def populate_logs(self):
        self.log_tab.setRowCount(0)
        for log in FileSorterLog.select().order_by(FileSorterLog.timestamp.desc()):
            row = self.log_tab.rowCount()
            self.log_tab.insertRow(row)
            self.log_tab.setItem(row, 0, QTableWidgetItem(log.timestamp.strftime('%Y-%m-%d %H:%M:%S')))
            self.log_tab.setItem(row, 1, QTableWidgetItem(log.title))
            self.log_tab.setItem(row, 2, QTableWidgetItem(log.message))

    @pyqtSlot()
    def set_default_folder(self):
        current_path = FileSorterload_default_path()
        reply = QMessageBox.question(self, "Current Save Folder", 
                                     "Current Save Folder: " + current_path + "\n\nDo you want to select a new save folder?\n\nClick Yes to select a new save folder.\n\nClick No to continue using the one listed.",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            path = QFileDialog.getExistingDirectory(self, "Select Directory", current_path)
            if path:
                self.desktop_path = path
                self.statusLabel.setText(f'Default Path: {self.desktop_path}')
                FileSortersave_default_path(self.desktop_path)
                QMessageBox.information(self, "Current Save Folder", "Current Save Folder: " + FileSorterload_default_path())
        else:
            QMessageBox.information(self, "Info", "No changes made to the save folder.")      

    @pyqtSlot()
    def preview_file(self):
        selected_files = QFileDialog.getOpenFileNames(self, "Select File(s) to Preview", self.desktop_path)[0]
        if selected_files:
            for file_path in selected_files:
                previewDialog = FileSorterFilePreview(self)
                previewDialog.loadFile(file_path)
                previewDialog.exec_()

    @pyqtSlot()
    def import_logs(self):
        file_name, _ = QFileDialog.getOpenFileName(self, 'Import Logs', '.', 'JSON Files (*.json)')
        if file_name:
            with open(file_name, 'r') as file:
                logs = json.load(file)
                for log in logs:
                    FileSorterLog.create(timestamp=datetime.strptime(log['timestamp'], '%Y-%m-%d %H:%M:%S'),
                               title=log['title'], message=log['message'])
            self.populate_logs()
            QMessageBox.information(self, "Import Logs", "Logs imported successfully.")

    @pyqtSlot()
    def import_rules(self):
        file_name, _ = QFileDialog.getOpenFileName(self, 'Import Rules', '.', 'JSON Files (*.json)')
        if file_name:
            with open(file_name, 'r') as file:
                rules = json.load(file)
                for rule in rules:
                    FileSorterSortingRule.create(keyword=rule['keyword'], file_type=rule['file_type'],
                                       destination=rule['destination'], enabled=rule['enabled'],
                                       priority=rule['priority'])
            self.populate_rules()
            QMessageBox.information(self, "Import Rules", "Rules imported successfully.")

    @pyqtSlot()
    def export_logs(self):
        file_name, _ = QFileDialog.getSaveFileName(self, 'Export Logs', '.', 'JSON Files (*.json)')
        if file_name:
            with open(file_name, 'w') as file:
                logs = [log for log in FileSorterLog.select().dicts()]
                json.dump(logs, file, default=str)
            QMessageBox.information(self, "Export Logs", "Logs exported successfully.")

    @pyqtSlot()
    def export_rules(self):
        file_name, _ = QFileDialog.getSaveFileName(self, 'Export Rules', '.', 'JSON Files (*.json)')
        if file_name:
            with open(file_name, 'w') as file:
                rules = [rule for rule in FileSorterSortingRule.select().dicts()]
                json.dump(rules, file, default=str)
            QMessageBox.information(self, "Export Rules", "Rules exported successfully.")

    @pyqtSlot()
    def add_rule(self):
        dialog = FileSorterRuleDialog(parent=self)
        if dialog.exec_() == QDialog.Accepted:
            self.populate_rules()
            QMessageBox.information(self, "Add Rule", "Rule added successfully.")

    @pyqtSlot()
    def remove_rule(self):
        selected_items = self.rules_tab.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Error", "No rule selected.")
            return

        # Collect unique row indices of selected items to handle multiple selections correctly
        rows_to_delete = set(item.row() for item in selected_items)
    
        successful_deletions = 0
        for row in rows_to_delete:
            rule_id = self.rules_tab.item(row, 0).data(Qt.UserRole)
            if rule_id is not None:
                try:
                    rule = FileSorterSortingRule.get_by_id(rule_id)
                    rule.delete_instance()
                    successful_deletions += 1
                except FileSorterSortingRule.DoesNotExist:
                    # Optionally log this error or notify the user
                    continue

        if successful_deletions > 0:
            self.populate_rules()
            QMessageBox.information(self, "Success", f"{successful_deletions} rule(s) removed successfully.")
        else:
            QMessageBox.warning(self, "Error", "No valid rules were selected or rules do not exist.")

    @pyqtSlot()
    def edit_rule(self):
        selected_items = self.rules_tab.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Edit Rule", "No rule selected.")
            return
    
        row = self.rules_tab.currentRow()
        if row < 0:
            QMessageBox.warning(self, "Edit Rule", "Please select a rule to edit.")
            return
    
        rule_id = self.rules_tab.item(row, 0).data(Qt.UserRole)
        if rule_id is None:
            QMessageBox.warning(self, "Edit Rule", "Invalid rule ID.")
            return

        try:
            rule = FileSorterSortingRule.get_by_id(rule_id)
            dialog = FileSorterRuleDialog(rule, self)
            if dialog.exec_() == QDialog.Accepted:
                self.populate_rules()
                QMessageBox.information(self, "Edit Rule", "Rule updated successfully.")
        except FileSorterSortingRule.DoesNotExist:
            QMessageBox.warning(self, "Edit Rule", "Selected rule does not exist.")

    @pyqtSlot()
    def toggle_sorting(self):
        if self.sorting_thread and self.sorting_thread.isRunning():
            self.sorting_thread.stop()
            self.statusLabel.setText("Sorting stopped")
            logging.debug("Sorting Stopped")
        else:
            if self.sorting_thread is not None:
                self.sorting_thread.wait()  # Ensure the thread has finished
            self.sorting_thread = FileSorterSortingThread(self.desktop_path, self.logs_updated_signal, run_once=False)
            self.sorting_thread.start()
            self.statusLabel.setText("Sorting started")
            logging.debug("Sorting Started")

    @pyqtSlot()
    def toggle_rule(self):
        selected_items = self.rules_tab.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Toggle Rule", "No rule selected.")
            return
        
        # Assuming the rule ID is stored as UserRole in the first column of each row
        row = self.rules_tab.currentRow()
        rule_id = self.rules_tab.item(row, 0).data(Qt.UserRole)
        
        if rule_id is None:
            QMessageBox.warning(self, "Toggle Rule", "Invalid rule selected.")
            return
        
        try:
            rule = FileSorterSortingRule.get_by_id(rule_id)
            rule.enabled = not rule.enabled
            rule.save()
            self.populate_rules()
            status = "enabled" if rule.enabled else "disabled"
            QMessageBox.information(self, "Toggle Rule", f"Rule successfully {status}.")
        except FileSorterSortingRule.DoesNotExist:
            QMessageBox.warning(self, "Toggle Rule", "Selected rule does not exist.")

class FileSorterFilePreview(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle('File Preview')
        layout = QVBoxLayout(self)
        self.previewWidget = QTextEdit()
        self.previewWidget.setReadOnly(True)
        layout.addWidget(self.previewWidget)

    def loadFile(self, filePath):
        try:
            with open(filePath, 'r') as file:
                self.previewWidget.setText(file.read())
        except Exception as e:
            logging.error(f'Error loading file preview: {str(e)}')
            self.previewWidget.setText("Preview not available.")

class FileSorterSortingThread(QThread):

    def __init__(self, desktop_path, logs_updated_signal, run_once):
        super().__init__()
        self.desktop_path = desktop_path
        self.logs_updated_signal = logs_updated_signal
        self.run_once = run_once
        self.observer = None
        self.running = False

    def run(self):
        event_handler = FileSorterEventHandler(self.desktop_path, self.logs_updated_signal)
        if not self.run_once:
            self.observer = Observer()
            self.observer.schedule(event_handler, self.desktop_path, recursive=True)
            if debug_mode:
                print("Observer Started")
            self.observer.start()
        self.running = True
        while self.running:
            sleep(0.5)  # Adjust the timing as needed for your test
            if debug_mode_internal:
                print("Timer+")
            if self.run_once:
                event_handler.process_existing_files()
                self.running = False
            if not self.run_once:
                event_handler.check_buffer()
        if self.observer:
            self.observer.stop()
            self.observer.join()

    def check_status(self):
        # Implement logic to update UI with sorting status
        pass

    def stop(self):
        self.running = False
        self.wait()

class FileSorterEventHandler(FileSystemEventHandler):
    def __init__(self, desktop_path, logs_updated_signal):
        super().__init__()
        self.desktop_path = desktop_path
        self.logs_updated_signal = logs_updated_signal
        self.buffer = {}
        self.timer = QTimer()
        self.timer.timeout.connect(self.check_buffer)
        self.timer.start(1000)
        #self.signal = signal
        logging.debug("Timer started with interval 1000 ms.")
        logging.info("EventHandler initialized with desktop path: %s", self.desktop_path)

    def on_any_event(self, event):
        if debug_mode:
            print("on_any_event Triggered")
        if not event.is_directory:
            event_dir = os.path.dirname(event.src_path)
            if event_dir == self.desktop_path:
                self.buffer[event.src_path] = event.event_type
                logging.debug("Buffered event: %s for file: %s", event.event_type, event.src_path)
                self.logs_updated_signal.emit()
            else:
                logging.debug("Ignored event for file in subdirectory: %s", event.src_path)

    def process_existing_files(self):
        if debug_mode:
            print("process_existing_files Triggered")
        for item in os.listdir(self.desktop_path):
            item_path = os.path.join(self.desktop_path, item)
            if os.path.isfile(item_path):
                self.sort_file(item_path)

    def check_buffer(self):
        if debug_mode:
            print("check_buffer Triggered")
            logging.debug("Timer triggered. Checking buffer for events to process.")
        for src_path, event_type in list(self.buffer.items()):
            logging.debug("Found buffered event: %s for file: %s. Processing...", event_type, src_path)
            try:
                if event_type in ['created', 'moved', 'modified']:
                    logging.debug("Processing event: %s for file: %s", event_type, src_path)
                    self.sort_file(src_path)
                else:
                    logging.debug("Event type %s for file: %s is not handled.", event_type, src_path)
                del self.buffer[src_path]
            except Exception as e:
                logging.error("Error processing event for file %s: %s", src_path, str(e))
                
    def sort_file(self, src_path):
        if debug_mode:
            print("sort_file Triggered")
        logging.info("Attempting to sort file: %s", src_path)
        file_name = os.path.basename(src_path)
        file_extension = os.path.splitext(file_name)[1].lower().lstrip('.')
        file_size = os.path.getsize(src_path)  # Get the size of the file
        FileSorterLog.create(timestamp=datetime.now(), title="File Sorted", message=f"File {src_path} sorted.", file_size=file_size)  # Log the action with file size
        rules = FileSorterSortingRule.select().where(FileSorterSortingRule.enabled == True).order_by(FileSorterSortingRule.priority.asc())

        for rule in rules:
            keyword, file_type, source, destination = rule.keyword, rule.file_type, rule.source, rule.destination
            keyword_match = False
    
            # Check if keyword is "*", meaning match all files
            if keyword == '*':
                keyword_match = True
            else:
                # Use the keyword as a regex pattern if it's not "*"
                try:
                    keyword_match = re.search(keyword, file_name, re.IGNORECASE) is not None
                except re.error as e:
                    log_message = f"Regex error with keyword {keyword} for file {src_path}: {e}"
                    logging.error(log_message)
                    self.create_log_entry(log_message)  # Create a log entry
                    continue  # Skip this rule and continue with the next one

            file_type_match = (file_type == file_extension or file_type == 'all')
    
            source_match = (not source) or (os.path.dirname(src_path) == source)
            if keyword_match and file_type_match and source_match:
                if not os.path.exists(destination):
                    try:
                        os.makedirs(destination)
                        log_message = f"Created destination directory: {destination}"
                        logging.info(log_message)
                        self.create_log_entry(log_message)  # Create a log entry
                    except Exception as e:
                        log_message = f"Failed to create destination directory: {destination}. Error: {e}"
                        logging.error(log_message)
                        self.create_log_entry(log_message)  # Create a log entry
                        return
    
                destination_path = os.path.join(destination, file_name)
                # Handling existing destination file
                if os.path.exists(destination_path):
                    base, extension = os.path.splitext(destination_path)
                    i = 1
                    while os.path.exists(f"{base}_{i}{extension}"):
                        i += 1
                    destination_path = f"{base}_{i}{extension}"
    
                try:
                    shutil.move(src_path, destination_path)
                    log_message = f"Successfully moved {src_path} to {destination_path}"
                    logging.info(log_message)
                    self.create_log_entry(log_message)  # Create a log entry
                    break  # Successfully moved, no need to check other rules
                except Exception as e:
                    log_message = f"Failed to move {src_path} to {destination_path}. Error: {e}"
                    logging.error(log_message)
                    self.create_log_entry(log_message)  # Create a log entry
                    break

    def create_log_entry(self, message):
        FileSorterLog.create(timestamp=datetime.now(), title="File Sorting Activity", message=message)
        self.logs_updated_signal.emit()

class FileSorterRuleDialog(QDialog):
    def __init__(self, rule=None, parent=None):
        super().__init__(parent)
        self.rule = rule
        self.setWindowTitle('Add/Edit Rule')
        layout = QVBoxLayout(self)
        current_dir = os.path.dirname(os.path.realpath(__file__))
        icon_path = os.path.join(current_dir, 'app_icon.ico')
        self.setWindowIcon(QIcon(icon_path))
        self.setWindowTitle('TSTP:FS - Add/Edit Rule')

        layout.addWidget(QLabel('Keyword (* for all files):'))
        self.keywordInput = QLineEdit()
        self.keywordInput.setText(rule.keyword if rule else '')
        layout.addWidget(self.keywordInput)

        layout.addWidget(QLabel('File Type:'))
        self.fileTypeInput = QComboBox()
        self.fileTypeInput.setEditable(True)
        self.loadFileTypes()
        if rule:
            index = self.fileTypeInput.findText(rule.file_type, Qt.MatchFixedString)
            if index >= 0:
                self.fileTypeInput.setCurrentIndex(index)
        layout.addWidget(self.fileTypeInput)
        
        layout.addWidget(QLabel('Source:'))
        self.sourceInput = QLineEdit()
        self.sourceInput.setText(rule.source if rule else '')
        layout.addWidget(self.sourceInput)

        layout.addWidget(QLabel('Destination:'))
        self.destinationInput = QLineEdit()
        self.destinationInput.setText(rule.destination if rule else '')
        selectDestinationBtn = QPushButton('Select Folder')
        selectDestinationBtn.clicked.connect(self.selectDestination)
        destLayout = QHBoxLayout()
        destLayout.addWidget(self.destinationInput)
        destLayout.addWidget(selectDestinationBtn)
        layout.addLayout(destLayout)

        layout.addWidget(QLabel('Priority:'))
        self.priorityInput = QComboBox()
        self.priorityInput.addItems([str(i) for i in range(1, 11)])
        if rule:
            self.priorityInput.setCurrentIndex(rule.priority - 1)
        layout.addWidget(self.priorityInput)

        saveBtn = QPushButton('Save')
        saveBtn.clicked.connect(self.saveRule)
        layout.addWidget(saveBtn)

    def loadFileTypes(self):
        self.fileTypeInput.clear()
        for fileType in FileSorterFileTypes.select():
            self.fileTypeInput.addItem(fileType.file_type)

    def selectDestination(self):
        destination = QFileDialog.getExistingDirectory(self, "Select Destination Folder")
        if destination:
            self.destinationInput.setText(destination)

    def saveRule(self):
        keyword = self.keywordInput.text()
        file_type = self.fileTypeInput.currentText()
        destination = self.destinationInput.text()
        priority = self.priorityInput.currentText()
        source = self.sourceInput.text()
        if self.rule:
            self.rule.keyword = keyword
            self.rule.source = source
            self.rule.file_type = file_type
            self.rule.destination = destination
            self.rule.priority = int(priority)
            self.rule.save()
        else:
            FileSorterSortingRule.create(keyword=keyword, file_type=file_type, source=source, destination=destination, priority=int(priority))
        self.accept()
        
class FileSorterFileTypeDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        current_dir = os.path.dirname(os.path.realpath(__file__))
        icon_path = os.path.join(current_dir, 'app_icon.ico')
        self.setWindowIcon(QIcon(icon_path))
        self.setWindowTitle('TSTP:FS - Edit File Types')
        layout = QVBoxLayout(self)

        self.fileTypeList = QTableWidget()
        self.fileTypeList.setColumnCount(1)
        self.fileTypeList.setHorizontalHeaderLabels(['File Type'])
        self.fileTypeList.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.populateFileTypes()
        layout.addWidget(self.fileTypeList)

        addBtn = QPushButton('Add')
        addBtn.clicked.connect(self.addFileType)
        layout.addWidget(addBtn)

        removeBtn = QPushButton('Remove Selected')
        removeBtn.clicked.connect(self.removeSelectedFileType)
        layout.addWidget(removeBtn)

    def populateFileTypes(self):
        self.fileTypeList.setRowCount(0)
        for fileType in FileSorterFileTypes.select():
            rowPosition = self.fileTypeList.rowCount()
            self.fileTypeList.insertRow(rowPosition)
            self.fileTypeList.setItem(rowPosition, 0, QTableWidgetItem(fileType.file_type))

    def addFileType(self):
        text, ok = QInputDialog.getText(self, 'Add File Type', 'File type:')
        if ok and text:
            FileSorterFileTypes.create(file_type=text)
            self.populateFileTypes()

    def removeSelectedFileType(self):
        selectedItems = self.fileTypeList.selectedItems()
        if not selectedItems:
            QMessageBox.warning(self, "Error", "No file type selected.")
            return

        successful_deletions = 0
        # Track already processed file types to avoid attempting to delete duplicates
        processed_file_types = set()

        for item in selectedItems:
            selectedType = item.text()
            if selectedType in processed_file_types:
                continue  # Skip if this file type has already been processed

            try:
                fileType = FileSorterFileTypes.get(FileSorterFileTypes.file_type == selectedType)
                fileType.delete_instance()
                processed_file_types.add(selectedType)
                successful_deletions += 1
            except FileSorterFileTypes.DoesNotExist:
                # Optionally log this error or notify the user
                continue

        if successful_deletions > 0:
            self.populateFileTypes()
            QMessageBox.information(self, "Success", f"{successful_deletions} file type(s) removed successfully.")
        else:
            QMessageBox.warning(self, "Error", "Selected file types do not exist.")
            
class FileSorterFolderSetupWindow(QWidget):
    def __init__(self, desktop_path, main_form, parent=None):
        super().__init__(parent)
        self.desktop_path = FileSorterload_default_path()
        self.main_form = main_form
        desktop_path = FileSorterload_default_path()
        self.initUI()

    def initUI(self):
        current_dir = os.path.dirname(os.path.realpath(__file__))
        icon_path = os.path.join(current_dir, 'app_icon.ico')
        self.setWindowIcon(QIcon(icon_path))
        self.setWindowTitle('TSTP:FS - Folder Setup Guide')
        self.setGeometry(100, 100, 600, 400)
        self.layout = QVBoxLayout()

        self.tabs = QTabWidget()
        self.tabs.addTab(self.createBasicTab(), "Basic Setup")
        self.tabs.addTab(self.createAdvancedTab(), "Advanced Setup")

        self.layout.addWidget(self.tabs)
        self.setLayout(self.layout)

    def createBasicTab(self):
        tab = QWidget()
        layout = QVBoxLayout()

        header = QLabel("<h2>Basic Setup</h2>")
        header.setAlignment(Qt.AlignCenter)
        layout.addWidget(header)

        description = QTextEdit()
        description.setReadOnly(True)
        description.setHtml("""
        <p><b>Description:</b> The Basic Setup is crafted for users who value simplicity and ease of use over detailed categorization. By creating a series of general-purpose folders directly on your desktop, this setup aims to streamline your file organization process without overwhelming you with too many categories or subfolders. Here is how the Basic Setup can transform your digital workspace:</p>

        <ul>
            <li><b>Documents:</b> A single, accessible location for all your textual content, including reports, articles, and notes, regardless of their format (e.g., PDF, DOCX, TXT).</li>
            <li><b>Images:</b> Keeps your digital memories and graphical content in one place, making it easy to find screenshots, photos, and design files.</li>
            <li><b>Videos:</b> Consolidates all your video files, from personal recordings to downloaded content, ensuring they're just a click away.</li>
            <li><b>Music and Audio Files:</b> Gathers your audio files, including music, podcasts, and recordings, into a dedicated folder for quick access.</li>
            <li><b>Downloads:</b> A specific folder to house all your downloaded files, helping you keep track of recent downloads without cluttering your desktop.</li>
        </ul>

        <p>This setup is not just about creating folders; it is about providing a hassle-free way to manage your files. By sorting files into these broad categories based on their file type, the Basic Setup eliminates the need for intricate sorting rules or subfolders, making it perfect for everyday use. Whether you're dealing with work documents, personal photos, or entertainment files, you'll know exactly where to find them.</p>

        <p>Moreover, the Basic Setup is designed to be flexible. As your needs grow or change, you can easily transition to the Advanced Setup for more granular control over your file organization. But for many users, the simplicity of the Basic Setup offers the perfect balance between order and accessibility, turning the desktop into a tidy, functional space that supports your digital lifestyle.</p>

        <p>Choose the Basic Setup for a straightforward, efficient way to keep your files organized, making your digital space as comfortable and user-friendly as possible.</p>
        """)

        layout.addWidget(description)

        startBtn = QPushButton('Start Basic Setup')
        startBtn.clicked.connect(lambda: self.create_default_folders('Basic'))
        layout.addWidget(startBtn)

        tab.setLayout(layout)
        return tab

    def createAdvancedTab(self):
        tab = QWidget()
        layout = QVBoxLayout()

        header = QLabel("<h2>Advanced Setup</h2>")
        header.setAlignment(Qt.AlignCenter)
        layout.addWidget(header)

        description = QTextEdit()
        description.setReadOnly(True)
        description.setHtml("""
        <p><b>Description:</b> The Advanced Setup is designed for users who seek an exhaustive and detailed approach to file organization. This setup not only creates a top-level folder structure but also dives deeper by establishing a hierarchy of subfolders tailored to specific file types and categories. This meticulous approach facilitates an organized, efficient, and easily navigable file system.</p>

        <p>Here's what the Advanced Setup entails:</p>

        <ul>
            <li><b>Document Management:</b> Differentiates between various document formats such as PDF, DOCX, TXT, and more. Each format is allocated its own subfolder under the 'Documents' main folder, making it effortless to locate specific document types.</li>
            <li><b>Image Categorization:</b> Organizes images by file type (JPEG, PNG, GIF, etc.), but also offers the option to sort by source or content, such as 'Screenshots', 'Photos', and 'Graphics', helping you quickly find the image you need.</li>
            <li><b>Video and Audio Separation:</b> Sorts videos and audios into their respective main folders with subcategories for each format (MP4, MOV for videos; MP3, WAV for audio). Additionally, it can organize content by genre, series, or project, providing a highly customized media library.</li>
            <li><b>Programming and Development:</b> For developers, this setup includes dedicated folders for programming languages (Python, JavaScript, etc.), project files, and development tools. Subfolders can be customized to separate source code, documentation, and binaries.</li>
            <li><b>Archives and Compressed Files:</b> Automatically sorts ZIP, RAR, and other archive formats into a dedicated 'Archives' folder, with options to organize further based on project or source.</li>
            <li><b>Specialized Content:</b> Creates specialized folders for content such as eBooks, Spreadsheets, Presentations, and 3D Models. Each category receives detailed subfolder treatment based on file types and further classifications like genre, project, or author.</li>
        </ul>

        <p>Beyond these categorizations, the Advanced Setup introduces the concept of <i>smart sorting</i>, where files can be organized based on metadata (like creation date, author, or project) and custom rules that you define. This level of customization ensures that every file is exactly where you expect it to be, streamlining your workflow and maximizing productivity.</p>

        <p>The setup process is intuitive and guided, allowing you to specify preferences and adjust the categorization to match your exact needs. With the Advanced Setup, managing a large volume of files becomes significantly more manageable, turning potential chaos into a well-ordered digital environment.</p>

        <p>Embrace the Advanced Setup for a transformative file organization experience that adapts to your lifestyle, enhances accessibility, and secures your digital assets in an orderly structure, ready for immediate retrieval.</p>

        """)
        layout.addWidget(description)

        startBtn = QPushButton('Start Advanced Setup')
        startBtn.clicked.connect(lambda: self.create_default_folders('Advanced'))
        layout.addWidget(startBtn)

        tab.setLayout(layout)
        return tab
        
    def get_sort_folder_name(self):
        text, ok = QInputDialog.getText(self, 'Sort Folder Name', 'Enter the folder name for sorting:')
        if ok and text:
            return text
        else:
            return "SORT"

    def create_default_folders(self, level):
        basic_folders = ['Documents', 'Images', 'Videos', 'Audios', 'Archives', 'Programming', 'eBooks', 'Spreadsheets', 'Presentations']
        advanced_folders = {
            'Documents': [
                'txt', 'docx', 'pdf', 'odt', 'rtf', 'md', 'doc', 'xlsb', 'xlsm', 'log', 'ini', 'conf'
            ],
            'Images': [
                'jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'tif', 'tiff', 'psd', 'ai', 'eps', 'heic', 'ico', 'webp'
            ],
            'Videos': [
                'mp4', 'mov', 'wmv', 'flv', 'avi', 'mkv', 'mpeg', 'mpg', 'm4v', 'webm'
            ],
            'Audios': [
                'mp3', 'wav', 'aac', 'flac', 'ogg', 'm4a', 'wma', 'aiff', 'alac'
            ],
            'Archives': [
                'zip', 'rar', '7z', 'tar', 'gz', 'bz2', 'xz', 'iso', 'jar'
            ],
            'Programming': [
                'py', 'js', 'java', 'cpp', 'c', 'cs', 'php', 'rb', 'swift', 'go',
                'ts', 'json', 'xml', 'yml', 'yaml', 'sh', 'bat', 'ps1', 'tsx', 'jsx', 'scss', 'less',
                'html', 'css'
            ],
            'eBooks': [
                'epub', 'mobi', 'azw', 'azw3', 'fb2', 'ibook', 'pdf', 'cbr', 'cbz'
            ],
            'Spreadsheets': [
                'xls', 'xlsx', 'ods', 'csv', 'slk'
            ],
            'Presentations': [
                'ppt', 'pptx', 'odp', 'key', 'pps'
            ],
            'Design & CAD': [
                'dwg', 'dxf', 'skp', '3ds', 'max', 'blend', 'obj', 'fbx', 'fig', 'sketch'
            ],
            '3D Models': [
                'stl', 'obj', 'dae', '3dm'
            ],
            'Vector Graphics': [
                'svg', 'eps', 'ai'
            ],
            'Scripts & Executables': [
                'exe', 'msi', 'bin', 'cmd', 'pl'
            ],
            'Databases': [
                'sql', 'db', 'mdb', 'accdb', 'sqlite', 'dbf'
            ],
            'Financial': [
                'qfx', 'qif', 'ofx'
            ],
            'Scientific & Engineering': [
                'mat', 'sci', 'ipynb', 'rdata', 'r', 'm', 'c', 'cpp', 'java'
            ],
            'Emails': [
                'eml', 'msg', 'pst', 'ost', 'mbox'
            ],
            'Backups': [
                'bak', 'tmp', 'old', 'snapshot', 'gho', 'tib'
            ],
        }

        # Check for duplicates
        #all_file_types = []
        #for category, file_types in advanced_folders.items():
            #all_file_types.extend(file_types)

        # Identify any duplicates
        #duplicates = [ftype for ftype in set(all_file_types) if all_file_types.count(ftype) > 1]

        # Reporting
        #if duplicates:
            #print("Duplicate file types found:", duplicates)
        #else:
            #print("No duplicates found. Each file type is uniquely categorized.")

        sort_folder_name = self.get_sort_folder_name()
        sort_folder = os.path.join(self.desktop_path, sort_folder_name)
        folder_exists = os.path.exists(sort_folder)

        if folder_exists:
            user_choice = QMessageBox.question(self, "Setup Incomplete", "Folders are already setup. Do you want to add rules now?", QMessageBox.Yes | QMessageBox.No)
            if user_choice == QMessageBox.No:
                return

        if not folder_exists:
            os.makedirs(sort_folder, exist_ok=True)
            for folder in basic_folders:
                os.makedirs(os.path.join(sort_folder, folder), exist_ok=True)

        for folder, extensions in advanced_folders.items():
            path = os.path.join(sort_folder, folder)
            if level == 'Basic' and folder in basic_folders or level == 'Advanced':
                if not os.path.exists(path):
                    os.makedirs(path, exist_ok=True)
                for ext in extensions:
                    _, created = FileSorterFileTypes.get_or_create(file_type=ext)
                    if created or level == 'Advanced':
                        destination_path = path if level == 'Basic' else os.path.join(path, ext)
                        if level == 'Advanced' and not os.path.exists(destination_path):
                            os.makedirs(destination_path, exist_ok=True)
                        FileSorterSortingRule.get_or_create(keyword='*', file_type=ext, destination=destination_path, enabled=True)

        QMessageBox.information(self, "Setup Complete", "Setup complete with all specified folders, subfolders, file types, and rules.")
        self.main_form.populate_rules()
        self.main_form.populate_logs()

    def add_rules_for_folder(self, level, path, extensions):
        for ext in extensions:
            ext_path = path if level == 'Basic' else os.path.join(path, ext)
            if level == 'Advanced' and not os.path.exists(ext_path):
                os.makedirs(ext_path, exist_ok=True)
            _, created = FileSorterFileTypes.get_or_create(file_type=ext)
            if created:
                FileSorterSortingRule.get_or_create(keyword='*', file_type=ext, destination=ext_path, enabled=True)
                
class FileSorterReportWindow(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle('Ultimate File Movement Report')
        self.setGeometry(100, 100, 1200, 700)  # Further increased dimensions for better visibility
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)

        self.searchField = QLineEdit(self)
        self.searchField.setPlaceholderText("Search by file name or destination...")
        self.searchField.textChanged.connect(self.filterReportData)
        layout.addWidget(self.searchField)
        
        self.reportTable = QTableWidget()
        self.reportTable.setColumnCount(5)  # Further expanded to include 'Action Type'
        self.reportTable.setHorizontalHeaderLabels(['Date', 'File Name', 'File Size', 'Destination Path', 'Action Type'])
        self.reportTable.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.reportTable.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.reportTable.setEditTriggers(QAbstractItemView.NoEditTriggers)
        
        self.fullReportData = []
        self.loadReportData()
        
        layout.addWidget(self.reportTable)

    def loadReportData(self):
        self.fullReportData.clear()  # Clear previous data
        conn = sqlite3.connect(FileSorterDB_PATH)
        cursor = conn.cursor()
        query = """
        SELECT DATE(timestamp), title, message, file_size
        FROM Log
        ORDER BY DATE(timestamp) DESC, timestamp DESC
        """
        cursor.execute(query)
        self.fullReportData = cursor.fetchall()

        self.populateReportTable(self.fullReportData)

    def populateReportTable(self, data):
        self.reportTable.setRowCount(0)
        for row in data:
            date, file_name, message, file_size = row
            destination_path = message.split(" to ")[-1] if 'moved' in message else "N/A"
            action_type = "Move" if 'moved' in message else "Other"

            rowNum = self.reportTable.rowCount()
            self.reportTable.insertRow(rowNum)
            self.reportTable.setItem(rowNum, 0, QTableWidgetItem(date))
            self.reportTable.setItem(rowNum, 1, QTableWidgetItem(file_name))
            self.reportTable.setItem(rowNum, 2, QTableWidgetItem(self.formatFileSize(file_size)))
            self.reportTable.setItem(rowNum, 3, QTableWidgetItem(destination_path))
            self.reportTable.setItem(rowNum, 4, QTableWidgetItem(action_type))

        self.reportTable.cellDoubleClicked.connect(self.openFileLocation)

    def filterReportData(self, searchText):
        filteredData = [row for row in self.fullReportData if searchText.lower() in row[1].lower() or searchText.lower() in row[2].lower()]
        self.populateReportTable(filteredData)

    def formatFileSize(self, size):
        # Enhanced file size formatting to support larger files more gracefully
        for unit in ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']:
            if size < 1024.0:
                return f"{size:.2f} {unit}"
            size /= 1024.0
        return f"{size:.2f} YB"

    def openFileLocation(self, row, column):
        if column == 3 and 'N/A' not in self.reportTable.item(row, column).text():
            destination_path = self.reportTable.item(row, column).data(Qt.UserRole)
            QDesktopServices.openUrl(QUrl.fromLocalFile(os.path.dirname(destination_path)))
            
class FileSorterAboutDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.initUI()

    def initUI(self):
        current_dir = os.path.dirname(os.path.realpath(__file__))
        icon_path = os.path.join(current_dir, 'app_icon.ico')
        self.setWindowIcon(QIcon(icon_path))
        self.setWindowTitle('TSTP:FS - About Us')
        self.setGeometry(100, 100, 500, 400)  # Expanded for more content
        self.setFixedSize(self.size())
        self.setWindowIcon(QIcon(':/icons/about_icon.ico'))

        layout = QVBoxLayout()

        # Dialog Styling
        self.setStyleSheet("""
            QLabel {
                font-size: 10pt;
                margin-bottom: 10px;
            }
            QLabel#title {
                font-size: 14pt;
                font-weight: bold;
            }
            QLabel#link {
                text-decoration: underline;
                color: blue;
            }
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-size: 10pt;
                padding: 10px;
                border: none;
                cursor: pointer;
                margin-top: 20px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QVBoxLayout {
                margin: 20px;
            }
        """)

        # About Content
        title = QLabel("About TSTP:File Sorter")
        title.setObjectName("title")
        layout.addWidget(title)

        aboutText = QLabel("""
<p>The Solutions To Problems, LLC (TSTP) is at the forefront of technological innovation, dedicated to enhancing 
productivity and simplifying the digital lifestyle of businesses and individuals alike. Our goal is to develop 
solutions that not only meet current needs but also anticipate future challenges.</p>
        
<p>With TSTP:File Sorter, we aim to revolutionize the way you organize your digital files, bringing order to chaos 
with just a few clicks. We believe in creating intuitive, powerful tools that improve efficiency and joy in the 
digital workspace.</p>
        
<p>To learn more about our mission and explore other innovative solutions:</p>
        """)
        aboutText.setWordWrap(True)
        layout.addWidget(aboutText)

        # Additional Links
        websiteLink = QLabel('<a href="https://tstp.xyz" id="link">Visit Our Website</a>')
        websiteLink.setOpenExternalLinks(True)
        layout.addWidget(websiteLink)

        linkedInLink = QLabel('<a href="https://www.linkedin.com/company/thesolutions-toproblems/" id="link">Follow Us on LinkedIn</a>')
        linkedInLink.setOpenExternalLinks(True)
        layout.addWidget(linkedInLink)

        emailSupport = QLabel('For support, email us at: <a href="mailto:support@tstp.xyz" id="link">support@tstp.xyz</a>')
        emailSupport.setOpenExternalLinks(True)
        layout.addWidget(emailSupport)

        closeButton = QPushButton("Close")
        closeButton.clicked.connect(self.close)
        layout.addWidget(closeButton)

        self.setLayout(layout)

class FileSorterDonateDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.initUI()

    def initUI(self):
        current_dir = os.path.dirname(os.path.realpath(__file__))
        icon_path = os.path.join(current_dir, 'app_icon.ico')
        self.setWindowIcon(QIcon(icon_path))
        self.setWindowTitle('TSTP:FS - Donate')
        self.setGeometry(100, 100, 450, 400)  # Adjusted for expanded content
        self.setFixedSize(self.size())
        self.setWindowIcon(QIcon(':/icons/app_icon.ico'))

        layout = QVBoxLayout()

        # Enhanced Styling for a More Web-Like Appearance
        self.setStyleSheet("""
            QLabel {
                font-size: 10pt;
                margin-bottom: 5px;
            }
            QPushButton {
                font-size: 12pt;
                background-color: #4CAF50;
                color: white;
                border-radius: 5px;
                padding: 10px 20px;
                margin-top: 15px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            a {
                text-decoration: none;
                color: #007BFF;
            }
        """)

        # Introduction Text
        introText = QLabel("""
        <h2>Join Us in Shaping the Future</h2>
        <p>At <b>The Solutions To Problems, LLC</b>, we're on a mission to streamline technology for everyday users. Our team is dedicated to developing innovative software solutions, like TSTP:File Sorter, that make digital organization effortless and intuitive.</p>
        """)
        introText.setWordWrap(True)
        layout.addWidget(introText)

        # Donation Text Expanded
        donateText = QLabel("""
        <h3>Your Support Makes a Difference</h3>
        <p>Your generosity fuels our innovation engine. Donations go directly into research and development, empowering us to enhance existing tools and create new solutions that tackle the complexities of digital life.</p>
        <p>With your support, we can:</p>
        <ul>
            <li>Accelerate the development of new features and tools.</li>
            <li>Expand our outreach to help more individuals and businesses.</li>
            <li>Invest in cutting-edge technology and research.</li>
        </ul>
        <p>Every contribution, no matter the size, plays a crucial role in our journey.</p>
        """)
        donateText.setWordWrap(True)
        layout.addWidget(donateText)

        # Donation Link
        linkLabel = QLabel('<a href="https://tstp.xyz/donate">Donate Now</a>')
        linkLabel.setOpenExternalLinks(True)
        layout.addWidget(linkLabel)

        # Additional Links for Engagement
        linksText = QLabel("""
        <p>Discover more ways to support and engage with us:</p>
        <a href="https://www.linkedin.com/company/thesolutions-toproblems/">LinkedIn</a> | 
        <a href="https://tstp.xyz">Our Website</a> | 
        <a href="mailto:support@tstp.xyz">Email Support</a>
        """)
        linksText.setOpenExternalLinks(True)
        layout.addWidget(linksText)

        # Close Button
        closeButton = QPushButton("Close")
        closeButton.clicked.connect(self.close)
        layout.addWidget(closeButton)

        self.setLayout(layout)

class FileSorterTutorialDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        current_dir = os.path.dirname(os.path.realpath(__file__))
        icon_path = os.path.join(current_dir, 'app_icon.ico')
        self.setWindowIcon(QIcon(icon_path))
        self.setWindowTitle('TSTP:FS - Tutorial')
        self.setGeometry(100, 100, 400, 400)  # Larger size for detailed content
        self.setFixedSize(500, 500)
        layout = QVBoxLayout()

        self.tabWidget = QTabWidget()
        self.setupTabs()

        closeButton = QPushButton("Close")
        closeButton.clicked.connect(self.close)
        layout.addWidget(self.tabWidget)
        layout.addWidget(closeButton)

        self.setLayout(layout)

    def setupTabs(self):
        self.addTutorialTab("Introduction", self.introductionContent())
        self.addTutorialTab("Sorting Rules", self.sortingRulesContent())
        self.addTutorialTab("Logs", self.logsContent())
        self.addTutorialTab("Import/Export", self.importExportContent())
        self.addTutorialTab("Customization", self.customizationContent())
        self.addTutorialTab("Utilities", self.utilitiesContent())

    def addTutorialTab(self, title, content):
        tab = QWidget()
        layout = QVBoxLayout()

        # Create a QLabel with wordWrap enabled
        label = QLabel(content)
        label.setWordWrap(True)
    
        # Add QLabel to the layout
        layout.addWidget(label)

        # Optionally, for very long texts, you might want to add a QScrollArea
        scrollArea = QScrollArea()
        scrollArea.setWidgetResizable(True)  # Allow the contained widget to expand
        scrollWidget = QWidget()  # This widget will contain your layout
        scrollWidget.setLayout(layout)
        scrollArea.setWidget(scrollWidget)  # Set the widget that contains your layout

        # Set the layout of the tab to contain the scroll area
        tabLayout = QVBoxLayout()
        tabLayout.addWidget(scrollArea)
        tab.setLayout(tabLayout)

        self.tabWidget.addTab(tab, title)

    def introductionContent(self):
        return """
        <div style='text-align: center;'>
            <h2>Welcome to the File Sorter Application</h2>
            <p>This application is designed to simplify your digital life by automatically organizing your files 
            according to customizable rules. With an intuitive interface, you can easily navigate through the 
            application, access a wide range of functionalities directly from the toolbar, and personalize your 
            experience using the options provided in the menu bar.</p>
            <p>Whether you're dealing with a cluttered Desktop or just need a more efficient way to handle your 
            files, this guide will walk you through everything you need to know to get started.</p>
        </div>
    """


    # Implement similar methods for other tabs, filling in the content string with detailed explanations
    def sortingRulesContent(self):
        return """
        <div style='text-align: center;'>
            <h2>Setting Up Sorting Rules</h2>
            <p>Sorting rules are at the heart of the File Sorter Application. They tell the application how to 
            categorize and move your files based on names, types, or other criteria you define.</p>
        
            <h3>Creating a New Rule</h3>
            <p>To create a new rule, navigate to the 'Rules' tab in the main interface. Click on the 'Add Rule' 
            button in the toolbar. A dialog will appear, prompting you to specify the criteria for the rule, such 
            as the keyword or file type to look for and the destination folder where matching files should be moved.</p>
        
            <h3>Editing an Existing Rule</h3>
            <p>If you need to modify a rule, simply select it from the list in the 'Rules' tab and click 'Edit Rule.' 
            Make the necessary adjustments in the dialog that appears and save your changes.</p>
        
            <h3>Deleting a Rule</h3>
            <p>To delete a rule, select it and choose 'Remove Rule.' Confirm your decision when prompted.</p>
        
            <p>With these simple steps, you can automate the organization of your files, making your digital workspace 
            cleaner and more efficient.</p>
        </div>
        """

    def logsContent(self):
        return """
        <div style='text-align: center;'>
            <h2>Monitoring Activity with Logs</h2>
            <p>The 'Logs' tab provides a detailed record of all sorting actions performed by the application. Here, 
            you can review the timestamp, title, and message associated with each action, giving you insight into 
            the application's operations and the outcomes of your sorting rules.</p>
        
            <p>This feature is particularly useful for troubleshooting and ensuring that your files are being organized 
            as intended. If you notice any unexpected behavior, the logs can help you pinpoint what went wrong.</p>
        </div>
        """

    def importExportContent(self):
        return """
        <div style='text-align: center;'>
            <h2>Importing and Exporting Rules and Logs</h2>
            <p>For added convenience and data portability, the File Sorter Application allows you to import and export 
            your sorting rules and logs in JSON format.</p>
        
            <h3>Importing</h3>
            <p>To import rules or logs, go to the 'File' menu and select 'Import Rules' or 'Import Logs.' Then, navigate 
            to the JSON file you wish to import. This functionality enables you to quickly set up the application on a 
            new machine or recover your settings.</p>
        
            <h3>Exporting</h3>
            <p>Similarly, you can export your current rules and logs by selecting 'Export Rules' or 'Export Logs' from 
            the 'File' menu. This can be useful for backing up your configuration or sharing it with others.</p>
        </div>
        """

    def customizationContent(self):
        return """
        <div style='text-align: center;'>
            <h2>Customizing the Application's Theme</h2>
            <p>The File Sorter Application supports theme customization, allowing you to change the look and feel of the 
            interface to suit your preferences. To change the theme, use the theme selection combo box located in the 
            toolbar. Choose from a variety of themes, including 'Dark Mode,' 'Light Mode,' and more.</p>
        
            <p>Switching themes can improve visibility and reduce eye strain, making your experience more enjoyable and 
            personalized.</p>
        </div>
        """

    def utilitiesContent(self):
        return """
        <div style='text-align: center;'>
            <h2>Utility Features</h2>
            <p>Beyond file sorting, the File Sorter Application offers additional utility features to enhance your 
            user experience.</p>
        
            <h3>Create Defaults</h3>
            <p>'Create Defaults' is a feature designed to help you quickly set up a default sorting structure. It creates 
            a set of commonly used folders such as 'Documents,' 'Images,' 'Videos,' etc., on your Desktop or in a specified 
            location. This function is accessible from the toolbar and can be a great starting point for organizing your 
            files.</p>
        
            <h3>Setting the Default Folder</h3>
            <p>You can specify a default folder for the application to monitor and sort files from. To set or change the 
            default folder, select '&Set Default Folder' from the toolbar and choose the desired directory.</p>
        
            <p>These utilities, along with the core sorting functionalities, make the File Sorter Application a powerful 
            tool for managing your digital files.</p>
        </div>
        """

class FileSorterFileSorterPlugin:
    def on_file_detected(self, file_path):
        pass

    def on_sort_rule_applied(self, file_path, rule):
        pass
    
class FileSorterSortingRule(Model):
    keyword = CharField()
    file_type = CharField()
    source = CharField(default='')  # Add this line
    destination = CharField()
    enabled = BooleanField(default=True)
    priority = IntegerField(default=0)

    class Meta:
        database = FileSorterdb

class FileSorterLog(Model):
    timestamp = DateTimeField(default=datetime.now)
    title = CharField()
    message = TextField()
    file_size = IntegerField(default=0)  # Added file_size field with default value

    class Meta:
        database = FileSorterdb

class FileSorterFileTypes(Model):
    file_type = CharField(unique=True)

    class Meta:
        database = FileSorterdb

def FileSorterload_sorter_plugins():
    sorter_plugins = []
    # Ensure the directory exists
    if not os.path.exists(FileSorterPLUGIN_DIRECTORY):
        print(f"Plugin directory {FileSorterPLUGIN_DIRECTORY} does not exist.")
        return sorter_plugins
    
    # List and import plugins from the fixed directory
    for plugin_file in os.listdir(FileSorterPLUGIN_DIRECTORY):
        if plugin_file.endswith('.py') and not plugin_file.startswith('__'):
            # Construct the full path to the plugin file
            full_path = os.path.join(FileSorterPLUGIN_DIRECTORY, plugin_file)
            # Importing the plugin module by file path
            name = os.path.splitext(plugin_file)[0]
            module_spec = importlib.util.spec_from_file_location(name, full_path)
            module = importlib.util.module_from_spec(module_spec)
            module_spec.loader.exec_module(module)
            
            # Check each attribute to see if it's a FileSorterPlugin subclass
            for attribute_name in dir(module):
                attribute = getattr(module, attribute_name)
                if isinstance(attribute, type) and issubclass(attribute, FileSorterFileSorterPlugin) and attribute is not FileSorterFileSorterPlugin:
                    sorter_plugins.append(attribute())
    return sorter_plugins

def FileSorterhex_to_rgb(hex_color):
    # Convert hex to RGB
    hex_color = hex_color.strip('#')
    lv = len(hex_color)
    return tuple(int(hex_color[i:i + lv // 3], 16) for i in range(0, lv, lv // 3))

def FileSorterluminance(color):
    # Calculate the luminance of a color to decide if it's light or dark
    import re
    hex_color = re.search(r'#([0-9a-fA-F]{6})', color)
    if hex_color:
        rgb_hex = hex_color.groups()[0]
        rgb = tuple(int(rgb_hex[i:i+2], 16) / 255 for i in (0, 2, 4))
        return 0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]
    return 0

def FileSorterget_contrasting_color(hex_color):
    # Simple algorithm to determine contrasting color (black or white)
    r, g, b = FileSorterhex_to_rgb(hex_color)
    return '#FFFFFF' if (r * 0.299 + g * 0.587 + b * 0.114) < 186 else '#000000'

def FileSortercalculate_luminance(color):
    # Calculate the luminance of an RGB tuple.
    r, g, b = color
    return 0.2126 * r + 0.7152 * g + 0.0722 * b

def FileSorteris_dark_theme(CSSContent):
    # Try to find a background-color attribute in the CSS content.
    bg_color_search = re.search(r'background-color\s*:\s*([^;]+)', CSSContent, re.IGNORECASE)
    if bg_color_search:
        bg_color = bg_color_search.group(1).strip()
        # Check for hex color (e.g., #FFFFFF or #FFF).
        if re.match(r'^#(?:[0-9a-fA-F]{3}){1,2}$', bg_color):
            rgb = FileSorterhex_to_rgb(bg_color)
        # Insert other parsing logic here if you use other color formats (like rgba, hsl, etc.).
        else:
            # If the color is not in a recognizable format, default to light theme.
            return False
        
        # Calculate the luminance of the color to determine if it's dark.
        return FileSortercalculate_luminance(rgb) < 128
    
    # Default to light theme if no background-color found.
    return False

def FileSorteris_light_theme(hex_color: str) -> bool:
    # Function to check if the theme is considered 'light' based on the hex color of the background.
    rgb = int(hex_color[1:], 16)
    r, g, b = (rgb >> 16) & 0xff, (rgb >> 8) & 0xff, rgb & 0xff
    luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255
    return luminance > 0.5

def FileSortercontrast_ratio(lum1, lum2):
    # Calculate contrast ratio between two luminances.
    # The formula is (L1 + 0.05) / (L2 + 0.05) where L1 is the luminance of the lighter color
    # and L2 is the luminance of the darker color.
    lighter = max(lum1, lum2)
    darker = min(lum1, lum2)
    return (lighter + 0.05) / (darker + 0.05)

def FileSorteris_contrast_acceptable(foreground_hex, background_hex):
    fg_lum = FileSortercalculate_luminance_from_hex(foreground_hex)
    bg_lum = FileSortercalculate_luminance_from_hex(background_hex)
    ratio = FileSortercontrast_ratio(fg_lum, bg_lum)
    # WCAG AA level for normal text requires a contrast ratio of at least 4.5:1
    return ratio >= 4.5

def FileSortercalculate_luminance_from_hex(hex_color):
    rgb = FileSorterhex_to_rgb(hex_color)
    return 0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]

def FileSorterinvert_color(hex_color):
    """Inverts a hex color."""
    # Check if hex_color is valid
    if hex_color.startswith('#') and len(hex_color) == 7:
        # Remove the '#' symbol
        hex_color = hex_color[1:]
        # Invert the color
        inverted_color = ''.join(['{:02X}'.format(255 - int(hex_color[i:i+2], 16)) for i in range(0, 6, 2)])
        return f'#{inverted_color}'
    else:
        # Return a default contrast color if input is invalid
        return '#FFFFFF' if hex_color.lower() in ['#000', '#000000', 'black', ''] else '#000000'
    
def FileSortersave_default_path(path):
    directory_path = 'C:\\TSTP\\FileSorter'
    file_path = os.path.join(directory_path, 'default_path.txt')
    try:
        with open(file_path, 'w') as file:
            file.write(path)
    except Exception as e:
        print(f"Error saving default path: {e}")
        
def FileSorterload_default_path():
    directory_path = 'C:\\TSTP\\FileSorter'
    os.makedirs(directory_path, exist_ok=True)  # Ensure the directory exists
    file_path = os.path.join(directory_path, 'default_path.txt')

    if not os.path.isfile(file_path):
        # If the file doesn't exist, save the default path to it
        FileSortersave_default_path(os.path.join(os.path.expanduser('~'), 'Desktop'))

    try:
        with open(file_path, 'r') as file:
            return file.read().strip()
    except Exception as e:
        print(f"Error loading default path: {e}")
        return os.path.join(os.path.expanduser('~'), 'Desktop')
    
debug_mode_internal = False

FileSorterfile_path = os.path.join(FileSorterdirectory_path, 'default_path.txt')

FileSorternew_file_path = None

# Create the directory if it does not exist
os.makedirs(FileSorterdirectory_path, exist_ok=True)

# Directory path for plugins
FileSorterplugin_directory_path = 'C:\\TSTP\\FileSorter\\Plugins'

# Create the plugin directory if it does not exist
os.makedirs(FileSorterplugin_directory_path, exist_ok=True)

# Load the default path at the start of the program
FileSorterdesktop_path = FileSorterload_default_path()
FileSorterload_default_path()
       
FileSorterPLUGIN_DIRECTORY = r"C:\TSTP\FileSorter\Plugins"
    
FileSorterdb.connect()
FileSorterdb.create_tables([FileSorterSortingRule, FileSorterLog, FileSorterFileTypes], safe=True)

################################ FILE SORTER END ################################

################################ USER SCANNER START #############################
class UserScannerExportDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Export User List")
        self.layout = QVBoxLayout(self)
        
        self.select_all_button = QPushButton("Select All", self)
        self.select_all_button.clicked.connect(self.select_all_options)
        self.layout.addWidget(self.select_all_button)
        
        self.options = {
            "Username": QCheckBox("Username"),
            "Full Name": QCheckBox("Full Name"),
            "Comment": QCheckBox("Comment"),
            "User ID": QCheckBox("User ID"),
            "Primary Group ID": QCheckBox("Primary Group ID"),
            "Last Logon": QCheckBox("Last Logon"),
            "Last Logoff": QCheckBox("Last Logoff"),
            "Password Last Set": QCheckBox("Password Last Set"),
            "Account Expires": QCheckBox("Account Expires"),
            "Number of Logons": QCheckBox("Number of Logons"),
            "Bad Password Count": QCheckBox("Bad Password Count"),
            "Home Directory": QCheckBox("Home Directory"),
            "Script Path": QCheckBox("Script Path"),
            "Profile Path": QCheckBox("Profile Path"),
        }
        
        for option in self.options.values():
            self.layout.addWidget(option)
        
        self.buttons = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel, self)
        self.layout.addWidget(self.buttons)
        
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
    
    def get_selected_options(self):
        return [key for key, checkbox in self.options.items() if checkbox.isChecked()]

    def select_all_options(self):
        for checkbox in self.options.values():
            checkbox.setChecked(True)

class UserScanner(QMainWindow):
    def __init__(self, parent=None):
        super().__init__()
        self.setWindowFlags(Qt.Window)
        self.initUI()
        
        # Apply the same stylesheet as the main program and connect to theme changes
        if parent:
            self.setStyleSheet(parent.styleSheet())
            parent.themeChanged.connect(self.updateStyleSheet)

    def updateStyleSheet(self, styleSheet):
        self.setStyleSheet(styleSheet)        
    
    def initUI(self):
        self.setWindowTitle("User Scanner")
        self.setGeometry(100, 100, 600, 400)
        
        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)
        
        self.layout = QVBoxLayout(self.central_widget)
        
        # Menu
        self.menu_bar = self.menuBar()
        self.file_menu = self.menu_bar.addMenu("File")
        self.help_menu = self.menu_bar.addMenu("Help")
        
        self.exit_action = QAction("Exit", self)
        self.exit_action.triggered.connect(self.close)
        self.file_menu.addAction(self.exit_action)
        
        self.tutorial_action = QAction("Tutorial", self)
        self.tutorial_action.triggered.connect(self.show_tutorial)
        self.help_menu.addAction(self.tutorial_action)
        
        # Scan Users Button
        self.scan_button = QPushButton("Scan Users", self)
        self.scan_button.clicked.connect(self.scan_users)
        self.layout.addWidget(self.scan_button)
        
        # User List
        self.user_list = QListWidget(self)
        self.layout.addWidget(self.user_list)
        
        # Export User List Button
        self.export_button = QPushButton("Export User List", self)
        self.export_button.clicked.connect(self.open_export_dialog)
        self.layout.addWidget(self.export_button)
        
        # Progress Bar
        self.progress_bar = QProgressBar(self)
        self.progress_bar.setVisible(False)
        self.layout.addWidget(self.progress_bar)
        
        # Status Bar
        self.status_bar = self.statusBar()
        
    def show_tutorial(self):
        tutorial_window = UserScannerTutorialWindow(self)
        tutorial_window.exec_()
    
    def scan_users(self):
        try:
            self.progress_bar.setVisible(True)
            self.progress_bar.setValue(0)
            self.status_bar.showMessage("Scanning users...")
            
            users = self.get_users()
            
            self.user_list.clear()
            for user in users:
                self.user_list.addItem(user)
            
            self.progress_bar.setValue(100)
            self.status_bar.showMessage("User scan complete.", 5000)
        except Exception as e:
            logging.error(f"Error scanning users: {e}")
            logging.debug(traceback.format_exc())
            self.show_error("An error occurred while scanning users.")
    
    def get_users(self):
        try:
            import win32net
            import win32netcon

            self.progress_bar.setValue(20)
            users, _, _ = win32net.NetUserEnum(None, 0, win32netcon.FILTER_NORMAL_ACCOUNT)
            user_list = [user['name'] for user in users]
            self.progress_bar.setValue(60)
            logging.info(f"Found users: {user_list}")
            return user_list
        except ImportError as e:
            logging.error(f"Error importing modules: {e}")
            logging.debug(traceback.format_exc())
            self.progress_bar.setValue(0)
            raise RuntimeError("Required modules are not installed.") from e
        except Exception as e:
            logging.error(f"Error getting users: {e}")
            logging.debug(traceback.format_exc())
            self.progress_bar.setValue(0)
            raise RuntimeError("Failed to retrieve user information.") from e

    def open_export_dialog(self):
        try:
            dialog = UserScannerExportDialog(self)
            if dialog.exec_():
                selected_options = dialog.get_selected_options()
                self.export_user_list(selected_options)
        except Exception as e:
            logging.error(f"Error opening export dialog: {e}")
            logging.debug(traceback.format_exc())
            self.show_error("An error occurred while opening the export dialog.")
    
    def export_user_list(self, options):
        try:
            file_dialog = QFileDialog(self)
            save_path, _ = file_dialog.getSaveFileName(self, "Save File", "", "JSON Files (*.json);;CSV Files (*.csv);;Text Files (*.txt)")
        
            if save_path:
                users_info = self.get_users_info(options)
                if save_path.endswith(".json"):
                    self.save_as_json(save_path, users_info)
                elif save_path.endswith(".csv"):
                    self.save_as_csv(save_path, users_info)
                else:
                    self.save_as_txt(save_path, users_info)
            
                QMessageBox.information(self, "Success", "User list exported successfully.")
                self.status_bar.showMessage("User list exported successfully.", 5000)
        except Exception as e:
            logging.error(f"Error exporting user list: {e}")
            logging.debug(traceback.format_exc())
            self.show_error("An error occurred while exporting the user list.")
    
    def get_users_info(self, options):
        try:
            import win32net
            import win32netcon

            users = self.get_users()
            users_info = []

            for username in users:
                user_info = {}
                user_details = win32net.NetUserGetInfo(None, username, 2)
            
                if "Username" in options:
                    user_info["Username"] = username
                if "Full Name" in options:
                    user_info["Full Name"] = user_details.get("full_name", "")
                if "Comment" in options:
                    user_info["Comment"] = user_details.get("comment", "")
                if "User ID" in options:
                    user_info["User ID"] = user_details.get("user_id", "")
                if "Primary Group ID" in options:
                    user_info["Primary Group ID"] = user_details.get("primary_group_id", "")
                if "Last Logon" in options:
                    user_info["Last Logon"] = datetime.fromtimestamp(user_details.get("last_logon", 0)).strftime('%Y-%m-%d %H:%M:%S')
                if "Last Logoff" in options:
                    user_info["Last Logoff"] = datetime.fromtimestamp(user_details.get("last_logoff", 0)).strftime('%Y-%m-%d %H:%M:%S')
                if "Password Last Set" in options:
                    user_info["Password Last Set"] = datetime.fromtimestamp(user_details.get("password_age", 0)).strftime('%Y-%m-%d %H:%M:%S')
                if "Account Expires" in options:
                    expires = user_details.get("acct_expires", 0)
                    user_info["Account Expires"] = "Never" if expires == win32netcon.TIMEQ_FOREVER else datetime.fromtimestamp(expires).strftime('%Y-%m-%d %H:%M:%S')
                if "Number of Logons" in options:
                    user_info["Number of Logons"] = user_details.get("num_logons", 0)
                if "Bad Password Count" in options:
                    user_info["Bad Password Count"] = user_details.get("bad_pw_count", 0)
                if "Home Directory" in options:
                    user_info["Home Directory"] = user_details.get("home_dir", "")
                if "Script Path" in options:
                    user_info["Script Path"] = user_details.get("script_path", "")
                if "Profile Path" in options:
                    user_info["Profile Path"] = user_details.get("profile", "")

                users_info.append(user_info)

            logging.info(f"Users info: {users_info}")
            return users_info
        except ImportError as e:
            logging.error(f"Error importing modules: {e}")
            logging.debug(traceback.format_exc())
            raise RuntimeError("Required modules are not installed.") from e
        except Exception as e:
            logging.error(f"Error getting users info: {e}")
            logging.debug(traceback.format_exc())
            raise RuntimeError("Failed to retrieve user details.") from e
        
    def save_as_json(self, path, data):
        try:
            with open(path, 'w') as file:
                json.dump(data, file, indent=4)
            logging.info(f"Data saved as JSON: {path}")
        except Exception as e:
            logging.error(f"Error saving as JSON: {e}")
            logging.debug(traceback.format_exc())
            raise RuntimeError("Failed to save as JSON.") from e
    
    def save_as_csv(self, path, data):
        try:
            keys = data[0].keys()
            with open(path, 'w', newline='') as file:
                dict_writer = csv.DictWriter(file, keys)
                dict_writer.writeheader()
                dict_writer.writerows(data)
            logging.info(f"Data saved as CSV: {path}")
        except Exception as e:
            logging.error(f"Error saving as CSV: {e}")
            logging.debug(traceback.format_exc())
            raise RuntimeError("Failed to save as CSV.") from e
    
    def save_as_txt(self, path, data):
        try:
            with open(path, 'w') as file:
                for entry in data:
                    file.write(f"{entry}\n")
            logging.info(f"Data saved as TXT: {path}")
        except Exception as e:
            logging.error(f"Error saving as TXT: {e}")
            logging.debug(traceback.format_exc())
            raise RuntimeError("Failed to save as TXT.") from e

    def show_error(self, message):
        QMessageBox.critical(self, "Error", message)
        self.status_bar.showMessage(message, 5000)
        
class UserScannerTutorialWindow(QDialog):
    def __init__(self, parent=None):
        super(UserScannerTutorialWindow, self).__init__(parent)
        self.setWindowTitle("Interactive Tutorial")
        self.setGeometry(100, 100, 800, 600)
        self.setWindowModality(Qt.ApplicationModal)

        self.layout = QVBoxLayout()

        self.webView = QWebEngineView()
        self.layout.addWidget(self.webView)

        self.navigation_layout = QHBoxLayout()
        self.back_button = QPushButton("Previous")
        self.back_button.clicked.connect(self.go_to_previous_page)
        self.navigation_layout.addWidget(self.back_button)

        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.go_to_next_page)
        self.navigation_layout.addWidget(self.next_button)

        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.navigation_layout.addWidget(self.progress_bar)

        self.start_button = QPushButton("Start Using App")
        self.start_button.clicked.connect(self.close)
        self.navigation_layout.addWidget(self.start_button)

        self.layout.addLayout(self.navigation_layout)
        self.setLayout(self.layout)

        self.current_page_index = 0
        self.tutorial_pages = [
            self.create_welcome_page(),
            self.create_scanning_users_page(),
            self.create_selecting_users_page(),
            self.create_exporting_users_page(),
        ]

        self.load_tutorial_page(self.current_page_index)

    def create_welcome_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: Arial, sans-serif;
                    margin: 20px;
                    padding: 20px;
                    background-color: #f4f4f4;
                }
                h1 {
                    color: #333;
                    text-align: center;
                }
                p {
                    color: #666;
                    margin: 0 0 10px;
                }
                .content {
                    max-width: 800px;
                    margin: 0 auto;
                    padding: 20px;
                    background-color: #fff;
                    border-radius: 8px;
                    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
                }
            </style>
        </head>
        <body>
            <div class="content">
                <h1>Welcome to the Interactive Tutorial</h1>
                <p>Welcome to the User Scanner application! This tool allows you to scan, view, and export user information from your system.</p>
                <p>In this tutorial, you will learn how to:</p>
                <ul>
                    <li>Scan for users on your system</li>
                    <li>Select users to view detailed information</li>
                    <li>Export user information in various formats</li>
                </ul>
                <p>Let's get started by exploring the features of this application.</p>
            </div>
        </body>
        </html>
        """

    def create_scanning_users_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: Arial, sans-serif;
                    margin: 20px;
                    padding: 20px;
                    background-color: #f4f4f4;
                }
                h2 {
                    color: #333;
                    text-align: center;
                }
                p {
                    color: #666;
                    margin: 0 0 10px;
                }
                .content {
                    max-width: 800px;
                    margin: 0 auto;
                    padding: 20px;
                    background-color: #fff;
                    border-radius: 8px;
                    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
                }
            </style>
        </head>
        <body>
            <div class="content">
                <h2>Step 1: Scanning Users</h2>
                <p>To begin using the User Scanner application, start by scanning for users on your system.</p>
                <p>Follow these steps:</p>
                <ol>
                    <li>Click the <strong>Scan Users</strong> button on the main interface.</li>
                    <li>The application will search for all user accounts on your system and display them in a list.</li>
                    <li>Wait for the scan to complete. The progress bar will indicate the scan status.</li>
                </ol>
                <p>Once the scan is complete, you will see a list of all users found on your system.</p>
            </div>
        </body>
        </html>
        """

    def create_selecting_users_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: Arial, sans-serif;
                    margin: 20px;
                    padding: 20px;
                    background-color: #f4f4f4;
                }
                h2 {
                    color: #333;
                    text-align: center;
                }
                p {
                    color: #666;
                    margin: 0 0 10px;
                }
                .content {
                    max-width: 800px;
                    margin: 0 auto;
                    padding: 20px;
                    background-color: #fff;
                    border-radius: 8px;
                    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
                }
            </style>
        </head>
        <body>
            <div class="content">
                <h2>Step 2: Selecting Users</h2>
                <p>After scanning, you can select the users you want to view or export.</p>
                <p>Follow these steps:</p>
                <ol>
                    <li>Click on a user in the list to select them. You can select multiple users by holding the <strong>Ctrl</strong> key (or <strong>Cmd</strong> key on Mac) while clicking.</li>
                    <li>The selected users will be highlighted in the list.</li>
                    <li>If you need to deselect a user, simply click on them again while holding the <strong>Ctrl</strong> key.</li>
                </ol>
                <p>Once you have selected the users, you can proceed to export their information.</p>
            </div>
        </body>
        </html>
        """

    def create_exporting_users_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {
                    font-family: Arial, sans-serif;
                    margin: 20px;
                    padding: 20px;
                    background-color: #f4f4f4;
                }
                h2 {
                    color: #333;
                    text-align: center;
                }
                p {
                    color: #666;
                    margin: 0 0 10px;
                }
                .content {
                    max-width: 800px;
                    margin: 0 auto;
                    padding: 20px;
                    background-color: #fff;
                    border-radius: 8px;
                    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
                }
            </style>
        </head>
        <body>
            <div class="content">
                <h2>Step 3: Exporting User List</h2>
                <p>After selecting the users you want to export, follow these steps to save their information:</p>
                <ol>
                    <li>Click the <strong>Export User List</strong> button.</li>
                    <li>An export dialog will appear with several options for the information to include in the export. Select the information you want to include by checking the appropriate checkboxes.</li>
                    <li>Click <strong>Save</strong> to proceed. A file dialog will open, allowing you to choose the location and format for the export file (JSON, CSV, or TXT).</li>
                    <li>Enter a file name and select the desired format, then click <strong>Save</strong>.</li>
                </ol>
                <p>The selected user information will be exported and saved to the specified location.</p>
            </div>
        </body>
        </html>
        """

    def load_tutorial_page(self, index):
        self.webView.setHtml(self.tutorial_pages[index])
        self.progress_bar.setValue(int((index + 1) / len(self.tutorial_pages) * 100))

    def go_to_previous_page(self):
        if self.current_page_index > 0:
            self.current_page_index -= 1
            self.load_tutorial_page(self.current_page_index)

    def go_to_next_page(self):
        if self.current_page_index < len(self.tutorial_pages) - 1:
            self.current_page_index += 1
            self.load_tutorial_page(self.current_page_index)
################################ USER SCANNER END ###############################

################################ PARSEING TOOL START ############################
class ParsingToolMainWindow(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowFlags(Qt.Window | Qt.CustomizeWindowHint | Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint | Qt.WindowCloseButtonHint)
        self.setWindowTitle("Parsing Tool - TSTP:Omni Omega")
        try:
            self.initUI()
        except Exception as e:
            QMessageBox.critical(self, "Initialization Error", f"Error initializing UI: {str(e)}")

    def initUI(self):
        try:
            self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))
            self.setWindowTitle('TSTP:Parsing Tool')
            self.setGeometry(100, 100, 1200, 800)

            # Initialize System Tray
            # self.initSystemTray()

            # Central widget and main layout
            centralWidget = QWidget()
            self.setCentralWidget(centralWidget)
            mainLayout = QHBoxLayout(centralWidget)

            # Left side (folder structure)
            leftLayout = QVBoxLayout()
            self.folderSearchBar = QLineEdit()
            self.folderSearchBar.setPlaceholderText("Search folders...")
            self.folderSearchBar.textChanged.connect(self.filterFolderTree)
            self.folderView = QTreeView()
            self.folderModel = QFileSystemModel()
            self.folderModel.setRootPath(QDir.rootPath())
            self.folderModel.setFilter(QDir.NoDotAndDotDot | QDir.AllDirs)
            self.folderView.setModel(self.folderModel)
            self.folderView.setRootIndex(self.folderModel.index(QDir.rootPath()))
            self.folderView.clicked.connect(self.onFolderClicked)
            self.folderView.setHeaderHidden(True)

            leftLayout.addWidget(self.folderSearchBar)
            leftLayout.addWidget(self.folderView)

            # Middle (file list and text area)
            middleLayout = QVBoxLayout()

            self.searchBar = QLineEdit()
            self.searchBar.setPlaceholderText("Search files...")
            self.searchBar.textChanged.connect(self.filterFileList)
            self.fileTypeFilter = QComboBox()
            self.fileTypeFilter.addItem("All Files")
            self.fileTypeFilter.addItem(".txt")
            self.fileTypeFilter.addItem(".log")
            self.fileTypeFilter.addItem(".xml")
            self.fileTypeFilter.currentTextChanged.connect(self.filterFileList)

            self.fileList = QListWidget()
            self.fileList.setSelectionMode(QListWidget.MultiSelection)
            self.fileList.itemSelectionChanged.connect(self.onFileSelectionChanged)

            self.textArea = QTextEdit()
            self.textArea.setReadOnly(True)

            self.toggleSelectButton = QPushButton('Select All Files')
            self.toggleSelectButton.setCheckable(True)
            self.toggleSelectButton.clicked.connect(self.toggleSelectFiles)

            buttonLayout = QHBoxLayout()
            self.selectFolderButton = QPushButton('Select Folder')
            self.selectFolderButton.clicked.connect(self.selectFolder)
            self.parseButton = QPushButton('Parse')
            self.parseButton.clicked.connect(self.parseSelectedFolder)
            self.saveButton = QPushButton('Save')
            self.saveButton.clicked.connect(self.saveToFile)
            self.copyButton = QPushButton('Copy to Clipboard')
            self.copyButton.clicked.connect(self.copyToClipboard)
            self.copyStructureButton = QPushButton('Copy File Structure')
            self.copyStructureButton.clicked.connect(self.copyFileStructure)
            buttonLayout.addWidget(self.selectFolderButton)
            buttonLayout.addWidget(self.parseButton)
            buttonLayout.addWidget(self.saveButton)
            buttonLayout.addWidget(self.copyButton)
            buttonLayout.addWidget(self.copyStructureButton)
            buttonLayout.addWidget(self.toggleSelectButton)

            middleLayout.addWidget(self.searchBar)
            middleLayout.addWidget(self.fileTypeFilter)
            middleLayout.addWidget(self.fileList)
            middleLayout.addWidget(self.textArea)
            middleLayout.addLayout(buttonLayout)

            # Add layouts to main layout
            splitter = QSplitter()
            folderWidget = QWidget()
            folderWidget.setLayout(leftLayout)
            splitter.addWidget(folderWidget)
            middleWidget = QWidget()
            middleWidget.setLayout(middleLayout)
            splitter.addWidget(middleWidget)

            mainLayout.addWidget(splitter)

            # Menu
            menuBar = self.menuBar()
            helpMenu = menuBar.addMenu('Help')

            aboutAction = QAction('About', self)
            aboutAction.triggered.connect(self.showAbout)
            helpMenu.addAction(aboutAction)

            donateAction = QAction('Donate', self)
            donateAction.triggered.connect(self.showDonate)
            helpMenu.addAction(donateAction)

            tutorialAction = QAction('Tutorial', self)
            tutorialAction.triggered.connect(self.show_tutorial_dialog)
            helpMenu.addAction(tutorialAction)

            # Options
            optionsMenu = menuBar.addMenu('Options')

            selectFolderAction = QAction('Select Folder', self)
            selectFolderAction.triggered.connect(self.selectFolder)
            optionsMenu.addAction(selectFolderAction)

            parseAction = QAction('Parse', self)
            parseAction.triggered.connect(self.parseSelectedFolder)
            optionsMenu.addAction(parseAction)

            saveAction = QAction('Save', self)
            saveAction.triggered.connect(self.saveToFile)
            optionsMenu.addAction(saveAction)

            copyAction = QAction('Copy to Clipboard', self)
            copyAction.triggered.connect(self.copyToClipboard)
            optionsMenu.addAction(copyAction)

            copyStructureAction = QAction('Copy File Structure', self)
            copyStructureAction.triggered.connect(self.copyFileStructure)
            optionsMenu.addAction(copyStructureAction)

            self.selected_folder = None
        except Exception as e:
            QMessageBox.critical(self, "Initialization Error", f"Error initializing UI: {str(e)}")

    def initSystemTray(self):
        try:
            self.trayIcon = QSystemTrayIcon(self)
            self.trayIcon.setIcon(QtGui.QIcon(resource_path("app_icon_pt.ico")))

            trayMenu = QMenu(self)

            # Add actions to tray menu
            selectFolderAction = QAction("Select Folder", self)
            selectFolderAction.triggered.connect(self.selectFolder)
            trayMenu.addAction(selectFolderAction)

            parseAction = QAction("Parse", self)
            parseAction.triggered.connect(self.parseSelectedFolder)
            trayMenu.addAction(parseAction)

            saveAction = QAction("Save", self)
            saveAction.triggered.connect(self.saveToFile)
            trayMenu.addAction(saveAction)

            copyAction = QAction("Copy to Clipboard", self)
            copyAction.triggered.connect(self.copyToClipboard)
            trayMenu.addAction(copyAction)

            copyStructureAction = QAction("Copy File Structure", self)
            copyStructureAction.triggered.connect(self.copyFileStructure)
            trayMenu.addAction(copyStructureAction)

            aboutAction = QAction("About", self)
            aboutAction.triggered.connect(self.showAbout)
            trayMenu.addAction(aboutAction)

            donateAction = QAction("Donate", self)
            donateAction.triggered.connect(self.showDonate)
            trayMenu.addAction(donateAction)

            tutorialAction = QAction("Tutorial", self)
            tutorialAction.triggered.connect(self.show_tutorial_dialog)
            trayMenu.addAction(tutorialAction)

            exitAction = QAction("Exit", self)
            exitAction.triggered.connect(QApplication.quit)
            trayMenu.addAction(exitAction)

            self.trayIcon.setContextMenu(trayMenu)
            self.trayIcon.show()
        except Exception as e:
            QMessageBox.critical(self, "System Tray Error", f"Error initializing system tray: {str(e)}")

    def onFolderClicked(self, index):
        try:
            self.selected_folder = self.folderModel.filePath(index)
            self.populateFileList(self.selected_folder)
        except Exception as e:
            QMessageBox.critical(self, "Folder Selection Error", f"Error selecting folder: {str(e)}")

    def selectFolder(self):
        try:
            folder = QFileDialog.getExistingDirectory(self, "Select Directory")
            if folder:
                self.selected_folder = folder
                index = self.folderModel.index(folder)
                self.folderView.setCurrentIndex(index)
                self.populateFileList(folder)
        except Exception as e:
            QMessageBox.critical(self, "Folder Selection Error", f"Error selecting folder: {str(e)}")

    def populateFileList(self, folder):
        try:
            self.fileList.clear()
            for root, dirs, files in os.walk(folder):
                for file in files:
                    file_path = os.path.join(root, file)
                    if self.filterFileType(file):
                        self.fileList.addItem(file_path)
            self.filterFileList()
        except Exception as e:
            QMessageBox.critical(self, "File Population Error", f"Error populating file list: {str(e)}")

    def filterFolderTree(self):
        try:
            search_term = self.folderSearchBar.text().lower()
            self.folderView.setRootIndex(self.folderModel.index(QDir.rootPath()))
            self.filterFolderModel(self.folderModel.index(QDir.rootPath()), search_term)
        except Exception as e:
            QMessageBox.critical(self, "Folder Filter Error", f"Error filtering folder tree: {str(e)}")

    def filterFolderModel(self, parent, search_term):
        for row in range(self.folderModel.rowCount(parent)):
            index = self.folderModel.index(row, 0, parent)
            if not self.folderModel.isDir(index):
                continue
            folder_name = self.folderModel.fileName(index).lower()
            match = search_term in folder_name
            self.folderView.setRowHidden(row, parent, not match)
            if match or search_term in self.folderModel.filePath(index).lower():
                self.filterFolderModel(index, search_term)

    def filterFileType(self, file):
        try:
            selected_type = self.fileTypeFilter.currentText()
            if selected_type == "All Files":
                return True
            return file.endswith(selected_type)
        except Exception as e:
            QMessageBox.critical(self, "File Filter Error", f"Error filtering file type: {str(e)}")

    def filterFileList(self):
        try:
            search_term = self.searchBar.text().lower()
            for i in range(self.fileList.count()):
                item = self.fileList.item(i)
                item.setHidden(search_term not in item.text().lower())
        except Exception as e:
            QMessageBox.critical(self, "File Filter Error", f"Error filtering file list: {str(e)}")

    def parseSelectedFolder(self):
        try:
            if self.selected_folder and os.path.isdir(self.selected_folder):
                selected_items = self.fileList.selectedItems()
                if selected_items:
                    files_to_parse = [item.text() for item in selected_items]
                else:
                    files_to_parse = []
                    for root, dirs, files in os.walk(self.selected_folder):
                        for file in files:
                            if self.filterFileType(file):
                                files_to_parse.append(os.path.join(root, file))
                self.parseFiles(files_to_parse)
            else:
                QMessageBox.warning(self, "Warning", "Please select a valid folder first.")
        except Exception as e:
            QMessageBox.critical(self, "Parse Error", f"Error parsing folder: {str(e)}")

    def parseFiles(self, files):
        try:
            self.textArea.clear()
            self.textArea.append('#' * 50)
            for file_path in files:
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    self.textArea.append(f"\n\n{'#' * 4} {os.path.basename(file_path)}:\n\n")
                    self.textArea.append(content)
                    self.textArea.append("\n")
                    self.textArea.append('#' * 50)
                except Exception as e:
                    QMessageBox.critical(self, "File Read Error", f"Error reading {file_path}: {str(e)}")
        except Exception as e:
            QMessageBox.critical(self, "Parse Error", f"Error parsing files: {str(e)}")

    def saveToFile(self):
        try:
            filename, _ = QFileDialog.getSaveFileName(self, "Save File", "", "Text Files (*.txt);;All Files (*)")
            if filename:
                try:
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(self.textArea.toPlainText())
                except Exception as e:
                    QMessageBox.critical(self, "Save Error", f"Error saving file: {str(e)}")
        except Exception as e:
            QMessageBox.critical(self, "Save Dialog Error", f"Error opening save dialog: {str(e)}")

    def copyToClipboard(self):
        try:
            clipboard = QApplication.clipboard()
            clipboard.setText(self.textArea.toPlainText())
            QMessageBox.information(self, "Success", "Text copied to clipboard.")
        except Exception as e:
            QMessageBox.critical(self, "Copy Error", f"Error copying to clipboard: {str(e)}")

    def copyFileStructure(self):
        try:
            if not self.selected_folder:
                QMessageBox.warning(self, "Warning", "Please select a folder first.")
                return
            
            structure = []
            for root, dirs, files in os.walk(self.selected_folder):
                level = root.replace(self.selected_folder, '').count(os.sep)
                indent = ' ' * 4 * (level)
                structure.append('{}{}/'.format(indent, os.path.basename(root)))
                subindent = ' ' * 4 * (level + 1)
                for f in files:
                    structure.append('{}{}'.format(subindent, f))
            
            try:
                clipboard = QApplication.clipboard()
                clipboard.setText('\n'.join(structure))
                QMessageBox.information(self, "Success", "File structure copied to clipboard.")
            except Exception as e:
                QMessageBox.critical(self, "Copy Error", f"Error copying file structure to clipboard: {str(e)}")
        except Exception as e:
            QMessageBox.critical(self, "Copy Structure Error", f"Error copying file structure: {str(e)}")

    def onFileSelectionChanged(self):
        try:
            selected_items = self.fileList.selectedItems()
            if selected_items:
                file_path = selected_items[0].text()
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    self.textArea.setPlainText(content)
                    self.highlightSearchResults()
                except Exception as e:
                    QMessageBox.critical(self, "File Read Error", f"Error reading {file_path}: {str(e)}")
            self.updateToggleSelectButton()
        except Exception as e:
            QMessageBox.critical(self, "File Selection Error", f"Error handling file selection: {str(e)}")

    def highlightSearchResults(self):
        try:
            cursor = self.textArea.textCursor()
            cursor.movePosition(cursor.Start)
            search_term = self.searchBar.text()
            format = QtGui.QTextCharFormat()
            format.setBackground(QtGui.QBrush(Qt.yellow))

            while not cursor.isNull() and not cursor.atEnd():
                cursor = self.textArea.document().find(search_term, cursor)
                if not cursor.isNull():
                    cursor.mergeCharFormat(format)
        except Exception as e:
            QMessageBox.critical(self, "Highlight Error", f"Error highlighting search results: {str(e)}")

    def toggleSelectFiles(self):
        try:
            if self.toggleSelectButton.isChecked():
                self.fileList.selectAll()
                self.toggleSelectButton.setText("Deselect All Files")
            else:
                self.fileList.clearSelection()
                self.toggleSelectButton.setText("Select All Files")
        except Exception as e:
            QMessageBox.critical(self, "Toggle Error", f"Error toggling file selection: {str(e)}")

    def updateToggleSelectButton(self):
        try:
            if self.fileList.selectedItems():
                self.toggleSelectButton.setChecked(True)
                self.toggleSelectButton.setText("Deselect All Files")
            else:
                self.toggleSelectButton.setChecked(False)
                self.toggleSelectButton.setText("Select All Files")
        except Exception as e:
            QMessageBox.critical(self, "Update Toggle Error", f"Error updating toggle select button: {str(e)}")

    def show_tutorial_dialog(self):
        try:
            tutorialWindow = ParsingToolTutorialWindow(self)
            tutorialWindow.show()
        except Exception as e:
            QMessageBox.critical(self, "Tutorial Error", f"Error opening tutorial: {str(e)}")

    def showAbout(self):
        try:
            dialog = QDialog(self)
            dialog.setWindowTitle("About")
            dialog.setFixedSize(400, 300)

            layout = QVBoxLayout()

            message = QLabel("This is a Parsing Tool application that allows you to select a folder and parse its files.\n\nFor more information, check out the Tutorial in the Help menu.\n\nFor support, email us at Support@TSTP.xyz.\n\nThank you for your support and for downloading the Parsing Tool!")
            message.setWordWrap(True)
            message.setAlignment(Qt.AlignCenter)
        
            layout.addWidget(message)
        
            button_layout = QHBoxLayout()
        
            btn_yes = QPushButton("Yes")
            btn_yes.clicked.connect(lambda: QtGui.QDesktopServices.openUrl(QUrl("https://tstp.xyz/programs/parsing-tool/")))
        
            btn_ok = QPushButton("OK")
            btn_ok.clicked.connect(dialog.close)
        
            button_layout.addWidget(btn_yes)
            button_layout.addWidget(btn_ok)
        
            layout.addLayout(button_layout)
        
            dialog.setLayout(layout)
            dialog.exec_()
        except Exception as e:
            QMessageBox.critical(self, "About Error", f"Error showing about dialog: {str(e)}")

    def showDonate(self):
        try:
            dialog = QDialog(self)
            dialog.setWindowTitle("Donate")
            dialog.setFixedSize(400, 200)

            layout = QVBoxLayout()

            message = QLabel("Thank you for considering a donation!\n\nYou do not have to donate, as this program is free and we will continue to provide free programs and projects for the public, but your donation is greatly appreciated if you still choose to.\n\nThank you for supporting us by downloading the program!\n\nWe appreciate it over at TSTP.")
            message.setWordWrap(True)
            message.setAlignment(Qt.AlignCenter)
        
            layout.addWidget(message)
        
            button_layout = QHBoxLayout()
        
            btn_yes = QPushButton("Yes")
            btn_yes.clicked.connect(lambda: QtGui.QDesktopServices.openUrl(QUrl("https://www.tstp.xyz/donate")))
        
            btn_ok = QPushButton("OK")
            btn_ok.clicked.connect(dialog.close)
        
            button_layout.addWidget(btn_yes)
            button_layout.addWidget(btn_ok)
        
            layout.addLayout(button_layout)
        
            dialog.setLayout(layout)
            dialog.exec_()
        except Exception as e:
            QMessageBox.critical(self, "Donate Error", f"Error showing donate dialog: {str(e)}")

class ParsingToolTutorialWindow(QWidget):
    def __init__(self, parent=None):
        super(ParsingToolTutorialWindow, self).__init__(parent)
        try:
            self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))   
            self.setWindowTitle("Interactive Tutorial")
            self.setGeometry(100, 100, 800, 600)
            self.setWindowFlags(Qt.Window)

            self.layout = QVBoxLayout()

            self.webView = QWebEngineView()
            self.webView.setStyleSheet("background-color: #ffffff;")  # White background for the content
            
            self.layout.addWidget(self.webView)

            self.navigation_layout = QHBoxLayout()
            self.navigation_layout.setContentsMargins(10, 10, 10, 10)  # Margin for cleaner look

            self.back_button = QPushButton("Previous")
            self.back_button.setStyleSheet(self.button_style())
            self.back_button.clicked.connect(self.go_to_previous_page)
            self.navigation_layout.addWidget(self.back_button)

            self.progress_bar = QProgressBar()
            self.progress_bar.setRange(0, 100)
            self.progress_bar.setStyleSheet(self.progress_bar_style())
            self.navigation_layout.addWidget(self.progress_bar)

            self.next_button = QPushButton("Next")
            self.next_button.setStyleSheet(self.button_style())
            self.next_button.clicked.connect(self.go_to_next_page)
            self.navigation_layout.addWidget(self.next_button)

            self.start_button = QPushButton("Start Using App")
            self.start_button.setStyleSheet(self.button_style())
            self.start_button.clicked.connect(self.close)
            self.navigation_layout.addWidget(self.start_button)

            self.layout.addLayout(self.navigation_layout)
            self.setLayout(self.layout)

            self.current_page_index = 0
            self.tutorial_pages = [
                self.create_welcome_page(),
                self.create_overview_page(),
                self.create_select_folder_page(),
                self.create_search_filter_page(),
                self.create_parse_files_page(),
                self.create_save_copy_page(),
                self.create_copy_structure_page(),
                self.create_error_handling_page()
            ]

            self.load_tutorial_page(self.current_page_index)
        except Exception as e:
            QMessageBox.critical(self, "Initialization Error", f"Error initializing tutorial: {str(e)}")

    def load_tutorial_page(self, index):
        try:
            self.webView.setHtml(self.tutorial_pages[index])
            self.progress_bar.setValue(int((index + 1) / len(self.tutorial_pages) * 100))
        except Exception as e:
            QMessageBox.critical(self, "Loading Error", f"Error loading tutorial page: {str(e)}")

    def go_to_previous_page(self):
        try:
            if self.current_page_index > 0:
                self.current_page_index -= 1
                self.load_tutorial_page(self.current_page_index)
        except Exception as e:
            QMessageBox.critical(self, "Navigation Error", f"Error navigating to previous page: {str(e)}")

    def go_to_next_page(self):
        try:
            if self.current_page_index < len(self.tutorial_pages) - 1:
                self.current_page_index += 1
                self.load_tutorial_page(self.current_page_index)
        except Exception as e:
            QMessageBox.critical(self, "Navigation Error", f"Error navigating to next page: {str(e)}")

    def open_link_in_browser(self, url):
        try:
            QtGui.QDesktopServices.openUrl(url)
        except Exception as e:
            QMessageBox.critical(self, "Link Error", f"Error opening link: {str(e)}")

    def button_style(self):
        return """
        QPushButton {
            background-color: #4CAF50; /* Green */
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            font-size: 16px;
            margin: 4px 2px;
        }
        QPushButton:hover {
            background-color: #45a049;
        }
        """

    def progress_bar_style(self):
        return """
        QProgressBar {
            border: 1px solid #bbb;
            border-radius: 5px;
            text-align: center;
        }
        QProgressBar::chunk {
            background-color: #4CAF50;
            width: 20px;
        }
        """

    def create_welcome_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h1>Welcome to the Parsing Tool Interactive Tutorial</h1>
            <p>In this tutorial, you will learn how to use the key features of the Parsing Tool application in detail.</p>
            <p>Let's get started!</p>
        </body>
        </html>
        """

    def create_overview_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Overview</h2>
            <p>The Parsing Tool allows you to select a folder and parse its files, displaying the content in a user-friendly interface.</p>
            <p>Key features include:</p>
            <ul>
                <li>File search and filtering</li>
                <li>Parsing and displaying file contents</li>
                <li>Saving and copying parsed content</li>
                <li>Copying file structure</li>
                <li>Advanced error handling</li>
            </ul>
        </body>
        </html>
        """

    def create_select_folder_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Selecting a Folder</h2>
            <p>To begin, select a folder to parse:</p>
            <ol>
                <li>Click on the 'Select Folder' button.</li>
                <li>Browse to the desired directory and select it.</li>
                <li>The folder structure will be displayed on the left side of the application.</li>
            </ol>
        </body>
        </html>
        """

    def create_search_filter_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Search and Filter Files</h2>
            <p>Use the search bar and filter options to narrow down the list of files:</p>
            <ul>
                <li>Type in the search bar to filter files by name.</li>
                <li>Select a file type from the dropdown menu to filter by extension (e.g., .txt, .log, .xml).</li>
                <li>The file list will update in real-time based on your search criteria.</li>
            </ul>
        </body>
        </html>
        """

    def create_parse_files_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { font-size: 14px; }
                ol { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Parsing Files</h2>
            <p>To parse files:</p>
            <ol>
                <li>Select one or more files from the list.</li>
                <li>Click the 'Parse' button to display their contents in the text area.</li>
            </ol>
            <p>If no files are selected, all files in the folder and subfolders will be parsed.</p>
        </body>
        </html>
        """

    def create_save_copy_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ol { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Saving and Copying Parsed Content</h2>
            <p>You can save or copy the parsed content for further use:</p>
            <ol>
                <li>Click 'Save' to save the parsed content to a file.</li>
                <li>Click 'Copy to Clipboard' to copy the parsed content to the clipboard.</li>
            </ol>
        </body>
        </html>
        """

    def create_copy_structure_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ol { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Copying File Structure</h2>
            <p>To copy the structure of the selected folder:</p>
            <ol>
                <li>Click the 'Copy File Structure' button.</li>
                <li>The folder structure will be copied to the clipboard in a readable format.</li>
            </ol>
        </body>
        </html>
        """

    def create_error_handling_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Advanced Error Handling</h2>
            <p>The Parsing Tool includes advanced error handling to ensure smooth operation:</p>
            <ul>
                <li>Errors encountered during file parsing will be displayed in a message box.</li>
                <li>Error messages provide detailed information about the issue and possible causes.</li>
                <li>Ensure you have the necessary permissions to read and write files in the selected folder.</li>
            </ul>
        </body>
        </html>
        """

################################ PARSING TOOL END ###############################

################################ PARSE REVERSE START ############################

class ParseReverseQTextEditLogger(logging.Handler):
    def __init__(self, text_edit):
        super().__init__()
        self.text_edit = text_edit

    def emit(self, record):
        msg = self.format(record)
        self.text_edit.appendPlainText(msg)

class ParseReverseApp(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))
        self.clipboard = QApplication.clipboard()
        self.tabs = []
        self.show_notifications = True
        self.db_path = "C:/TSTP/ParseReverse/DB/folders.db"
        self.create_db()
        self.setWindowFlags(Qt.Window)
        self.setWindowTitle("Parse Reverse - TSTP:Omni Omega")
        try:
            self.initUI()
            # self.init_tray_icon()
            self.init_logging()
        except Exception as e:
            logging.error(f"Initialization Error: {str(e)}")
            self.show_error("Initialization Error", f"An error occurred during initialization: {str(e)}")
            sys.exit(1)

    def initUI(self):
        try:
            self.layout = QVBoxLayout()

            # Menu Bar
            menubar = QMenuBar()
            self.layout.setMenuBar(menubar)

            file_menu = menubar.addMenu('File')
            edit_menu = menubar.addMenu('Edit')
            help_menu = menubar.addMenu('Help')

            new_tab_action = QAction('New Tab', self)
            new_tab_action.triggered.connect(self.new_tab)
            file_menu.addAction(new_tab_action)

            save_action = QAction('Save', self)
            save_action.triggered.connect(self.save_content)
            save_action.setShortcut('Ctrl+S')
            file_menu.addAction(save_action)

            exit_action = QAction('Exit', self)
            exit_action.triggered.connect(self.close)
            file_menu.addAction(exit_action)

            copy_clipboard_action = QAction('Copy from Clipboard', self)
            copy_clipboard_action.triggered.connect(self.copy_from_clipboard)
            copy_clipboard_action.setShortcut('Ctrl+1')
            edit_menu.addAction(copy_clipboard_action)

            toggle_auto_clipboard_action = QAction('Toggle Auto Clipboard', self)
            toggle_auto_clipboard_action.triggered.connect(lambda: self.toggle_auto_clipboard(None))
            toggle_auto_clipboard_action.setCheckable(True)
            toggle_auto_clipboard_action.setShortcut('Ctrl+2')
            edit_menu.addAction(toggle_auto_clipboard_action)

            toggle_auto_parse_action = QAction('Toggle Auto Parse', self)
            toggle_auto_parse_action.triggered.connect(lambda: self.toggle_auto_parse(None))
            toggle_auto_parse_action.setCheckable(True)
            toggle_auto_parse_action.setShortcut('Ctrl+3')
            edit_menu.addAction(toggle_auto_parse_action)

            detect_delimiter_action = QAction('Detect Delimiter', self)
            detect_delimiter_action.triggered.connect(self.detect_delimiter)
            edit_menu.addAction(detect_delimiter_action)

            toggle_notifications_action = QAction('Toggle Notifications', self)
            toggle_notifications_action.triggered.connect(self.toggle_notifications)
            toggle_notifications_action.setCheckable(True)
            edit_menu.addAction(toggle_notifications_action)

            toggle_log_action = QAction('Toggle Log', self)
            toggle_log_action.triggered.connect(self.toggle_log)
            toggle_log_action.setCheckable(True)
            edit_menu.addAction(toggle_log_action)

            help_menu.addAction(self.create_action("TSTP.xyz", lambda: QDesktopServices.openUrl(QUrl("https://www.tstp.xyz"))))

            tutorial_action = QAction('Tutorial', self)
            tutorial_action.triggered.connect(self.show_tutorial)
            help_menu.addAction(tutorial_action)

            about_action = QAction('About', self)
            about_action.triggered.connect(self.show_about)
            help_menu.addAction(about_action)

            donate_action = QAction('Donate', self)
            donate_action.triggered.connect(self.show_donate)
            help_menu.addAction(donate_action)

            self.tab_widget = QTabWidget()
            self.tab_widget.setTabsClosable(True)
            self.tab_widget.tabCloseRequested.connect(self.close_tab)
            self.tab_widget.currentChanged.connect(self.on_tab_changed)
            self.layout.addWidget(self.tab_widget)
            self.new_tab()

            self.log_area = QPlainTextEdit()
            self.log_area.setReadOnly(True)
            self.log_area.setVisible(False)
            self.layout.addWidget(self.log_area)

            self.setLayout(self.layout)
            self.setWindowTitle('TSTP:Parse Reverse')
            self.setGeometry(300, 300, 800, 600)
            self.show()

        except Exception as e:
            logging.error(f"UI Initialization Error: {str(e)}")
            self.show_error("UI Initialization Error", f"An error occurred while setting up the UI: {str(e)}")
            raise

    def init_logging(self):
        self.log_area_handler = ParseReverseQTextEditLogger(self.log_area)
        self.log_area_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        logging.getLogger().addHandler(self.log_area_handler)
        logging.getLogger().setLevel(logging.DEBUG)
        logging.info("Logging initialized and ready.")

    def create_db(self):
        try:
            os.makedirs("C:/TSTP/ParseReverse/DB", exist_ok=True)
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute('''CREATE TABLE IF NOT EXISTS folders (id INTEGER PRIMARY KEY, path TEXT UNIQUE)''')
            cursor.execute('''CREATE TABLE IF NOT EXISTS parsed_items (id INTEGER PRIMARY KEY, content TEXT)''')
            conn.commit()
            conn.close()
        except Exception as e:
            logging.error(f"Database Creation Error: {str(e)}")
            self.show_error("Database Creation Error", f"An error occurred while creating the database: {str(e)}")

    def new_tab(self):
        try:
            tab = QWidget()
            tab_layout = QVBoxLayout()

            # Content text area
            content_area = QTextEdit()
            content_area.textChanged.connect(self.update_file_list)
            tab_layout.addWidget(content_area)

            # File delimiter input
            delimiter_layout = QHBoxLayout()
            delimiter_layout.addWidget(QLabel("File Delimiter:"))
            delimiter_input = QComboBox()
            delimiter_input.setEditable(True)
            delimiter_input.addItems(["//", "###", "/*", "<!--"])
            delimiter_input.currentTextChanged.connect(self.update_delimiter_example)
            delimiter_layout.addWidget(delimiter_input)

            save_delimiter_button = QPushButton("Save Delimiter")
            save_delimiter_button.clicked.connect(self.save_delimiter)
            delimiter_layout.addWidget(save_delimiter_button)

            delimiter_type = QComboBox()
            delimiter_type.addItems(["Prefix", "Surround"])
            delimiter_type.currentTextChanged.connect(self.update_delimiter_example)
            delimiter_layout.addWidget(delimiter_type)

            delimiter_example = QLineEdit()
            delimiter_example.setReadOnly(True)
            delimiter_layout.addWidget(delimiter_example)
            tab_layout.addLayout(delimiter_layout)

            self.update_delimiter_example(delimiter_input, delimiter_type, delimiter_example)  # Initialize the example

            # Path selection
            path_layout = QHBoxLayout()
            path_input = QComboBox()
            path_input.setEditable(True)
            self.load_saved_folders(path_input)
            path_layout.addWidget(path_input)

            path_button = QPushButton("Select Folder")
            path_button.clicked.connect(lambda: self.select_folder(path_input))
            path_layout.addWidget(path_button)

            save_path_button = QPushButton("Save Folder")
            save_path_button.clicked.connect(lambda: self.save_folder(path_input))
            path_layout.addWidget(save_path_button)

            tab_layout.addLayout(path_layout)

            # List of files and checkboxes
            file_list = QListWidget()
            tab_layout.addWidget(file_list)

            # Buttons
            button_layout = QHBoxLayout()

            clear_button = QPushButton("Clear")
            clear_button.clicked.connect(lambda: content_area.clear())
            button_layout.addWidget(clear_button)

            auto_clipboard_button = QCheckBox("Auto Clipboard")
            auto_clipboard_button.stateChanged.connect(lambda state: self.toggle_auto_clipboard(tab))
            button_layout.addWidget(auto_clipboard_button)

            auto_parse_button = QCheckBox("Auto Parse")
            auto_parse_button.stateChanged.connect(lambda state: self.toggle_auto_parse(tab))
            button_layout.addWidget(auto_parse_button)

            select_all_button = QPushButton("Select All")
            select_all_button.clicked.connect(lambda: self.toggle_select_all(select_all_button, file_list))
            button_layout.addWidget(select_all_button)

            copy_clipboard_button = QPushButton("Copy Clipboard")
            copy_clipboard_button.clicked.connect(lambda: self.copy_from_clipboard(content_area))
            button_layout.addWidget(copy_clipboard_button)

            save_button = QPushButton("Save")
            save_button.clicked.connect(lambda: self.save_content(content_area))
            button_layout.addWidget(save_button)

            reverse_parse_button = QPushButton("Parse")
            reverse_parse_button.clicked.connect(lambda: self.reverse_parse(content_area, path_input, delimiter_input, delimiter_type, file_list))
            button_layout.addWidget(reverse_parse_button)

            tab_layout.addLayout(button_layout)

            tab.setLayout(tab_layout)
            self.tab_widget.addTab(tab, f"Tab {len(self.tabs) + 1}")
            self.tabs.append({
                'tab': tab,
                'content_area': content_area,
                'delimiter_input': delimiter_input,
                'delimiter_type': delimiter_type,
                'delimiter_example': delimiter_example,
                'path_input': path_input,
                'file_list': file_list,
                'auto_clipboard_button': auto_clipboard_button,
                'auto_parse_button': auto_parse_button,
                'auto_clipboard_timer': QTimer(self),
                'check_folder_timer': QTimer(self),
                'last_clipboard_content': ''  # Initialize last_clipboard_content
            })

            # Connect the clipboard timer to the check_clipboard method
            self.tabs[-1]['auto_clipboard_timer'].timeout.connect(self.check_clipboard)

            logging.info(f"New tab created: Tab {len(self.tabs)}")

        except Exception as e:
            logging.error(f"New Tab Error: {str(e)}")
            self.show_error("New Tab Error", f"An error occurred while creating a new tab: {str(e)}")
            raise

    def close_tab(self, index):
        try:
            self.tab_widget.removeTab(index)
            self.tabs.pop(index)
            logging.info(f"Tab {index + 1} closed")
        except Exception as e:
            logging.error(f"Close Tab Error: {str(e)}")
            self.show_error("Close Tab Error", f"An error occurred while closing the tab: {str(e)}")

    def on_tab_changed(self, index):
        try:
            if index != -1:
                for tab_index, tab_data in enumerate(self.tabs):
                    if tab_data['auto_clipboard_button'].isChecked():
                        if tab_index == index:
                            tab_data['auto_clipboard_timer'].start(1000)
                        else:
                            tab_data['auto_clipboard_timer'].stop()
            logging.info(f"Switched to tab {index + 1}")
        except Exception as e:
            logging.error(f"Tab Changed Error: {str(e)}")
            self.show_error("Tab Changed Error", f"An error occurred while changing tabs: {str(e)}")

    def update_delimiter_example(self, delimiter_input, delimiter_type, delimiter_example):
        try:
            delimiter = delimiter_input.currentText()
            if delimiter_type.currentText() == "Prefix":
                delimiter_example.setText(f"{delimiter} filename.filetype")
            else:
                delimiter_example.setText(f"{delimiter} filename.filetype {delimiter}")
            logging.info(f"Delimiter example updated: {delimiter_example.text()}")
        except Exception as e:
            logging.error(f"Update Delimiter Example Error: {str(e)}")
            self.show_error("Update Delimiter Example Error", f"An error occurred while updating the delimiter example: {str(e)}")

    def save_delimiter(self):
        try:
            delimiter = self.tabs[self.tab_widget.currentIndex()]['delimiter_input'].currentText()
            if delimiter and delimiter not in [self.tabs[self.tab_widget.currentIndex()]['delimiter_input'].itemText(i) for i in range(self.tabs[self.tab_widget.currentIndex()]['delimiter_input'].count())]:
                self.tabs[self.tab_widget.currentIndex()]['delimiter_input'].addItem(delimiter)
            logging.info(f"Delimiter saved: {delimiter}")
        except Exception as e:
            logging.error(f"Save Delimiter Error: {str(e)}")
            self.show_error("Save Delimiter Error", f"An error occurred while saving the delimiter: {str(e)}")

    def select_folder(self, path_input):
        try:
            folder = QFileDialog.getExistingDirectory(self, "Select Folder")
            if folder:
                path_input.setCurrentText(folder)
            logging.info(f"Folder selected: {folder}")
        except Exception as e:
            logging.error(f"Folder Selection Error: {str(e)}")
            self.show_error("Folder Selection Error", f"An error occurred while selecting the folder: {str(e)}")

    def save_folder(self, path_input):
        try:
            folder = path_input.currentText()
            if folder:
                conn = sqlite3.connect(self.db_path)
                cursor = conn.cursor()
                cursor.execute('''INSERT OR IGNORE INTO folders (path) VALUES (?)''', (folder,))
                conn.commit()
                conn.close()
                # Update the combobox with the saved folder
                self.load_saved_folders(path_input)
            logging.info(f"Folder saved: {folder}")
        except Exception as e:
            logging.error(f"Save Folder Error: {str(e)}")
            self.show_error("Save Folder Error", f"An error occurred while saving the folder: {str(e)}")

    def load_saved_folders(self, path_input):
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute('''SELECT path FROM folders''')
            folders = cursor.fetchall()
            path_input.clear()  # Clear current items before loading
            for folder in folders:
                path_input.addItem(folder[0])
            conn.close()
            logging.info(f"Saved folders loaded: {folders}")
        except Exception as e:
            logging.error(f"Load Saved Folders Error: {str(e)}")
            self.show_error("Load Saved Folders Error", f"An error occurred while loading saved folders: {str(e)}")

    def detect_delimiter(self):
        try:
            content = self.tabs[self.tab_widget.currentIndex()]['content_area'].toPlainText()
            if not content:
                self.show_error("Detect Delimiter Error", "Content area is empty")
                return

            delimiters = set(re.findall(r'\W+', content))
            if not delimiters:
                self.show_error("Detect Delimiter Error", "No delimiters detected in the content")
                return

            dialog = QDialog(self)
            dialog.setWindowTitle("TSTP:PR - Select Delimiter")
            layout = QVBoxLayout()
            dialog.setLayout(layout)

            delimiter_combobox = QComboBox()
            delimiter_combobox.addItems(delimiters)
            layout.addWidget(delimiter_combobox)

            select_button = QPushButton("Select")
            layout.addWidget(select_button)

            def on_select():
                selected_delimiter = delimiter_combobox.currentText()
                if selected_delimiter:
                    self.tabs[self.tab_widget.currentIndex()]['delimiter_input'].setCurrentText(selected_delimiter)
                dialog.close()

            select_button.clicked.connect(on_select)
            dialog.exec_()

            logging.info("Delimiter detected")
        except Exception as e:
            logging.error(f"Detect Delimiter Error: {str(e)}")
            self.show_error("Detect Delimiter Error", f"An error occurred while detecting the delimiter: {str(e)}")

    def toggle_select_all(self, select_all_button, file_list):
        try:
            select_all = select_all_button.text() == "Select All"
            for index in range(file_list.count()):
                item = file_list.item(index)
                item.setCheckState(Qt.Checked if select_all else Qt.Unchecked)
            select_all_button.setText("Deselect All" if select_all else "Select All")
            logging.info("Select All toggled")
        except Exception as e:
            logging.error(f"Toggle Select All Error: {str(e)}")
            self.show_error("Toggle Select All Error", f"An error occurred while toggling select all: {str(e)}")

    def update_file_list(self):
        try:
            content = self.tabs[self.tab_widget.currentIndex()]['content_area'].toPlainText()
            delimiter = self.tabs[self.tab_widget.currentIndex()]['delimiter_input'].currentText()
            delimiter_type = self.tabs[self.tab_widget.currentIndex()]['delimiter_type'].currentText()

            if not delimiter:
                return

            files = {}
            current_file = None

            if delimiter_type == "Prefix":
                pattern = f"^{re.escape(delimiter)}\\s*(.+\\..+)$"  # Ensure the filename has an extension
            else:  # Surround
                pattern = f"^{re.escape(delimiter)}\\s*(.+\\..+)\\s*{re.escape(delimiter)}$"

            for line in content.split('\n'):
                match = re.match(pattern, line.strip())
                if match:
                    current_file = match.group(1)
                    if current_file:
                        files[current_file] = ""
                elif current_file:
                    files[current_file] += line + '\n'

            self.tabs[self.tab_widget.currentIndex()]['file_list'].clear()
            for filename in files.keys():
                if filename:  # Ensure filename is not empty
                    item = QListWidgetItem(filename)
                    item.setCheckState(Qt.Checked)
                    self.tabs[self.tab_widget.currentIndex()]['file_list'].addItem(item)
            logging.info("File list updated")
        except Exception as e:
            logging.error(f"Update File List Error: {str(e)}")
            self.show_error("Update File List Error", f"An error occurred while updating the file list: {str(e)}")

    def reverse_parse(self, content_area, path_input, delimiter_input, delimiter_type, file_list):
        try:
            content = content_area.toPlainText()
            path = path_input.currentText()

            if not content:
                raise ValueError("Content area is empty")
            if not path:
                raise ValueError("No output path specified")

            delimiter = delimiter_input.currentText()
            delimiter_type = delimiter_type.currentText()

            if not delimiter:
                raise ValueError("File delimiter is not specified")

            files = {}
            current_file = None

            if delimiter_type == "Prefix":
                pattern = f"^{re.escape(delimiter)}\\s*(.+\\..+)$"  # Ensure the filename has an extension
            else:  # Surround
                pattern = f"^{re.escape(delimiter)}\\s*(.+\\..+)\\s*{re.escape(delimiter)}$"

            for line in content.split('\n'):
                match = re.match(pattern, line.strip())
                if match:
                    current_file = match.group(1)
                    if current_file:
                        files[current_file] = ""
                elif current_file:
                    files[current_file] += line + '\n'

            if not files:
                raise ValueError("No files were detected in the content")

            for index in range(file_list.count()):
                item = file_list.item(index)
                if item.checkState() == Qt.Checked:
                    filename = item.text()
                    file_content = files.get(filename)
                    if not file_content.strip():
                        continue

                    file_path = os.path.join(path, filename)
                    os.makedirs(os.path.dirname(file_path), exist_ok=True)
                    with open(file_path, 'w') as f:
                        f.write(file_content.strip())

                    self.save_parsed_item(file_content.strip())

            if not self.tabs[self.tab_widget.currentIndex()]['auto_clipboard_button'].isChecked() and not self.tabs[self.tab_widget.currentIndex()]['auto_parse_button'].isChecked():
                self.show_info("Success", f"Created {len(files)} files successfully!")
            else:
                self.show_tray_notification("Content parsed and saved")

            logging.info(f"Files parsed and saved to {path}")
        except Exception as e:
            logging.error(f"Reverse Parse Error: {str(e)}")
            self.show_tray_notification("Error during parsing: Some content could not be parsed.")

    def save_parsed_item(self, content):
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute('''INSERT INTO parsed_items (content) VALUES (?)''', (content,))
            conn.commit()
            conn.close()
            logging.info(f"Parsed item saved to database")
        except Exception as e:
            logging.error(f"Save Parsed Item Error: {str(e)}")
            self.show_error("Save Parsed Item Error", f"An error occurred while saving parsed item: {str(e)}")

    def show_error(self, title, message):
        logging.error(f"{title}: {message}")
        QMessageBox.critical(self, title, message)

    def show_info(self, title, message):
        logging.info(f"{title}: {message}")
        QMessageBox.information(self, title, message)

    def copy_from_clipboard(self, content_area):
        try:
            clipboard_content = self.clipboard.text()
            if clipboard_content != content_area.toPlainText():
                content_area.setPlainText(clipboard_content)
                self.tabs[self.tab_widget.currentIndex()]['last_clipboard_content'] = clipboard_content
                logging.info(f"Content copied from clipboard")
        except Exception as e:
            logging.error(f"Copy from Clipboard Error: {str(e)}")
            self.show_error("Copy from Clipboard Error", f"An error occurred while copying from clipboard: {str(e)}")

    def save_content(self, content_area):
        try:
            file_name, _ = QFileDialog.getSaveFileName(self, "Save File", "", "Text Files (*.txt);;All Files (*)")
            if file_name:
                with open(file_name, 'w') as f:
                    f.write(content_area.toPlainText())
                self.show_info("Success", "Content saved successfully!")
                logging.info(f"Content saved to {file_name}")
        except Exception as e:
            logging.error(f"Save Error: {str(e)}")
            self.show_error("Save Error", f"An error occurred while saving the content: {str(e)}")

    def toggle_auto_clipboard(self, tab=None):
        try:
            current_tab_index = self.tab_widget.currentIndex()
            if tab is None:
                tab = self.tab_widget.widget(current_tab_index)

            tab_data = next((t for t in self.tabs if t['tab'] == tab), None)
            if tab_data is None:
                raise ValueError("Tab not found")

            tab_data['auto_clipboard'] = tab_data['auto_clipboard_button'].isChecked()
            if tab_data['auto_clipboard']:
                tab_data['auto_clipboard_timer'].start(1000)  # Check every second
                logging.info("Auto Clipboard enabled")
            else:
                tab_data['auto_clipboard_timer'].stop()
                logging.info("Auto Clipboard disabled")
        except Exception as e:
            logging.error(f"Toggle Auto Clipboard Error: {str(e)}")
            self.show_error("Toggle Auto Clipboard Error", f"An error occurred while toggling auto clipboard: {str(e)}")

    def toggle_auto_parse(self, tab=None):
        try:
            current_tab_index = self.tab_widget.currentIndex()
            if tab is None:
                tab = self.tab_widget.widget(current_tab_index)

            tab_data = next((t for t in self.tabs if t['tab'] == tab), None)
            if tab_data is None:
                raise ValueError("Tab not found")

            tab_data['auto_parse'] = tab_data['auto_parse_button'].isChecked()
            if tab_data['auto_parse']:
                if not tab_data['path_input'].currentText():
                    self.select_folder(tab_data['path_input'])
                    if not tab_data['path_input'].currentText():
                        tab_data['auto_parse_button'].setChecked(False)
                        tab_data['auto_parse'] = False
                else:
                    tab_data['check_folder_timer'].timeout.connect(lambda: self.check_folder(tab_data))
                    tab_data['check_folder_timer'].start(10000)  # Check every 10 seconds
                logging.info("Auto Parse enabled")
            else:
                tab_data['check_folder_timer'].stop()
                logging.info("Auto Parse disabled")
        except Exception as e:
            logging.error(f"Toggle Auto Parse Error: {str(e)}")
            self.show_error("Toggle Auto Parse Error", f"An error occurred while toggling auto parse: {str(e)}")

    def check_folder(self, tab_data):
        try:
            if not os.path.isdir(tab_data['path_input'].currentText()):
                tab_data['auto_parse_button'].setChecked(False)
                tab_data['auto_parse'] = False
                self.show_error("Invalid Folder", "The selected folder is not valid.")
            logging.info(f"Folder checked: {tab_data['path_input'].currentText()}")
        except Exception as e:
            logging.error(f"Check Folder Error: {str(e)}")
            self.show_error("Check Folder Error", f"An error occurred while checking the folder: {str(e)}")

    def check_clipboard(self):
        try:
            current_tab_index = self.tab_widget.currentIndex()
            if current_tab_index != -1:
                tab = self.tabs[current_tab_index]
                new_clipboard = self.clipboard.text()
                if new_clipboard != tab['last_clipboard_content']:
                    tab['last_clipboard_content'] = new_clipboard
                    tab['content_area'].setPlainText(new_clipboard)
                    if tab['auto_parse_button'].isChecked():
                        self.reverse_parse(tab['content_area'], tab['path_input'], tab['delimiter_input'], tab['delimiter_type'], tab['file_list'])
                        tab['content_area'].clear()
                    logging.info("Clipboard content updated")
        except Exception as e:
            logging.error(f"Check Clipboard Error: {str(e)}")
            self.show_error("Check Clipboard Error", f"An error occurred while checking clipboard: {str(e)}")

    def show_tutorial(self):
        try:
            tutorial = ParseReverseTutorialWindow(self)
            tutorial.exec_()
        except Exception as e:
            logging.error(f"Show Tutorial Error: {str(e)}")
            self.show_error("Show Tutorial Error", f"An error occurred while showing the tutorial: {str(e)}")

    def show_about(self):
        try:
            dialog = QDialog(self)
            dialog.setWindowTitle("TSTP:PR - About")
            dialog.setFixedSize(400, 300)

            layout = QVBoxLayout()

            message = QLabel("This is the Parse Reverse application that allows you to reverse parse files.\n\nFor more information, check out the Tutorial in the Help menu.\n\nFor support, email us at Support@ParseReverse.xyz.\n\nThank you for your support and for downloading Parse Reverse!")
            message.setWordWrap(True)
            message.setAlignment(Qt.AlignCenter)

            layout.addWidget(message)

            button_layout = QHBoxLayout()

            btn_yes = QPushButton("Yes")
            btn_yes.clicked.connect(lambda: QUrl("https://parserverse.xyz/programs/parse-reverse/").openUrl())

            btn_ok = QPushButton("OK")
            btn_ok.clicked.connect(dialog.close)

            button_layout.addWidget(btn_yes)
            button_layout.addWidget(btn_ok)

            layout.addLayout(button_layout)

            dialog.setLayout(layout)
            dialog.exec_()
        except Exception as e:
            logging.error(f"About Error: {str(e)}")
            self.show_error("About Error", f"An error occurred while showing the about dialog: {str(e)}")

    def show_donate(self):
        try:
            dialog = QDialog(self)
            dialog.setWindowTitle("TSTP:PR - Donate")
            dialog.setFixedSize(500, 300)

            layout = QVBoxLayout()

            message = QLabel("Thank you for considering a donation!\n\nYou do not have to donate, as this program is free and we will continue to provide free programs and projects for the public, but your donation is greatly appreciated if you still choose to.\n\nThank you for supporting us by downloading the program!\n\nWe appreciate it over at Parse Reverse.\n\nWould you like to visit the donation page now? Click Yes to go to the donation page or OK to close the window.")
            message.setWordWrap(True)
            message.setAlignment(Qt.AlignCenter)

            layout.addWidget(message)

            button_layout = QHBoxLayout()

            btn_yes = QPushButton("Yes")
            btn_yes.clicked.connect(lambda: QUrl("https://www.parserverse.xyz/donate").openUrl())

            btn_ok = QPushButton("OK")
            btn_ok.clicked.connect(dialog.close)

            button_layout.addWidget(btn_yes)
            button_layout.addWidget(btn_ok)

            layout.addLayout(button_layout)

            dialog.setLayout(layout)

            dialog.exec_()
        except Exception as e:
            logging.error(f"Donate Error: {str(e)}")
            self.show_error("Donate Error", f"An error occurred while showing the donate dialog: {str(e)}")

    def init_tray_icon(self):
        if hasattr(self, 'tray_icon_created') and self.tray_icon_created:
            return
        self.tray_icon_created = True

        try:
            self.tray_icon = QSystemTrayIcon(QIcon(resource_path("app_icon_pr.ico")), self)
            self.tray_icon.setToolTip("TSTP:Parse Reverse")  # Set the tooltip for the tray icon
            tray_menu = QMenu()

            toggle_auto_clipboard_action = QAction("Auto Clipboard", self)
            toggle_auto_clipboard_action.setCheckable(True)
            toggle_auto_clipboard_action.triggered.connect(self.toggle_auto_clipboard_from_tray)
            tray_menu.addAction(toggle_auto_clipboard_action)

            toggle_auto_parse_action = QAction("Auto Parse", self)
            toggle_auto_parse_action.setCheckable(True)
            toggle_auto_parse_action.triggered.connect(self.toggle_auto_parse_from_tray)
            tray_menu.addAction(toggle_auto_parse_action)

            tray_menu.addAction(self.create_action("TSTP.xyz", lambda: QDesktopServices.openUrl(QUrl("https://www.tstp.xyz"))))

            toggle_log_action = QAction("Toggle Log", self)
            toggle_log_action.setCheckable(True)
            toggle_log_action.triggered.connect(self.toggle_log)
            tray_menu.addAction(toggle_log_action)

            tray_menu.addAction(self.create_action("Donate", self.show_donate))
            tray_menu.addAction(self.create_action("About", self.show_about))
            tray_menu.addAction(self.create_action("Tutorial", self.show_tutorial))

            select_folder_action = QAction("Select Folder", self)
            select_folder_action.triggered.connect(lambda: self.select_folder(self.tabs[self.tab_widget.currentIndex()]['path_input']))
            tray_menu.addAction(select_folder_action)

            new_tab_action = QAction("New Tab", self)
            new_tab_action.triggered.connect(self.new_tab)
            tray_menu.addAction(new_tab_action)

            toggle_notifications_action = QAction("Toggle Notifications", self)
            toggle_notifications_action.setCheckable(True)
            toggle_notifications_action.triggered.connect(self.toggle_notifications)
            tray_menu.addAction(toggle_notifications_action)

            exit_action = QAction("Exit", self)
            exit_action.triggered.connect(self.hide)
            tray_menu.addAction(exit_action)

            self.tray_icon.setContextMenu(tray_menu)
            self.tray_icon.show()
        except Exception as e:
            logging.error(f"Tray Icon Initialization Error: {str(e)}")
            self.show_error("Tray Icon Initialization Error", f"An error occurred while initializing the tray icon: {str(e)}")

    def toggle_auto_clipboard_from_tray(self):
        try:
            current_tab_index = self.tab_widget.currentIndex()
            current_tab = self.tabs[current_tab_index]
            current_tab['auto_clipboard_button'].toggle()
        except Exception as e:
            logging.error(f"Toggle Auto Clipboard From Tray Error: {str(e)}")
            self.show_error("Toggle Auto Clipboard From Tray Error", f"An error occurred while toggling auto clipboard from tray: {str(e)}")

    def toggle_auto_parse_from_tray(self):
        try:
            current_tab_index = self.tab_widget.currentIndex()
            current_tab = self.tabs[current_tab_index]
            current_tab['auto_parse_button'].toggle()
        except Exception as e:
            logging.error(f"Toggle Auto Parse From Tray Error: {str(e)}")
            self.show_error("Toggle Auto Parse From Tray Error", f"An error occurred while toggling auto parse from tray: {str(e)}")

    def toggle_log(self):
        self.log_area.setVisible(not self.log_area.isVisible())
        logging.info(f"Log {'enabled' if self.log_area.isVisible() else 'disabled'}")

    def show_tray_notification(self, message):
        self.tray_icon.showMessage("TSTP:Parse Reverse", message, QSystemTrayIcon.Information, 10000)

    def toggle_notifications(self):
        self.show_notifications = not self.show_notifications
        logging.info(f"Notifications {'enabled' if self.show_notifications else 'disabled'}")

    def create_action(self, name, function):
        action = QAction(name, self)
        action.triggered.connect(function)
        return action

class ParseReverseTutorialWindow(QDialog):
    def __init__(self, parent=None):
        super(ParseReverseTutorialWindow, self).__init__(parent)
        try:
            self.setWindowTitle("TSTP:PR - Interactive Tutorial")
            self.setGeometry(100, 100, 800, 600)

            self.layout = QVBoxLayout()

            self.webView = QPlainTextEdit()
            self.webView.setReadOnly(True)
            self.webView.setStyleSheet("background-color: #ffffff;")

            self.layout.addWidget(self.webView)

            self.navigation_layout = QHBoxLayout()
            self.navigation_layout.setContentsMargins(10, 10, 10, 10)

            self.back_button = QPushButton("Previous")
            self.back_button.setStyleSheet(self.button_style())
            self.back_button.clicked.connect(self.go_to_previous_page)
            self.navigation_layout.addWidget(self.back_button)

            self.progress_bar = QProgressBar()
            self.progress_bar.setRange(0, 100)
            self.progress_bar.setStyleSheet(self.progress_bar_style())
            self.navigation_layout.addWidget(self.progress_bar)

            self.next_button = QPushButton("Next")
            self.next_button.setStyleSheet(self.button_style())
            self.next_button.clicked.connect(self.go_to_next_page)
            self.navigation_layout.addWidget(self.next_button)

            self.start_button = QPushButton("Start Using App")
            self.start_button.setStyleSheet(self.button_style())
            self.start_button.clicked.connect(self.close)
            self.navigation_layout.addWidget(self.start_button)

            self.layout.addLayout(self.navigation_layout)
            self.setLayout(self.layout)

            self.current_page_index = 0
            self.tutorial_pages = [
                self.create_welcome_page(),
                self.create_overview_page(),
                self.create_select_folder_page(),
                self.create_set_delimiter_page(),
                self.create_parse_files_page(),
                self.create_save_copy_page(),
                self.create_auto_clipboard_page(),
                self.create_error_handling_page()
            ]

            self.load_tutorial_page(self.current_page_index)
        except Exception as e:
            logging.error(f"Initialization Error: {str(e)}")
            self.show_error("Initialization Error", f"Error initializing tutorial: {str(e)}")

    def load_tutorial_page(self, index):
        try:
            self.webView.setPlainText(self.tutorial_pages[index])
            self.progress_bar.setValue(int((index + 1) / len(self.tutorial_pages) * 100))
        except Exception as e:
            logging.error(f"Loading Error: {str(e)}")
            self.show_error("Loading Error", f"Error loading tutorial page: {str(e)}")
            
    def progress_bar_style(self):
        return """
        QProgressBar {
            border: 1px solid #bbb;
            border-radius: 5px;
            text-align: center;
        }
        QProgressBar::chunk {
            background-color: #4CAF50;
            width: 20px;
        }
        """
            
    def button_style(self):
        return """
        QPushButton {
            background-color: #4CAF50; /* Green */
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            font-size: 16px;
            margin: 4px 2px;
        }
        QPushButton:hover {
            background-color: #45a049;
        }
        """

    def go_to_previous_page(self):
        try:
            if self.current_page_index > 0:
                self.current_page_index -= 1
                self.load_tutorial_page(self.current_page_index)
        except Exception as e:
            logging.error(f"Navigation Error: {str(e)}")
            self.show_error("Navigation Error", f"Error navigating to previous page: {str(e)}")

    def go_to_next_page(self):
        try:
            if self.current_page_index < len(self.tutorial_pages) - 1:
                self.current_page_index += 1
                self.load_tutorial_page(self.current_page_index)
        except Exception as e:
            logging.error(f"Navigation Error: {str(e)}")
            self.show_error("Navigation Error", f"Error navigating to next page: {str(e)}")

    def create_welcome_page(self):
        return """
        Welcome to the Parse Reverse Interactive Tutorial

        In this tutorial, you will learn how to use the key features of the Parse Reverse application in detail.

        Let's get started!
        """

    def create_overview_page(self):
        return """
        Overview

        The Parse Reverse application allows you to reverse parse files, extracting content based on custom delimiters and saving them into separate files.

        Key features include:
        - Selecting and displaying file contents.
        - Setting custom delimiters for file content extraction.
        - Saving and copying parsed content.
        - Auto Clipboard functionality for real-time content updates.
        - Advanced error handling to ensure smooth operation.
        """

    def create_select_folder_page(self):
        return """
        Selecting a Folder

        To begin, select a folder to parse:
        1. Click on the 'Select Folder' button.
        2. Browse to the desired directory and select it.
        3. The selected path will be displayed in the path input field.
        """

    def create_set_delimiter_page(self):
        return """
        Setting File Delimiters

        To set the delimiters for parsing:
        1. Enter or select a delimiter in the 'File Delimiter' dropdown.
        2. Choose the delimiter type: 'Prefix' or 'Surround'.
        3. An example of the delimiter usage will be displayed for reference.
        4. Click 'Save Delimiter' to store the custom delimiter.
        """

    def create_parse_files_page(self):
        return """
        Parsing Files

        To parse files:
        1. Paste the content to be parsed into the text area.
        2. The file list will automatically update with detected files based on the set delimiter.
        3. Check or uncheck files in the list to include or exclude them from the parsing process.
        """

    def create_save_copy_page(self):
        return """
        Saving and Copying Parsed Content

        You can save or copy the parsed content for further use:
        1. Click 'Save' to save the parsed content to a file.
        2. Click 'Copy from Clipboard' to copy the parsed content from the clipboard to the text area.
        """

    def create_auto_clipboard_page(self):
        return """
        Using Auto Clipboard

        The Auto Clipboard feature allows real-time updates of the content area based on clipboard changes:
        1. Toggle the 'Auto Clipboard' checkbox to enable or disable this feature.
        2. When enabled, any new content copied to the clipboard will prompt the user to update the text area.
        """

    def create_error_handling_page(self):
        return """
        Advanced Error Handling

        Parse Reverse includes advanced error handling to ensure smooth operation:
        - Errors encountered during parsing will be displayed in a message box.
        - Detailed error messages provide information about the issue and possible causes.
        - Ensure you have the necessary permissions to read and write files in the selected folder.
        """

################################ PARSE REVERSE END ##############################

################################ AUTO CONTINUE START ############################

# Ensure the directory exists
base_dir = r'C:\TSTP\AutoContinue'
os.makedirs(base_dir, exist_ok=True)

class AutoContinueLogWindow(QDialog):
    def __init__(self):
        try:
            super().__init__()
            self.setWindowTitle("Log Window")
            self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))
            self.setGeometry(300, 300, 600, 400)
            self.layout = QVBoxLayout()

            self.log_text = QTextEdit()
            self.log_text.setReadOnly(True)
            self.layout.addWidget(self.log_text)

            self.refresh_button = QPushButton("Refresh Log")
            self.refresh_button.clicked.connect(self.load_log)
            self.layout.addWidget(self.refresh_button)

            self.setLayout(self.layout)
            self.load_log()
        except Exception as e:
            logging.error(f"Error in AutoContinueLogWindow.__init__: {e}")

    def load_log(self):
        try:
            with open(os.path.join(base_dir, 'autocontinue.log'), 'r') as file:
                self.log_text.setPlainText(file.read())
        except Exception as e:
            self.log_text.setPlainText(f"Error loading log file: {e}")
            logging.error(f"Error in load_log: {e}")

class AutoContinueMonitorSelectionWindow(QDialog):
    def __init__(self, selected_monitors):
        try:
            super().__init__()
            self.setWindowTitle("Select Monitors")
            self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))
            self.setGeometry(300, 300, 400, 300)
            self.layout = QVBoxLayout()

            self.monitor_checkboxes = []
            self.selected_monitors = selected_monitors

            monitors = get_monitors()
            for i, monitor in enumerate(monitors):
                checkbox = QCheckBox(f"Monitor {i + 1} ({monitor.width}x{monitor.height})")
                checkbox.setChecked(i in self.selected_monitors)
                self.monitor_checkboxes.append(checkbox)
                self.layout.addWidget(checkbox)

            self.all_monitors_checkbox = QCheckBox("All Monitors")
            self.all_monitors_checkbox.setChecked(-1 in self.selected_monitors)
            self.layout.addWidget(self.all_monitors_checkbox)

            self.ok_button = QPushButton("OK")
            self.ok_button.clicked.connect(self.save_selection)
            self.layout.addWidget(self.ok_button)

            self.setLayout(self.layout)
        except Exception as e:
            logging.error(f"Error in AutoContinueMonitorSelectionWindow.__init__: {e}")

    def save_selection(self):
        try:
            self.selected_monitors.clear()
            for i, checkbox in enumerate(self.monitor_checkboxes):
                if checkbox.isChecked():
                    self.selected_monitors.append(i)
            if self.all_monitors_checkbox.isChecked():
                self.selected_monitors.append(-1)
            self.accept()
        except Exception as e:
            logging.error(f"Error in save_selection: {e}")

class AutoContinueInfoWindow(QDialog):
    def __init__(self, title, content):
        try:
            super().__init__()
            self.setWindowTitle(title)
            self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))
            self.setGeometry(300, 300, 400, 300)
            self.layout = QVBoxLayout()

            self.label = QLabel(content)
            self.layout.addWidget(self.label)

            self.ok_button = QPushButton("OK")
            self.ok_button.clicked.connect(self.close)
            self.layout.addWidget(self.ok_button)

            self.setLayout(self.layout)
        except Exception as e:
            logging.error(f"Error in AutoContinueInfoWindow.__init__: {e}")

class AutoContinueDonateWindow(QDialog):
    def __init__(self):
        try:
            super().__init__()
            self.setWindowTitle("Donate")
            self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))
            self.setGeometry(300, 300, 400, 200)
            self.layout = QVBoxLayout()

            self.label = QLabel("Thank you for using Auto Continue!\nWould you like to donate?")
            self.layout.addWidget(self.label)

            self.yes_button = QPushButton("Yes")
            self.yes_button.clicked.connect(self.donate)
            self.layout.addWidget(self.yes_button)

            self.ok_button = QPushButton("OK")
            self.ok_button.clicked.connect(self.close)
            self.layout.addWidget(self.ok_button)

            self.setLayout(self.layout)
        except Exception as e:
            logging.error(f"Error in AutoContinueDonateWindow.__init__: {e}")

    def donate(self):
        try:
            webbrowser.open("https://www.tstp.xyz/donate")
            self.close()
        except Exception as e:
            logging.error(f"Error in donate: {e}")

class AutoContinueBrowserMonitor(QThread):
    log_signal = pyqtSignal(str)
    notification_signal = pyqtSignal(str, str, int)
    error_signal = pyqtSignal(str)

    def __init__(self, interval, button_image_path, notifications_enabled, selected_monitors):
        try:
            super().__init__()
            self.interval = interval
            self.button_image_path = button_image_path
            self.notifications_enabled = notifications_enabled
            self.monitoring = True
            self.selected_monitors = selected_monitors
            self.button_template = cv2.imread(self.button_image_path, 0)
            self.consecutive_errors = 0
            self.max_consecutive_errors = 5
        except Exception as e:
            logging.error(f"Error in AutoContinueBrowserMonitor.__init__: {e}")
            self.error_signal.emit(f"Error initializing AutoContinueBrowserMonitor: {str(e)}")

    def run(self):
        try:
            with mss.mss() as sct:
                while self.monitoring:
                    try:
                        self.process_monitors(sct)
                        self.consecutive_errors = 0  # Reset error count on successful iteration
                    except Exception as e:
                        self.handle_error(e)
                    
                    time.sleep(self.interval)
        except Exception as e:
            logging.error(f"Critical error in AutoContinueBrowserMonitor.run: {e}")
            self.error_signal.emit(f"Critical error in monitoring: {str(e)}")

    def process_monitors(self, sct):
        monitors = get_monitors()
        for i, monitor in enumerate(monitors):
            if -1 in self.selected_monitors or i in self.selected_monitors:
                self.process_single_monitor(sct, monitor, i)

    def process_single_monitor(self, sct, monitor, monitor_index):
        try:
            monitor_dict = {
                "top": monitor.y,
                "left": monitor.x,
                "width": monitor.width,
                "height": monitor.height
            }
            screenshot = np.array(sct.grab(monitor_dict))
            gray_screenshot = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)

            result = cv2.matchTemplate(gray_screenshot, self.button_template, cv2.TM_CCOEFF_NORMED)
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

            if max_val > 0.8:  # Adjust this threshold as needed
                button_x = monitor.x + max_loc[0] + self.button_template.shape[1] // 2
                button_y = monitor.y + max_loc[1] + self.button_template.shape[0] // 2

                pyautogui.click(button_x, button_y)

                self.log_signal.emit(f"Clicked 'Continue generation' button on monitor {monitor_index+1}")
                if self.notifications_enabled:
                    self.notification_signal.emit("TSTP:Auto Continue", f"Clicked button on monitor {monitor_index+1}", QSystemTrayIcon.Information)
        except mss.exception.ScreenShotError as e:
            raise Exception(f"ScreenShotError on monitor {monitor_index+1}: {e}")
        except Exception as e:
            raise Exception(f"Unexpected error on monitor {monitor_index+1}: {e}")

    def handle_error(self, error):
        self.consecutive_errors += 1
        error_msg = f"Error in monitoring: {str(error)}"
        logging.error(error_msg)
        self.error_signal.emit(error_msg)
        
        if self.consecutive_errors >= self.max_consecutive_errors:
            self.monitoring = False
            critical_error_msg = f"Stopping monitoring due to {self.consecutive_errors} consecutive errors"
            logging.critical(critical_error_msg)
            self.error_signal.emit(critical_error_msg)

    def stop(self):
        try:
            self.monitoring = False
        except Exception as e:
            logging.error(f"Error in AutoContinueBrowserMonitor.stop: {e}")
            self.error_signal.emit(f"Error stopping AutoContinueBrowserMonitor: {str(e)}")

class AutoContinueApp(QSystemTrayIcon):
    tray_icon_created = False

    def __init__(self, parent=None):
        super().__init__(parent)
        
        try:
            if AutoContinueApp.tray_icon_created:
                return

            self.setIcon(QIcon(resource_path("app_icon_ac.ico")))
            self.setToolTip("TSTP:Auto Continue")

            # Setup logging
            logging.basicConfig(filename=os.path.join(base_dir, 'autocontinue.log'), level=logging.INFO,
                                format='%(asctime)s - %(levelname)s - %(message)s')

            # Load settings
            self.settings_file = os.path.join(base_dir, 'settings.json')
            self.interval = 1
            self.notifications_enabled = True
            self.selected_monitors = [-1]
            self.load_settings()

            # Button image path
            self.button_image_path = resource_path("button_image.png")

            AutoContinueApp.tray_icon_created = True

            self.create_menu()

            self.monitoring = False
            self.monitor_thread = None
            self.log_window = None

            self.watchdog_timer = QTimer(self)
            self.watchdog_timer.timeout.connect(self.check_monitoring_status)
            self.watchdog_timer.start(60000)

            self.setup_shortcuts()

            self.apply_theme()  # Apply the theme immediately upon creation

        except Exception as e:
            logging.critical(f"Critical error in AutoContinueApp.__init__: {e}")
            self.show_error_message(f"Critical error initializing application: {str(e)}")

    def create_menu(self):
        try:
            self.menu = QMenu()

            self.toggle_action = QAction("Enable", self)
            self.toggle_action.triggered.connect(self.toggle_monitoring)
            self.menu.addAction(self.toggle_action)

            self.notification_action = QAction("Disable Notifications", self)
            self.notification_action.triggered.connect(self.toggle_notifications)
            self.menu.addAction(self.notification_action)

            self.interval_action = QAction("Set Interval", self)
            self.interval_action.triggered.connect(self.set_interval)
            self.menu.addAction(self.interval_action)

            self.monitor_action = QAction("Select Monitors", self)
            self.monitor_action.triggered.connect(self.select_monitors)
            self.menu.addAction(self.monitor_action)

            self.log_action = QAction("Show Log", self)
            self.log_action.triggered.connect(self.show_log_window)
            self.menu.addAction(self.log_action)

            self.about_action = QAction("About", self)
            self.about_action.triggered.connect(lambda: self.show_info_window("About", "TSTP:Auto Continue\nVersion 1.0\nDeveloped by TSTP"))
            self.menu.addAction(self.about_action)

            self.tutorial_action = QAction("Tutorial", self)
            self.tutorial_action.triggered.connect(self.show_tutorial_window)
            self.menu.addAction(self.tutorial_action)

            self.donate_action = QAction("Donate", self)
            self.donate_action.triggered.connect(self.show_donate_window)
            self.menu.addAction(self.donate_action)

            self.tstp_action = QAction("TSTP.xyz", self)
            self.tstp_action.triggered.connect(lambda: webbrowser.open("https://www.TSTP.xyz"))
            self.menu.addAction(self.tstp_action)

            self.exit_action = QAction("Exit", self)
            self.exit_action.triggered.connect(self.exit_app)
            self.menu.addAction(self.exit_action)

            self.setContextMenu(self.menu)
        except Exception as e:
            logging.error(f"Error in create_menu: {e}")
            self.show_error_message(f"Error creating menu: {str(e)}")

    def apply_theme(self):
        try:
            main_window = self.parent()
            if main_window:
                theme_stylesheet = main_window.styleSheet()
                self.update_theme(theme_stylesheet)
        except Exception as e:
            logging.error(f"Error in apply_theme: {e}")
            self.show_error_message(f"Error applying theme: {str(e)}")

    def update_theme(self, theme_stylesheet):
        try:
            self.menu.setStyleSheet(theme_stylesheet)
            for action in self.menu.actions():
                widget = self.menu.widgetForAction(action)
                if widget:
                    widget.setStyleSheet(theme_stylesheet)
        except Exception as e:
            logging.error(f"Error in update_theme: {e}")
            self.show_error_message(f"Error updating theme: {str(e)}")

    def setup_shortcuts(self):
        try:
            self.enable_shortcut = QShortcut(QKeySequence("Ctrl+Alt+E"), self)
            self.enable_shortcut.activated.connect(self.toggle_monitoring)

            self.notifications_shortcut = QShortcut(QKeySequence("Ctrl+Alt+N"), self)
            self.notifications_shortcut.activated.connect(self.toggle_notifications)
        except Exception as e:
            logging.error(f"Error in setup_shortcuts: {e}")
            self.show_error_message(f"Error setting up shortcuts: {str(e)}")

    def toggle_monitoring(self):
        try:
            if not self.monitoring:
                self.start_monitoring()
            else:
                self.stop_monitoring()
            self.save_settings()
        except Exception as e:
            logging.error(f"Error in toggle_monitoring: {e}")
            self.show_error_message(f"Error toggling monitoring: {str(e)}")

    def start_monitoring(self):
        try:
            self.monitoring = True
            self.toggle_action.setText("Disable")
            if self.notifications_enabled:
                self.showMessage("TSTP:Auto Continue", "Monitoring enabled.", QSystemTrayIcon.Information)
            logging.info("Monitoring enabled")

            self.monitor_thread = AutoContinueBrowserMonitor(self.interval, self.button_image_path, self.notifications_enabled, self.selected_monitors)
            self.monitor_thread.log_signal.connect(self.log_message)
            self.monitor_thread.notification_signal.connect(self.showMessage)
            self.monitor_thread.error_signal.connect(self.handle_monitor_error)
            self.monitor_thread.start()
        except Exception as e:
            logging.error(f"Error in start_monitoring: {e}")
            self.show_error_message(f"Error starting monitoring: {str(e)}")

    def stop_monitoring(self):
        try:
            self.monitoring = False
            self.toggle_action.setText("Enable")
            if self.notifications_enabled:
                self.showMessage("TSTP:Auto Continue", "Monitoring disabled.", QSystemTrayIcon.Information)
            logging.info("Monitoring disabled")
            if self.monitor_thread:
                self.monitor_thread.stop()
                self.monitor_thread.wait()
        except Exception as e:
            logging.error(f"Error in stop_monitoring: {e}")
            self.show_error_message(f"Error stopping monitoring: {str(e)}")

    def handle_monitor_error(self, error_message):
        logging.error(f"Monitor thread error: {error_message}")
        self.show_error_message(f"Monitoring error: {error_message}")
        self.stop_monitoring()
        self.toggle_action.setText("Enable")

    def check_monitoring_status(self):
        try:
            if self.monitoring and (not self.monitor_thread or not self.monitor_thread.isRunning()):
                logging.warning("Monitoring thread stopped unexpectedly. Restarting...")
                self.stop_monitoring()
                self.start_monitoring()
        except Exception as e:
            logging.error(f"Error in check_monitoring_status: {e}")

    def show_error_message(self, message):
        logging.error(message)
        self.showMessage("TSTP:Auto Continue Error", message, QSystemTrayIcon.Critical)

    def toggle_notifications(self):
        try:
            self.notifications_enabled = not self.notifications_enabled
            self.notification_action.setText("Disable Notifications" if self.notifications_enabled else "Enable Notifications")
            logging.info(f"Notifications {'enabled' if self.notifications_enabled else 'disabled'}")
            self.save_settings()
        except Exception as e:
            logging.error(f"Error in toggle_notifications: {e}")
            self.show_error_message(f"Error toggling notifications: {str(e)}")

    def set_interval(self):
        try:
            interval, ok = QInputDialog.getInt(None, "Set Interval", "Enter interval (seconds):", self.interval, 1, 60, 1)
            if ok:
                self.interval = interval
                self.save_settings()
                if self.notifications_enabled:
                    self.showMessage("TSTP:Auto Continue", f"Interval set to {self.interval} seconds.", QSystemTrayIcon.Information)
                logging.info(f"Interval set to {self.interval} seconds")
        except Exception as e:
            logging.error(f"Error in set_interval: {e}")
            self.show_error_message(f"Error setting interval: {str(e)}")

    def select_monitors(self):
        try:
            dialog = AutoContinueMonitorSelectionWindow(self.selected_monitors)
            if dialog.exec_():
                self.save_settings()
                if self.notifications_enabled:
                    self.showMessage("TSTP:Auto Continue", "Monitor selection updated.", QSystemTrayIcon.Information)
                logging.info("Monitor selection updated")
        except Exception as e:
            logging.error(f"Error in select_monitors: {e}")
            self.show_error_message(f"Error selecting monitors: {str(e)}")

    def log_message(self, message):
        try:
            logging.info(message)
        except Exception as e:
            logging.error(f"Error in log_message: {e}")

    def show_log_window(self):
        try:
            if not self.log_window:
                self.log_window = AutoContinueLogWindow()
            self.log_window.show()
        except Exception as e:
            logging.error(f"Error in show_log_window: {e}")

    def show_info_window(self, title, content):
        try:
            info_window = AutoContinueInfoWindow(title, content)
            info_window.exec_()
        except Exception as e:
            logging.error(f"Error in show_info_window: {e}")

    def show_donate_window(self):
        try:
            donate_window = AutoContinueDonateWindow()
            donate_window.exec_()
        except Exception as e:
            logging.error(f"Error in show_donate_window: {e}")

    def show_tutorial_window(self):
        try:
            tutorial_window = AutoContinueTutorialWindow()
            tutorial_window.exec_()
        except Exception as e:
            logging.error(f"Error in show_tutorial_window: {e}")

    def exit_app(self):
        try:
            self.monitoring = False
            if self.monitor_thread:
                self.monitor_thread.stop()
                self.monitor_thread.wait()
            logging.info("AutoContinueApp exited")
            self.save_settings()
            self.hide()  # Hide the system tray icon
            AutoContinueApp.tray_icon_created = False  # Reset the flag
        except Exception as e:
            logging.error(f"Error in exit_app: {e}")

    def load_settings(self):
        try:
            if os.path.exists(self.settings_file):
                with open(self.settings_file, 'r') as f:
                    settings = json.load(f)
                    self.interval = settings.get('interval', 5)
                    self.notifications_enabled = settings.get('notifications_enabled', True)
                    self.selected_monitors = settings.get('selected_monitors', [-1])
        except Exception as e:
            logging.error(f"Error in load_settings: {e}")

    def save_settings(self):
        try:
            settings = {
                'interval': self.interval,
                'notifications_enabled': self.notifications_enabled,
                'selected_monitors': self.selected_monitors
            }
            with open(self.settings_file, 'w') as f:
                json.dump(settings, f)
        except Exception as e:
            logging.error(f"Error in save_settings: {e}")

class AutoContinueTutorialWindow(QDialog):
    def __init__(self, parent=None):
        super(AutoContinueTutorialWindow, self).__init__(parent)
        self.setWindowTitle("Interactive Tutorial")
        self.setGeometry(100, 100, 800, 600)
        self.setWindowModality(Qt.ApplicationModal)

        self.layout = QVBoxLayout()

        self.webView = QWebEngineView()
        self.layout.addWidget(self.webView)

        self.navigation_layout = QHBoxLayout()

        self.home_button = QPushButton("Home")
        self.home_button.clicked.connect(self.go_to_home_page)
        self.navigation_layout.addWidget(self.home_button)

        self.back_button = QPushButton("Previous")
        self.back_button.clicked.connect(self.go_to_previous_page)
        self.navigation_layout.addWidget(self.back_button)

        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.navigation_layout.addWidget(self.progress_bar)

        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.go_to_next_page)
        self.navigation_layout.addWidget(self.next_button)

        self.start_button = QPushButton("Start Using App")
        self.start_button.clicked.connect(self.close)
        self.navigation_layout.addWidget(self.start_button)

        self.layout.addLayout(self.navigation_layout)
        self.setLayout(self.layout)

        self.current_page_index = 0
        self.page_history = [self.current_page_index]
        self.tutorial_pages = [
            self.create_index_page(),
            self.create_intro_page(),
            self.create_features_page(),
            self.create_usage_page(),
            self.create_shortcuts_page(),
        ]

        self.load_tutorial_page(self.current_page_index)

        self.channel = QWebChannel()
        self.webView.page().setWebChannel(self.channel)
        self.channel.registerObject("qt", self)

    @pyqtSlot()
    def on_load_finished(self):
        self.webView.page().runJavaScript("""
            new QWebChannel(qt.webChannelTransport, function(channel) {
                window.tutorial = channel.objects.qt;
            });
        """)

    @pyqtSlot(int)
    def jupyterloadPage(self, index):
        try:
            self.load_tutorial_page(index)
        except Exception as e:
            self.log_error(f"Error loading tutorial page {index}: " + str(e))

    def load_tutorial_page(self, index):
        try:
            self.log_debug(f"Loading tutorial page {index}")
            self.current_page_index = index
            self.webView.setHtml(self.tutorial_pages[index])
            self.progress_bar.setValue(int((index + 1) / len(self.tutorial_pages) * 100))
        except Exception as e:
            self.log_error(f"Error loading tutorial page {index}: " + str(e))

    def go_to_home_page(self):
        try:
            self.load_tutorial_page(0)
            self.page_history = [0]
        except Exception as e:
            self.log_error("Error navigating to home page: " + str(e))

    def go_to_previous_page(self):
        try:
            if len(self.page_history) > 1:
                self.page_history.pop()  # Remove current page from history
                previous_page = self.page_history.pop()  # Get previous page
                self.load_tutorial_page(previous_page)
                self.page_history.append(previous_page)  # Re-add previous page
        except Exception as e:
            self.log_error("Error navigating to previous page: " + str(e))

    def go_to_next_page(self):
        try:
            if self.current_page_index < len(self.tutorial_pages) - 1:
                next_page = self.current_page_index + 1
                self.load_tutorial_page(next_page)
                self.page_history.append(next_page)
        except Exception as e:
            self.log_error("Error navigating to next page: " + str(e))

    def log_error(self, message):
        print("ERROR: " + message)

    def log_debug(self, message):
        print("DEBUG: " + message)

    def create_index_page(self):
        try:
            return """
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; }
                    h1 { color: #333; }
                    p { font-size: 14px; }
                    .button-container {
                        display: flex;
                        flex-direction: column;
                        align-items: flex-start;
                    }
                    .tutorial-button {
                        margin: 5px 0;
                        padding: 10px;
                        background-color: #007BFF;
                        color: white;
                        border: none;
                        cursor: pointer;
                        width: 100%;
                        text-align: left;
                        box-sizing: border-box;
                    }
                    .tutorial-button:hover {
                        background-color: #0056b3;
                    }
                </style>
                <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
                <script>
                    document.addEventListener("DOMContentLoaded", function() {
                        new QWebChannel(qt.webChannelTransport, function(channel) {
                            window.tutorial = {
                                loadPage: function(index) {
                                    channel.objects.qt.jupyterloadPage(index);
                                }
                            };
                        });
                    });
                </script>
            </head>
            <body>
                <h1>Welcome to TSTP:Auto Continue Tutorial</h1>
                <p>This tutorial will guide you through the features and usage of the Auto-Continue program.</p>
                <div class="button-container">
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(1)">Introduction</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(2)">Features</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(3)">How to Use</button>
                    <button class="tutorial-button" onclick="window.tutorial.loadPage(4)">Shortcuts</button>
                </div>
            </body>
            </html>
            """
        except Exception as e:
            self.log_error("Error creating index page: " + str(e))
            return ""

    def create_intro_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h1>Introduction</h1>
            <p>The Auto-Continue program is designed to automatically click the "Continue generation" button on ChatGPT.com when the response ends but there is more to display. This helps you avoid interruptions and ensures continuous generation of responses.</p>
        </body>
        </html>
        """

    def create_features_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h1>Features</h1>
            <ul>
                <li>Automatic detection and clicking of the "Continue generation" button on ChatGPT.com</li>
                <li>Supports multiple monitors</li>
                <li>Configurable monitoring interval</li>
                <li>Enable/disable notifications</li>
                <li>View logs for monitoring activities</li>
                <li>Global keyboard shortcuts for quick actions</li>
                <li>System tray icon for easy access to features and settings</li>
            </ul>
        </body>
        </html>
        """

    def create_usage_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h1>How to Use</h1>
            <ol>
                <li>Launch the Auto-Continue program. It will minimize to the system tray.</li>
                <li>Right-click the system tray icon to access the menu.</li>
                <li>Enable monitoring by selecting "Enable". The program will start detecting and clicking the "Continue generation" button on ChatGPT.com.</li>
                <li>Configure the monitoring interval by selecting "Set Interval". Enter the desired interval in seconds.</li>
                <li>Select specific monitors for monitoring by choosing "Select Monitors".</li>
                <li>View logs for monitoring activities by selecting "Show Log".</li>
                <li>Enable or disable notifications through the "Disable Notifications" option.</li>
            </ol>
        </body>
        </html>
        """

    def create_shortcuts_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h1>Shortcuts</h1>
            <p>Use the following keyboard shortcuts for quick actions:</p>
            <ul>
                <li><strong>Ctrl + Alt + E:</strong> Enable/Disable monitoring</li>
                <li><strong>Ctrl + Alt + N:</strong> Enable/Disable notifications</li>
            </ul>
        </body>
        </html>
        """

################################ AUTO CONTINUE END ##############################

################################ FTP MANAGER START ##############################

master_db_file = "C:\\TSTP\\FTPManager\\DB\\ftp.db"
program_save_folder = "C:\\TSTP\\OmniOmega\\Logs\\FTP\\"
notification_db = "C:\\TSTP\\FTPManager\\DB\\notification_filters.db"

class FTPManagerFTPApp(QtWidgets.QMainWindow):
    _instance_visible = False

    def __init__(self, parent=None):
        if FTPManagerFTPApp._instance_visible:
            self.raise_()
            self.activateWindow()
            return

        super().__init__()
        self.setWindowFlags(Qt.Window)
        self.create_database()
        self.setup_logging()
        self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))        
        self.notifications_enabled = True
        self.active_connections = {}
        self.initUI()
        self.observers = {}
        self.ftp_connections = {}

        if parent:
            self.setStyleSheet(parent.styleSheet())
            parent.themeChanged.connect(self.updateStyleSheet)

        FTPManagerFTPApp._instance_visible = True
        self.init_tray_icon()

    def closeEvent(self, event):
        FTPManagerFTPApp._instance_visible = False
        if self.tray_icon:
            self.tray_icon.hide()
            self.tray_icon = None
        event.accept()

    def initUI(self):
        self.setWindowTitle('TSTP:FTP Manager')
        self.resize(800, 600)

        self.central_widget = QtWidgets.QWidget()
        self.setCentralWidget(self.central_widget)

        self.tabs = QtWidgets.QTabWidget()
        self.tabs.setTabsClosable(True)
        self.tabs.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.tabs.customContextMenuRequested.connect(self.show_tab_context_menu)
        self.tabs.tabCloseRequested.connect(self.close_tab)

        self.menu_bar = self.menuBar()

        # File menu
        file_menu = self.menu_bar.addMenu('File')
        new_tab_action = QtWidgets.QAction('New Tab', self)
        new_tab_action.triggered.connect(self.add_new_tab)
        close_tab_action = QtWidgets.QAction('Close Tab', self)
        close_tab_action.triggered.connect(self.close_current_tab)
        close_all_tabs_action = QtWidgets.QAction('Close All Tabs', self)
        close_all_tabs_action.triggered.connect(self.close_all_tabs)
        file_menu.addAction(new_tab_action)
        file_menu.addAction(close_tab_action)
        file_menu.addAction(close_all_tabs_action)

        # View menu
        view_menu = self.menu_bar.addMenu('View')
        credential_manager_action = QtWidgets.QAction('Credential Manager', self)
        credential_manager_action.triggered.connect(self.show_credentials_manager)
        folder_manager_action = QtWidgets.QAction('Folder Manager', self)
        folder_manager_action.triggered.connect(self.show_folder_manager)
        open_ftp_manager_action = QtWidgets.QAction('FTP Manager', self)
        open_ftp_manager_action.triggered.connect(self.open_ftp_manager)
        open_notification_manager_action = QtWidgets.QAction('Notification Manager', self)
        open_notification_manager_action.triggered.connect(self.show_notification_manager)        
        view_menu.addAction(open_ftp_manager_action)
        view_menu.addAction(credential_manager_action)
        view_menu.addAction(folder_manager_action)
        view_menu.addAction(open_notification_manager_action)

        # Help menu
        help_menu = self.menu_bar.addMenu('Help')
        about_action = QtWidgets.QAction('About', self)
        about_action.triggered.connect(self.show_about_dialog)
        donate_action = QtWidgets.QAction('Donate', self)
        donate_action.triggered.connect(self.show_donate_dialog)
        tutorial_action = QtWidgets.QAction('Tutorial', self)
        tutorial_action.triggered.connect(self.show_tutorial_dialog)
        help_menu.addAction(about_action)
        help_menu.addAction(donate_action)
        help_menu.addAction(tutorial_action)

        main_layout = QtWidgets.QVBoxLayout(self.central_widget)
        main_layout.addWidget(self.tabs)

        # Connect the "New Tab" button
        new_tab_button = QtWidgets.QPushButton("+")
        new_tab_button.clicked.connect(self.add_new_tab)
        main_layout.addWidget(new_tab_button)

        self.add_new_tab()

        self.init_tray_icon()
        self.show()

    def show_notification(self, title, message):
        if self.notifications_enabled:
            current_tab = self.tabs.currentWidget()
            if isinstance(current_tab, FTPManagerFTPTab):
                destination, delay = current_tab.notification_filter.apply_filters(message)
                if destination:
                    self.tray_icon.showMessage(title, message, QtGui.QIcon("app_icon.ico"), 5000)
                    if delay > 0:
                        QtCore.QTimer.singleShot(delay * 1000, lambda: self.tray_icon.showMessage(title, message, QtGui.QIcon("app_icon.ico"), 5000))

    def updateStyleSheet(self, styleSheet):
        self.setStyleSheet(styleSheet)

    def init_tray_icon(self):
        if hasattr(self, 'tray_icon_created') and self.tray_icon_created:
            return
        self.tray_icon_created = True

        self.tray_icon = QtWidgets.QSystemTrayIcon(QtGui.QIcon(resource_path("app_icon_fm.ico")), self)
        self.tray_icon.setVisible(True)
        self.tray_menu = QtWidgets.QMenu(self)

        open_action = QtWidgets.QAction("Open", self)
        open_action.triggered.connect(self.show)
        self.tray_menu.addAction(open_action)

        quick_connect_menu = self.tray_menu.addMenu("Quick Connect")
        self.populate_quick_connect_menu(quick_connect_menu)

        managers_menu = self.tray_menu.addMenu("Managers")

        quick_connect_manager_action = QtWidgets.QAction("Quick Connect Manager", self)
        quick_connect_manager_action.triggered.connect(self.show_quick_connect_manager)
        managers_menu.addAction(quick_connect_manager_action)

        folder_manager_action = QtWidgets.QAction("Folder Manager", self)
        folder_manager_action.triggered.connect(self.show_folder_manager)
        managers_menu.addAction(folder_manager_action)

        credential_manager_action = QtWidgets.QAction("Credential Manager", self)
        credential_manager_action.triggered.connect(self.show_credentials_manager)
        managers_menu.addAction(credential_manager_action)

        self.toggle_notifications_action = QtWidgets.QAction("Toggle Notifications", self)
        self.toggle_notifications_action.triggered.connect(self.toggle_notifications)
        self.tray_menu.addAction(self.toggle_notifications_action)

        self.show_notifications_action = QtWidgets.QAction("Notification Manager", self)
        self.show_notifications_action.triggered.connect(self.show_notification_manager)
        self.tray_menu.addAction(self.show_notifications_action)

        self.quit_action = QtWidgets.QAction("Quit", self)
        self.quit_action.triggered.connect(self.hide)
        self.tray_menu.addAction(self.quit_action)

        self.tray_icon.setContextMenu(self.tray_menu)
        self.tray_icon.activated.connect(self.on_tray_icon_activated)

    def setup_logging(self):
        log_folder = os.path.join(program_save_folder, 'logs')
        if not os.path.exists(log_folder):
            os.makedirs(log_folder)
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        file_handler = logging.FileHandler(os.path.join(log_folder, 'ftp_manager.log'))
        file_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)

    def log(self, message):
        self.logger.info(message)
        current_tab = self.tabs.currentWidget()
        if isinstance(current_tab, FTPManagerFTPTab):
            current_tab.log_area.append(message)

    def show_credentials_manager(self):
        self.credentials_manager = FTPManagerCredentialsManager(self)
        self.credentials_manager.show()

    def show_notification_manager(self):
        self.notification_manager = FTPManagerNotificationFilter(self)
        self.notification_manager.show()
        
    def show_folder_manager(self):
        self.folder_manager = FTPManagerFolderManager(self)
        self.folder_manager.show()

    def show_quick_connect_manager(self):
        self.quick_connect_manager = FTPManagerQuickConnectManager(self)
        self.quick_connect_manager.show()

    def add_new_tab(self):
        tab = FTPManagerFTPTab(self, log_func=self.log, notifications_enabled=self.notifications_enabled)
        tab.notification_filter = FTPManagerNotificationFilter(tab)
        tab.load_quick_connects()
        tab.session_name = f"Session {self.tabs.count() + 1}"
        self.tabs.addTab(tab, tab.session_name)
        self.tabs.setCurrentWidget(tab)
        tab.log_signal.connect(self.update_log_from_tab)
        tab.tray_notification_signal.connect(self.show_notification)

        tab.tray_notification_signal.connect(self.show_notification)
        
    def rename_tab(self, index):
        current_tab = self.tabs.widget(index)
        if isinstance(current_tab, FTPManagerFTPTab):
            current_tab_name = current_tab.session_name
            new_tab_name, ok = QtWidgets.QInputDialog.getText(self, "Rename Tab", "Enter new tab name:", text=current_tab_name)
            if ok and new_tab_name:
                self.tabs.setTabText(index, new_tab_name)
                current_tab.session_name = new_tab_name

    def close_tab(self, index):
        self.tabs.removeTab(index)

    def close_current_tab(self):
        self.close_tab(self.tabs.currentIndex())

    def close_all_tabs(self):
        while self.tabs.count():
            self.close_tab(0)

    def show_about_dialog(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("About")
        dialog.setFixedSize(400, 300)

        layout = QVBoxLayout()

        message = QLabel("This is an FTP application that not only works like a normal FTP client but also allows you to set an observer on a folder so that you can upload files as soon as a change is detected.\n\nFor more information, check out the Tutorial in the Help menu.\n\nFor support, email us at Support@TSTP.xyz.\n\nThank you for your support and for downloading TSTP:FTP Manager!")
        message.setWordWrap(True)
        message.setAlignment(Qt.AlignCenter)
    
        layout.addWidget(message)
    
        button_layout = QHBoxLayout()
    
        btn_yes = QPushButton("Yes")
        btn_yes.clicked.connect(lambda: QtGui.QDesktopServices.openUrl(QUrl("https://tstp.xyz/programs/ftp-manager/")))
    
        btn_ok = QPushButton("OK")
        btn_ok.clicked.connect(dialog.close)
    
        button_layout.addWidget(btn_yes)
        button_layout.addWidget(btn_ok)
    
        layout.addLayout(button_layout)
    
        dialog.setLayout(layout)
        dialog.exec_()

    def show_donate_dialog(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("Donate")
        dialog.setFixedSize(400, 200)

        layout = QVBoxLayout()

        message = QLabel("Thank you for considering a donation!\n\nYou do not have to donate, as this program is free and we will continue to provide free programs and projects for the public, but your donation is greatly appreciated if you still choose to.\n\nThank you for supporting us by downloading the program!\n\nWe appreciate it over at TSTP.")
        message.setWordWrap(True)
        message.setAlignment(Qt.AlignCenter)
    
        layout.addWidget(message)
    
        button_layout = QHBoxLayout()
    
        btn_yes = QPushButton("Yes")
        btn_yes.clicked.connect(lambda: QtGui.QDesktopServices.openUrl(QUrl("https://www.tstp.xyz/donate")))
    
        btn_ok = QPushButton("OK")
        btn_ok.clicked.connect(dialog.close)
    
        button_layout.addWidget(btn_yes)
        button_layout.addWidget(btn_ok)
    
        layout.addLayout(button_layout)
    
        dialog.setLayout(layout)
        dialog.exec_()

    def show_tutorial_dialog(self):
        tutorialWindow = FTPManagerTutorialWindow(self)
        tutorialWindow.show()

    def toggle_credentials_section(self):
        current_tab = self.tabs.currentWidget()
        if isinstance(current_tab, FTPManagerFTPTab):
            current_tab.toggle_credentials_checkbox.toggle()

    def show_credentials_manager(self):
        current_tab = self.tabs.currentWidget()
        if isinstance(current_tab, FTPManagerFTPTab):
            current_tab.show_credentials_manager()

    def show_folder_manager(self):
        self.folder_manager = FTPManagerFolderManager(self)
        self.folder_manager.show()
        self.folder_manager.add_button.clicked.connect(self.update_folder_dropdowns)
            
    def toggle_connection_section(self):
        current_tab = self.tabs.currentWidget()
        if isinstance(current_tab, FTPManagerFTPTab):
            current_tab.toggle_connection_checkbox.toggle()
            
    def toggle_folder_section(self):
        current_tab = self.tabs.currentWidget()
        if isinstance(current_tab, FTPManagerFTPTab):
            current_tab.toggle_folder_checkbox.toggle()
            
    def update_folder_dropdowns(self):
        for i in range(self.tabs.count()):
            tab = self.tabs.widget(i)
            if isinstance(tab, FTPManagerFTPTab):
                tab.load_folders()
            
    def toggle_log_section(self):
        current_tab = self.tabs.currentWidget()
        if isinstance(current_tab, FTPManagerFTPTab):
            current_tab.toggle_log_checkbox.toggle()

    def create_database(self):
        db_file = master_db_file
        db_dir = os.path.dirname(db_file)
    
        # Create the directory if it doesn't exist
        if not os.path.exists(db_dir):
            os.makedirs(db_dir)
    
        if os.path.exists(db_file):
            try:
                conn = sqlite3.connect(db_file)
                c = conn.cursor()
                c.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='credentials'")
                if not c.fetchone():
                    # Credentials table doesn't exist, create a backup
                    backup_file = f'ftp_backup_{datetime.now().strftime("%Y%m%d%H%M%S")}.db'
                    os.rename(db_file, backup_file)
                    self.logger.info(f'Created backup: {backup_file}')
            except sqlite3.OperationalError:
                # Database file is corrupted, create a backup
                backup_file = f'ftp_backup_{datetime.now().strftime("%Y%m%d%H%M%S")}.db'
                os.rename(db_file, backup_file)
                self.logger.info(f'Created backup: {backup_file}')
            finally:
                conn.close()
        else:
            # Database file does not exist, create it
            with open(db_file, 'w'):
                pass

        conn = sqlite3.connect(db_file)
        c = conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS credentials (
                id INTEGER PRIMARY KEY,
                host TEXT NOT NULL,
                username TEXT NOT NULL,
                password TEXT NOT NULL
            )
        ''')
        c.execute('''
            CREATE TABLE IF NOT EXISTS folders (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                remote_path TEXT NOT NULL,
                local_path TEXT NOT NULL
            )
        ''')
        c.execute('''
            CREATE TABLE IF NOT EXISTS quick_connects (
                id INTEGER PRIMARY KEY,
                host TEXT NOT NULL,
                username TEXT NOT NULL,
                password TEXT NOT NULL,
                local_folder TEXT NOT NULL,
                remote_folder TEXT NOT NULL
            )
        ''')
        conn.commit()
        conn.close()

    def setup_logging(self):
        if not os.path.exists('logs'):
            os.makedirs('logs')
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        file_handler = logging.FileHandler('logs/ftp_manager.log')
        file_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)
        
    def toggle_notifications(self):
        self.notifications_enabled = not self.notifications_enabled
        status = "enabled" if self.notifications_enabled else "disabled"
        self.log(f"Notifications have been {status}.")
        self.show_notification("Notifications", f"Notifications have been {status}.")

    def populate_quick_connect_menu(self, quick_connect_menu):
        conn = sqlite3.connect(master_db_file)
        c = conn.cursor()
        c.execute('SELECT id, username, host FROM quick_connects')
        rows = c.fetchall()
        conn.close()

        for row in rows:
            quick_connect_id, username, host = row
            action_text = f"{username}@{host}"
            
            if quick_connect_id in self.active_connections:
                sub_menu = quick_connect_menu.addMenu(action_text)
                disconnect_action = QtWidgets.QAction("Disconnect", self)
                disconnect_action.triggered.connect(lambda checked, q_id=quick_connect_id: self.disconnect_from_tray(q_id))
                sub_menu.addAction(disconnect_action)
                
                disconnect_close_action = QtWidgets.QAction("Disconnect and Close Tab", self)
                disconnect_close_action.triggered.connect(lambda checked, q_id=quick_connect_id: self.disconnect_and_close_tab_from_tray(q_id))
                sub_menu.addAction(disconnect_close_action)
            else:
                connect_action = QtWidgets.QAction(action_text, self)
                connect_action.triggered.connect(lambda checked, q_id=quick_connect_id: self.quick_connect_from_tray(q_id))
                quick_connect_menu.addAction(connect_action)

    def quick_connect_from_tray(self, quick_connect_id):
        try:
            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            c.execute('SELECT username, host, password, local_folder, remote_folder FROM quick_connects WHERE id=?', (quick_connect_id,))
            row = c.fetchone()
            conn.close()

            if row:
                username, host, password, local_folder, remote_folder = row
                existing_tab = self.find_existing_quick_connect_tab(username, host, local_folder, remote_folder)
                if existing_tab:
                    self.tabs.setCurrentWidget(existing_tab)
                else:
                    new_tab = self.add_new_tab_from_tray(username, host, password, local_folder, remote_folder)
                    if new_tab:
                        self.active_connections[quick_connect_id] = new_tab
                self.update_tray_icon()  # Update the existing tray icon
                self.show()
        except Exception as e:
            self.log(f"Error in quick_connect_from_tray: {e}")

    def find_existing_quick_connect_tab(self, username, host, local_folder, remote_folder):
        for i in range(self.tabs.count()):
            tab = self.tabs.widget(i)
            if isinstance(tab, FTPManagerFTPTab):
                if (tab.username == username and tab.host == host and
                    tab.local_folder == local_folder and tab.remote_folder == remote_folder):
                    return tab
        return None

    def add_new_tab_from_tray(self, username, host, password, local_folder, remote_folder):
        try:
            new_tab = FTPManagerFTPTab(self)
            new_tab.username = username
            new_tab.host = host
            new_tab.password = password
            new_tab.local_folder = local_folder
            new_tab.remote_folder = remote_folder
            new_tab.saved_credentials_dropdown.addItem(f"{username}@@{host}")
            new_tab.local_folder_view.headerItem().setText(0, local_folder)
            new_tab.folder_tree.headerItem().setText(0, remote_folder)

            self.tabs.addTab(new_tab, f"{username}@{host}")
            self.tabs.setCurrentWidget(new_tab)
            quick_connect_info = f"{username}@{host} | {local_folder} | {remote_folder}"
            new_tab.quick_connect_dropdown.addItem(quick_connect_info)
            new_tab.quick_connect_dropdown.setCurrentText(quick_connect_info)
            new_tab.quick_connect()

            return new_tab
        except Exception as e:
            error_message = f"Unexpected error: {e}"
            self.log(error_message)
            return None

    def disconnect_from_tray(self, quick_connect_id):
        try:
            if quick_connect_id in self.active_connections:
                tab = self.active_connections[quick_connect_id]
                tab.stop_monitoring()
                if tab.ftp:
                    tab.ftp.quit()
                del self.active_connections[quick_connect_id]
                self.update_tray_icon()  # Update the existing tray icon
            else:
                self.log(f"No active FTP connection to disconnect for ID: {quick_connect_id}")
        except Exception as e:
            self.log(f"Error disconnecting from tray: {e}")

    def disconnect_and_close_tab_from_tray(self, quick_connect_id):
        try:
            if quick_connect_id in self.active_connections:
                tab = self.active_connections[quick_connect_id]
                tab.stop_monitoring()
                if tab.ftp:
                    tab.ftp.quit()
                self.close_tab(self.tabs.indexOf(tab))
                del self.active_connections[quick_connect_id]
                self.update_tray_icon()  # Update the existing tray icon
            else:
                self.log(f"No active FTP connection to disconnect and close for ID: {quick_connect_id}")
        except Exception as e:
            self.log(f"Error disconnecting and closing tab from tray: {e}")

    def on_tray_icon_activated(self, reason):
        if reason == QtWidgets.QSystemTrayIcon.Trigger:
            self.show()

    def show_tab_context_menu(self, position):
        tab_index = self.tabs.tabBar().tabAt(position)
        if tab_index != -1:
            context_menu = QtWidgets.QMenu(self)
            rename_action = context_menu.addAction("Rename Tab")
            action = context_menu.exec_(self.tabs.mapToGlobal(position))
            if action == rename_action:
                self.rename_tab(tab_index)
            
    def open_ftp_manager(self):
        if not hasattr(self, 'ftp_manager_window') or self.ftp_manager_window is None:
            self.ftp_manager_window = FTPManagerFTPManagerWindow(self)
        self.ftp_manager_window.show()
        self.populate_sessions_dropdown()

    def populate_sessions_dropdown(self):
        self.ftp_manager_window.session_dropdown.clear()
        for i in range(self.tabs.count()):
            tab = self.tabs.widget(i)
            if isinstance(tab, FTPManagerFTPTab):
                session_name = tab.session_name
                if tab.is_connected():
                    self.ftp_manager_window.session_dropdown.addItem(session_name)
                else:
                    self.ftp_manager_window.session_dropdown.addItem(f"{session_name} (Disconnected)")
               
    def is_session_connected(self, session_name):
        """ Check if a session is connected """
        try:
            self.log(f"Checking connection status for session: {session_name}")
            connected = session_name in self.ftp_connections and self.ftp_connections[session_name].sock is not None
            self.log(f"Connection status for session {session_name}: {'Connected' if connected else 'Not Connected'}")
            return connected
        except Exception as e:
            self.log(f"Error checking connection status for session {session_name}: {e}")
            return False

    def get_ftp_connection(self, session_name):
        """ Get the FTP connection for a given session """
        try:
            self.log(f"Retrieving FTP connection for session: {session_name}")
            for i in range(self.tabs.count()):
                tab = self.tabs.widget(i)
                if isinstance(tab, FTPManagerFTPTab) and tab.session_name == session_name:
                    self.log(f"FTP connection found for session: {session_name}")
                    return tab.ftp
            self.log(f"No FTP connection found for session: {session_name}")
            return None
        except Exception as e:
            self.log(f"Error retrieving FTP connection for session {session_name}: {e}")
            return None
        
    def update_log_from_tab(self, message):
        current_tab = self.tabs.currentWidget()
        if isinstance(current_tab, FTPManagerFTPTab):
            current_tab.update_log(message)
            
    def load_folders(self):
        try:
            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            c.execute('SELECT name FROM folders')
            rows = c.fetchall()
            
            for i in range(self.tabs.count()):
                tab = self.tabs.widget(i)
                if isinstance(tab, FTPManagerFTPTab):
                    tab.folder_manager_dropdown.clear()
                    tab.folder_manager_dropdown.addItem("1 - None")
                    tab.folder_manager_dropdown.addItem("2 - Add Folder")
                    for row in rows:
                        tab.folder_manager_dropdown.addItem(row[0])
            
            conn.close()
        except sqlite3.Error as e:
            self.log(f"Database Error: Failed to load folders: {e}")
        except Exception as e:
            self.log(f"Unexpected error in load_folders: {e}")

    def new_tab_from_quick_connect(self, quick_connect_info):
        try:
            parts = quick_connect_info.split(' | ')
            if len(parts) != 3:
                raise ValueError(f"Invalid quick connect format. Expected format: 'username@host | local_folder | remote_folder', got: {quick_connect_info}")

            username_host, local_folder, remote_folder = parts
            username, host = username_host.rsplit('@', 1)

            new_tab = FTPManagerFTPTab(self)
            new_tab.username = username
            new_tab.host = host
            new_tab.local_folder = local_folder
            new_tab.remote_folder = remote_folder
            new_tab.saved_credentials_dropdown.addItem(f"{username}@@{host}")
            new_tab.local_folder_view.headerItem().setText(0, local_folder)
            new_tab.folder_tree.headerItem().setText(0, remote_folder)

            self.tabs.addTab(new_tab, f"{username}@{host}")
            self.tabs.setCurrentWidget(new_tab)
            new_tab.quick_connect_dropdown.addItem(quick_connect_info)
            new_tab.quick_connect_dropdown.setCurrentText(quick_connect_info)
            new_tab.quick_connect()

            return new_tab
        except Exception as e:
            error_message = f"Unexpected error: {e}"
            self.log(error_message)
            if debug_mode:
                print(f"{error_message}\nQuick connect info: {quick_connect_info}")
            else:
                QtWidgets.QMessageBox.critical(self, "Quick Connect Error", error_message)

    def update_tray_icon(self):
        self.tray_menu.clear()
        
        open_action = QtWidgets.QAction("Open", self)
        open_action.triggered.connect(self.show)
        self.tray_menu.addAction(open_action)

        quick_connect_menu = self.tray_menu.addMenu("Quick Connect")
        self.populate_quick_connect_menu(quick_connect_menu)

        # Add other menu items (Managers, Toggle Notifications, etc.) here
        managers_menu = self.tray_menu.addMenu("Managers")
        
        quick_connect_manager_action = QtWidgets.QAction("Quick Connect Manager", self)
        quick_connect_manager_action.triggered.connect(self.show_quick_connect_manager)
        managers_menu.addAction(quick_connect_manager_action)
        
        folder_manager_action = QtWidgets.QAction("Folder Manager", self)
        folder_manager_action.triggered.connect(self.show_folder_manager)
        managers_menu.addAction(folder_manager_action)
        
        credential_manager_action = QtWidgets.QAction("Credential Manager", self)
        credential_manager_action.triggered.connect(self.show_credentials_manager)
        managers_menu.addAction(credential_manager_action)

        self.toggle_notifications_action = QtWidgets.QAction("Toggle Notifications", self)
        self.toggle_notifications_action.triggered.connect(self.toggle_notifications)
        self.tray_menu.addAction(self.toggle_notifications_action)

        self.quit_action = QtWidgets.QAction("Quit", self)
        self.quit_action.triggered.connect(QtWidgets.qApp.quit)
        self.tray_menu.addAction(self.quit_action)

        self.tray_icon.setContextMenu(self.tray_menu)

class FTPManagerFTPTab(QtWidgets.QWidget):
    log_signal = QtCore.pyqtSignal(str)
    tray_notification_signal = QtCore.pyqtSignal(str, str)  # Title, Message
    log_message_signal = QtCore.pyqtSignal(str)

    def __init__(self, parent=None, log_func=None, notifications_enabled=True):
        super().__init__(parent)
        self.initUI()
        self.observers = {}
        self.ftp_connections = {}
        self.log_func = log_func
        self.notifications_enabled = notifications_enabled
        self.notification_filter = FTPManagerNotificationFilter(self)
        self.ftp = None
        self.local_path = ""
        self.remote_path = ""
        self.username = ""
        self.host = ""
        self.local_folder = ""
        self.remote_folder = ""
        self.password = ""
        self.overwrite_confirmed = False
        self.quickconnect_in_use = False
        self.session_name = "New Connection"  # Default session name
        self.last_log_time = None
        self.last_log_message = None
        self.log_signal.connect(self.log)
        self.log_message_signal.connect(self.handle_log_message)
        #self.tray_notification_signal.connect(self.log)
        self.tray_notification_signal.connect(self.parent().show_notification)
        self.notification_filter = FTPManagerNotificationFilter(self, log_func=self.log_func)

    def update_log(self, message):
        #print(message)
        pass

    def is_connected(self):
        return self.ftp is not None and self.ftp.sock is not None

    def connect_ftp(self):
        try:
            if self.connect_button.text() == 'Connect':
                self.connect_button.setText('Connecting...')
                self.log(f"Initiating connection process for session: {self.session_name}")
                QtCore.QTimer.singleShot(0, self._connect_ftp_thread)
            else:
                self.log(f"Disconnecting session: {self.session_name}")
                self.stop_monitoring()
                self.ftp.quit()
                self.ftp_connections = {}
                self.connect_button.setText('Connect')
                self.quick_connect_now_button.setText('Quick Connect Now')
        except Exception as e:
            self.log(f"Error in connect_ftp: {e}", "Connection Error")

    def _connect_ftp_thread(self):
        try:
            selected_credential = self.saved_credentials_dropdown.currentText().strip()
            if selected_credential:
                try:
                    username, host = selected_credential.split('@@')
                except ValueError:
                    self.log("Error: Invalid credential format.", "Connection Error")
                    self.connect_button.setText('Connect')
                    return
            else:
                self.log("Error: No credential selected.", "Connection Error")
                self.connect_button.setText('Connect')
                return

            password = self.get_password(host, username)
            if password is None:
                self.log(f"Error: No password found for host {host} and username {username}.", "Connection Error")
                self.connect_button.setText('Connect')
                return

            self.log(f"Connecting to FTP server at {host} with username {username}")
            self.ftp = self.connect_with_retry(host, username, password)
            self.log(f"Connected and logged in to FTP server: {host}")

            # Store the connection in the parent
            parent_app = self.get_parent_app()
            if parent_app:
                parent_app.ftp_connections[self.session_name] = self.ftp
                self.log(f"Stored FTP connection for session: {self.session_name}")

                # Update the tab name to reflect the session
                parent_app.tabs.setTabText(parent_app.tabs.indexOf(self), self.session_name)

            self.connect_button.setText('Disconnect')
            self.quick_connect_now_button.setText('Disconnect Now')

            # Start loading folders in a separate thread
            self.start_folder_loading_thread()
        except ftplib.all_errors as e:
            self.log(f"FTP connection error: {e}", "Connection Error")
            self.connect_button.setText('Connect')
        except Exception as e:
            self.log(f"Error in _connect_ftp_thread: {e}", "Connection Error")
            self.connect_button.setText('Connect')

    def get_parent_app(self):
        parent = self.parent()
        while parent and not hasattr(parent, 'ftp_connections'):
            parent = parent.parent()
        return parent

    def log(self, message, title="Notification"):
        try:
            print(message)
            current_time = datetime.now()
            timestamped_message = f"{current_time.strftime('%Y-%m-%d %H:%M:%S')} - {message}"
            destination, delay = self.notification_filter.apply_filters(timestamped_message)
            if destination == 'log':
                self.log_area.append(timestamped_message)
            elif destination == 'notification':
                self.tray_notification_signal.emit(title, timestamped_message)
            elif destination == 'both':
                self.log_area.append(timestamped_message)
                self.tray_notification_signal.emit(title, timestamped_message)
        except Exception as e:
            print(f"Error in log method: {e}")

    def handle_log_message(self, message):
        if self.log_func:
            self.log_func(message)

    def initUI(self):
        layout = QtWidgets.QVBoxLayout(self)

        # Connections & Credentials Section
        self.toggle_connection_credentials_checkbox = QtWidgets.QCheckBox('Connections and Credentials')
        self.toggle_connection_credentials_checkbox.setChecked(True)
        self.toggle_connection_credentials_checkbox.toggled.connect(self.toggle_connection_credentials_section)

        self.connection_credentials_section = QtWidgets.QWidget()

        # Credentials Section (Left Column)
        self.host_label = QtWidgets.QLabel('Host:', self)
        self.host_input = QtWidgets.QLineEdit(self)

        self.username_label = QtWidgets.QLabel('Username:', self)
        self.username_input = QtWidgets.QLineEdit(self)

        self.password_label = QtWidgets.QLabel('Password:', self)
        self.password_input = QtWidgets.QLineEdit(self)
        self.password_input.setEchoMode(QtWidgets.QLineEdit.Password)

        self.save_button = QtWidgets.QPushButton('Save Credentials', self)
        self.save_button.clicked.connect(self.save_credentials)

        credentials_layout = QtWidgets.QVBoxLayout()
        credentials_layout.addWidget(self.host_label)
        credentials_layout.addWidget(self.host_input)
        credentials_layout.addWidget(self.username_label)
        credentials_layout.addWidget(self.username_input)
        credentials_layout.addWidget(self.password_label)
        credentials_layout.addWidget(self.password_input)
        credentials_layout.addWidget(self.save_button)

        credentials_group = QtWidgets.QGroupBox('Credentials')
        credentials_group.setLayout(credentials_layout)

        # Connection Section (Right Column)
        self.quick_connect_dropdown = QtWidgets.QComboBox()
        self.quick_connect_dropdown.setMaximumWidth(1920)
        self.quick_connect_dropdown.setMinimumWidth(20)

        self.new_tab_button_top = QtWidgets.QPushButton("+")
        self.new_tab_button_top.setFixedWidth(30)
        self.new_tab_button_top.setFixedHeight(25)
        self.new_tab_button_top.clicked.connect(self.new_tab_from_quick_connect)

        quick_connect_layout = QtWidgets.QHBoxLayout()
        quick_connect_layout.addWidget(self.quick_connect_dropdown)
        quick_connect_layout.addWidget(self.new_tab_button_top)

        self.connect_button = QtWidgets.QPushButton('Connect')
        self.connect_button.clicked.connect(self.connect_ftp)

        self.saved_credentials_dropdown = QtWidgets.QComboBox()
        self.folder_manager_dropdown = QtWidgets.QComboBox()
        self.folder_manager_dropdown.addItem("1 - None")  # Add "Add Folder" option
        self.folder_manager_dropdown.addItem("2 - Add Folder")
        self.folder_manager_dropdown.currentTextChanged.connect(self.handle_folder_selection)

        self.load_credentials()
        self.load_folders()

        self.save_quick_connect_button = QtWidgets.QPushButton('Save Quick Connect')
        self.save_quick_connect_button.clicked.connect(self.save_quick_connect)

        self.quick_connect_now_button = QtWidgets.QPushButton('Quick Connect Now')
        self.quick_connect_now_button.clicked.connect(self.quick_connect)

        connection_layout = QtWidgets.QVBoxLayout()
        connection_layout.addLayout(quick_connect_layout)
        connection_layout.addWidget(self.connect_button)
        connection_layout.addWidget(self.saved_credentials_dropdown)
        connection_layout.addWidget(self.folder_manager_dropdown)
        connection_layout.addWidget(self.save_quick_connect_button)
        connection_layout.addWidget(self.quick_connect_now_button)

        connection_group = QtWidgets.QGroupBox('Connection')
        connection_group.setLayout(connection_layout)

        # Combine Credentials and Connection Sections
        combined_layout = QtWidgets.QHBoxLayout()
        combined_layout.addWidget(credentials_group)
        combined_layout.addWidget(connection_group)
        combined_layout.setStretch(0, 1)
        combined_layout.setStretch(1, 1)

        connection_credentials_layout = QtWidgets.QVBoxLayout(self.connection_credentials_section)
        connection_credentials_layout.addLayout(combined_layout)

        layout.addWidget(self.toggle_connection_credentials_checkbox)
        layout.addWidget(self.connection_credentials_section)

        # Folder Section
        self.toggle_folder_checkbox = QtWidgets.QCheckBox('Folders')
        self.toggle_folder_checkbox.setChecked(True)
        self.toggle_folder_checkbox.toggled.connect(self.toggle_folder_section)

        self.folder_tree = QtWidgets.QTreeWidget(self)
        self.folder_tree.setHeaderLabel('Remote Folders')
        self.folder_tree.itemDoubleClicked.connect(self.populate_folder)

        self.local_folder_view = QtWidgets.QTreeWidget(self)
        self.local_folder_view.setHeaderLabel('Local Folders')

        folder_layout = QtWidgets.QHBoxLayout()
        folder_layout.addWidget(self.folder_tree)
        folder_layout.addWidget(self.local_folder_view)

        self.folder_section = QtWidgets.QGroupBox('')
        self.folder_section_layout = QtWidgets.QVBoxLayout()
        self.folder_section_layout.addLayout(folder_layout)

        self.monitor_button = QtWidgets.QPushButton('Monitor Selected Folder', self)
        self.monitor_button.setCheckable(True)
        self.monitor_button.clicked.connect(self.toggle_monitor_folder)

        monitor_layout = QtWidgets.QHBoxLayout()
        monitor_layout.addWidget(self.monitor_button)

        self.folder_section_layout.addLayout(monitor_layout)
        self.folder_section.setLayout(self.folder_section_layout)

        layout.addWidget(self.toggle_folder_checkbox)
        layout.addWidget(self.folder_section)

        # Log Section
        self.log_area = QtWidgets.QTextBrowser(self)
        self.log_area.setReadOnly(True)

        self.save_log_button = QtWidgets.QPushButton('Save Log', self)
        self.save_log_button.clicked.connect(self.save_log)

        self.credential_manager_button = QtWidgets.QPushButton('Credential Manager', self)
        self.credential_manager_button.clicked.connect(self.show_credentials_manager)

        self.quick_connect_manager_button = QtWidgets.QPushButton('Quick Connect Manager')
        self.quick_connect_manager_button.clicked.connect(self.show_quick_connect_manager)

        self.folder_manager_button = QtWidgets.QPushButton('Folder Manager', self)
        self.folder_manager_button.clicked.connect(self.show_folder_manager)

        self.toggle_log_checkbox = QtWidgets.QCheckBox('Log')
        self.toggle_log_checkbox.setChecked(True)
        self.toggle_log_checkbox.toggled.connect(self.toggle_log_section)

        self.log_section = QtWidgets.QGroupBox('')
        self.log_section_layout = QtWidgets.QVBoxLayout()

        self.log_area_layout = QtWidgets.QVBoxLayout()
        self.log_area_layout.addWidget(self.log_area)

        self.log_buttons_layout = QtWidgets.QHBoxLayout()
        self.log_buttons_layout.addWidget(self.save_log_button)
        self.log_buttons_layout.addWidget(self.credential_manager_button)
        self.log_buttons_layout.addWidget(self.quick_connect_manager_button)
        self.log_buttons_layout.addWidget(self.folder_manager_button)

        self.log_section_layout.addLayout(self.log_area_layout)
        self.log_section_layout.addLayout(self.log_buttons_layout)
        self.log_section.setLayout(self.log_section_layout)

        layout.addWidget(self.toggle_log_checkbox)
        layout.addWidget(self.log_section)

        self.setLayout(layout)
        self.load_quick_connects()

    def log_to_ui(self, message):
        self.log_area.append(message)

    def select_local_folder(self):
        folder = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select Local Folder')
        if folder:
            self.local_folder_input.setText(folder)

    def toggle_section(self, section, checked):
        section.setVisible(checked)
        self.parentWidget().adjustSize()  # Ensure the parent widget resizes to fit the content
        self.adjustSize()
        
    def toggle_connection_credentials_section(self, checked):
        self.connection_credentials_section.setVisible(checked)
        
    def toggle_folder_section(self, checked):
        self.toggle_section(self.folder_section, checked)
        
    def toggle_log_section(self, checked):
        self.toggle_section(self.log_section, checked)
        
    def adjustSize(self):
        super().adjustSize()
        self.parentWidget().adjustSize()

    def save_credentials(self):
        host = self.host_input.text().strip()
        username = self.username_input.text().strip()
        password = self.password_input.text().strip()

        conn = sqlite3.connect(master_db_file)
        c = conn.cursor()
        c.execute('''
            INSERT INTO credentials (host, username, password) VALUES (?, ?, ?)
        ''', (host, username, password))
        conn.commit()
        conn.close()
        self.load_credentials()
        
        self.host_input.clear()
        self.username_input.clear()
        self.password_input.clear()

    def load_credentials(self):
        conn = sqlite3.connect(master_db_file)
        c = conn.cursor()
        c.execute('SELECT host, username FROM credentials')
        rows = c.fetchall()
        self.saved_credentials_dropdown.clear()
        for row in rows:
            host, username = row
            self.saved_credentials_dropdown.addItem(f"{username}@@{host}")
        conn.close()

    def show_credentials_manager(self):
        self.credentials_manager = FTPManagerCredentialsManager(self)
        self.credentials_manager.show()
        
    def show_folder_manager(self):
        self.folder_manager = FTPManagerFolderManager(self)
        self.folder_manager.show()

    def show_quick_connect_manager(self):
        self.quick_connect_manager = FTPManagerQuickConnectManager(self)
        self.quick_connect_manager.show()

    def delete_credentials(self):
        selected_host = self.saved_credentials_dropdown.currentText()
        conn = sqlite3.connect(master_db_file)
        c = conn.cursor()
        c.execute('DELETE FROM credentials WHERE host=?', (selected_host.split('@')[1],))
        conn.commit()
        conn.close()
        self.load_credentials()
        
    def get_password(self, host, username):
        try:
            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            c.execute('SELECT password FROM credentials WHERE host=? AND username=?', (host, username))
            row = c.fetchone()
            conn.close()
            return row[0] if row else None
        except sqlite3.Error as e:
            if debug_mode:
                print(f"SQLite error: {e.args[0]} while retrieving password for Host: {host}, Username: {username}")
            return None

    def get_folder_paths(self, folder_name):
        try:
            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            c.execute('SELECT local_path, remote_path FROM folders WHERE name=?', (folder_name,))
            row = c.fetchone()
            conn.close()
            return row if row else None
        except sqlite3.Error as e:
            if debug_mode:
                print(f"SQLite error: {e.args[0]} while retrieving folder paths for Folder: {folder_name}")
            return None
        
    def update_folder_dropdowns(self):
        try:
            parent = self
            while parent and not isinstance(parent, FTPManagerFTPApp):
                parent = parent.parent()
            
            if parent and isinstance(parent, FTPManagerFTPApp):
                parent.load_folders()
            else:
                raise AttributeError("Cannot find parent FTPManagerFTPApp")
        except AttributeError as e:
            self.log(f"Warning: {str(e)}")
        except Exception as e:
            self.log(f"Error updating folder dropdowns: {e}")
        
    def load_folders(self):
        try:
            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            c.execute('SELECT name FROM folders')
            rows = c.fetchall()
            self.folder_manager_dropdown.clear()
            self.folder_manager_dropdown.addItem("1 - None")  # Add "Add Folder" option
            self.folder_manager_dropdown.addItem("2 - Add Folder")            
            for row in rows:
                self.folder_manager_dropdown.addItem(row[0])
            conn.close()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Database Error", f"Failed to load folders: {e}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")
            
    def handle_folder_selection(self, selected_text):
        if selected_text == "2 - Add Folder":
            self.show_folder_manager()

    def load_selected_credentials(self):
        host = self.credentials_dropdown.currentText()
        conn = sqlite3.connect(master_db_file)
        c = conn.cursor()
        c.execute('SELECT username, password FROM credentials WHERE host=?', (host,))
        row = c.fetchone()
        if row:
            self.host_input.setText(host)
            self.username_input.setText(row[0])
            self.password_input.setText(row[1])
        conn.close()
        
    def new_tab_from_quick_connect(self):
        quick_connect_info = self.quick_connect_dropdown.currentText().strip()
        if quick_connect_info:
            parent_app = self.parent()
            while parent_app and not hasattr(parent_app, 'tabs'):
                parent_app = parent_app.parent()

            if parent_app:
                parent_app.new_tab_from_quick_connect(quick_connect_info)
            else:
                QtWidgets.QMessageBox.critical(self, "Error", "Cannot find parent FTPApp with 'tabs' attribute")
        else:
            QtWidgets.QMessageBox.critical(self, "Quick Connect Error", "No quick connect info selected.")

    def validate_credential_format(self, credential):
        parts = credential.split('@@')
        return len(parts) == 2 and all(parts)

    def connect_with_retry(self, host, username, password, retries=3, backoff=1):
        while retries > 0:
            try:
                ftp = ftplib.FTP(host)
                ftp.login(username, password)
                return ftp
            except ftplib.all_errors as e:
                self.log(f"Error connecting to FTP: {e}, retries left: {retries}")
                time.sleep(backoff)
                backoff *= 2  # Exponential backoff
                retries -= 1
        raise ConnectionError(f"Failed to connect to FTP server at {host} after multiple retries")

    def show_message_box(self, title, message):
        reply = QtWidgets.QMessageBox.question(self, title, message, QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        if reply == QtWidgets.QMessageBox.Yes:
            self.overwrite_confirmed = True
            self.start_quick_connect()
        else:
            self.log_signal.emit("Quick connect canceled by user.")

    def start_quick_connect(self):
        self.quick_connect_now_button.setText('Connecting...')
        QtCore.QTimer.singleShot(0, self._quick_connect_thread)

    def quick_connect(self):
        self.quickconnect_in_use = True
        if self.quick_connect_now_button.text() == 'Quick Connect Now':
            self.quick_connect_now_button.setText('Connecting...')
            QtCore.QTimer.singleShot(0, self._quick_connect_thread)
        else:
            self.stop_monitoring()
            if self.ftp:
                try:
                    self.ftp.quit()
                except:
                    pass
            self.ftp = None
            self.ftp_connections = {}
            self.quick_connect_now_button.setText('Quick Connect Now')
            self.connect_button.setText('Connect')

    def _quick_connect_thread(self):
        try:
            quick_connect_info = self.quick_connect_dropdown.currentText().strip()
            if not quick_connect_info:
                raise ValueError("No Quick Connect option selected")

            username_host, local_folder, remote_folder = quick_connect_info.split(' | ')
            username, host = username_host.rsplit('@', 1)

            self.log(f"Connecting to FTP server at {host} with username {username}")
            password = self.get_password(host, username)
            if password is None:
                raise ValueError(f"No password found for {username}@{host}")

            self.ftp = ftplib.FTP(host, timeout=30)
            self.ftp.login(username, password)
            self.log(f"Connected and logged in to FTP server: {host}")

            self.username = username
            self.host = host
            self.local_folder = local_folder
            self.remote_folder = remote_folder

            # Store the connection in the parent
            parent_app = self.get_parent_app()
            if parent_app:
                parent_app.ftp_connections[self.session_name] = self.ftp
                self.log(f"Stored FTP connection for session: {self.session_name}")

                # Update the tab name to reflect the session
                parent_app.tabs.setTabText(parent_app.tabs.indexOf(self), f"{self.username}@{self.host}")

            self.connect_button.setText('Disconnect')
            self.quick_connect_now_button.setText('Disconnect Now')

            # Start loading folders in a separate thread
            self.start_folder_loading_thread()

            # Start the observer for folder monitoring
            self.start_monitor_with_folder(self.local_folder, self.remote_folder, username, password)

        except ValueError as ve:
            self.log(f"Quick Connect error: {str(ve)}", "Connection Error")
            self.quick_connect_now_button.setText('Quick Connect Now')
        except ftplib.all_errors as e:
            self.log(f"FTP connection error: {e}", "Connection Error")
            self.quick_connect_now_button.setText('Quick Connect Now')
        except Exception as e:
            self.log(f"Error in _quick_connect_thread: {e}", "Connection Error")
            self.quick_connect_now_button.setText('Quick Connect Now')

    def on_quick_connect_successful(self, ftp, local_folder, remote_folder):
        self.ftp = ftp
        self.populate_folder_tree()
        self.connect_button.setText('Disconnect')
        self.quick_connect_now_button.setText('Disconnect Now')
        self.start_monitor_with_folder(local_folder, remote_folder)

    def on_connection_successful(self, ftp):
        self.ftp = ftp
        self.connect_button.setText('Disconnect')
        self.quick_connect_now_button.setText('Disconnect Now')
        # Start loading folders in a separate thread
        self.start_folder_loading_thread()

    def start_folder_loading_thread(self):
        self.folder_loading_thread = QtCore.QThread()
        self.folder_loading_worker = FolderLoadingWorker(self.ftp, self.folder_tree)
        self.folder_loading_worker.moveToThread(self.folder_loading_thread)
        self.folder_loading_thread.started.connect(self.folder_loading_worker.run)
        self.folder_loading_worker.finished.connect(self.folder_loading_thread.quit)
        self.folder_loading_worker.finished.connect(self.folder_loading_worker.deleteLater)
        self.folder_loading_thread.finished.connect(self.folder_loading_thread.deleteLater)
        self.folder_loading_thread.start()

    def on_connection_failed(self, error):
        self.log_signal.emit(f'Error connecting to FTP server: {error}')
        self.connect_button.setText('Connect')
        self.quick_connect_now_button.setText('Quick Connect Now')

    def populate_folder_tree(self):
        self.folder_tree.clear()
        self.add_folder_items('', self.folder_tree)

    def add_folder_items(self, path, parent_item):
        try:
            items = [item for item in self.ftp.nlst(path) if item not in ['.', '..']]
            for item in items:
                item_path = os.path.join(path, item)
                tree_item = QtWidgets.QTreeWidgetItem(parent_item, [item])
                if self.is_directory(item_path):
                    self.add_folder_items(item_path, tree_item)
        except Exception as e:
            print(f'Error listing folders: {e}')

    def is_directory(self, path):
        try:
            self.ftp.cwd(path)
            self.ftp.cwd('..')
            return True
        except:
            return False

    def populate_folder(self, item, column):
        path = self.get_item_path(item)
        if self.is_directory(path):
            item.takeChildren()
            self.add_folder_items(path, item)

    def get_item_path(self, item):
        path = []
        while item:
            path.append(item.text(0))
            item = item.parent()
        return '/'.join(reversed(path))

    def toggle_monitor_folder(self):
        folder = self.folder_manager_dropdown.currentText()
        if self.monitor_button.isChecked():
            self.monitor_folder(folder)
        else:
            self.stop_monitoring()

    def start_monitor(self):
        folder = self.folder_manager_dropdown.currentText()
        if folder and folder != "None":
            self.monitor_folder(folder)
            
    def start_monitor_with_folder(self, local_folder, remote_folder, username, password):
        try:
            if local_folder and local_folder != "None" and remote_folder and remote_folder != "None":
                observer_thread = FTPManagerObserverThread(
                    local_path=local_folder,
                    remote_path=remote_folder,
                    ftp=self.ftp,
                    log_func=self.log_signal.emit,
                    quickconnect_in_use=self.quickconnect_in_use,
                    notifications_enabled=self.notifications_enabled,
                    notification_filter=self.notification_filter,
                    username=username,
                    password=password
                )
                observer_thread.log_signal.connect(self.log_signal.emit)
                observer_thread.tray_notification_signal.connect(self.tray_notification_signal)
                observer_thread.start()
                self.observers[remote_folder] = observer_thread
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

    def monitor_folder(self, folder_path):
        local_path = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select Local Folder to Monitor')
        if local_path:
            #self.log_signal.emit(f"Starting observer for local path: {local_path}, remote path: {folder_path}")
            observer_thread = FTPManagerObserverThread(
                local_path=local_path,
                remote_path=folder_path,
                ftp=self.ftp,
                log_func=self.log_signal.emit,
                quickconnect_in_use=self.quickconnect_in_use
            )
            observer_thread.log_signal.connect(self.log_signal.emit)
            observer_thread.start()
            self.observers[folder_path] = observer_thread

    def stop_monitoring(self):
        for remote_folder, observer in self.observers.items():
            observer.stop()
        self.observers.clear()

    def save_log(self):
        log_folder = os.path.join(program_save_folder, 'logs')
        if not os.path.exists(log_folder):
            os.makedirs(log_folder)
        log_file = QtWidgets.QFileDialog.getSaveFileName(self, 'Save Log', os.path.join(log_folder, 'ftp_manager.log'), 'Log Files (*.log)')[0]
        if log_file:
            with open(log_file, 'w') as f:
                f.write(self.log_area.toPlainText())

    def save_quick_connect(self):
        try:
            # Get the selected text from the dropdowns
            selected_credential = self.saved_credentials_dropdown.currentText().strip()
            selected_folder = self.folder_manager_dropdown.currentText().strip()

            if not selected_credential:
                raise ValueError("No credential selected.")
            if not selected_folder:
                raise ValueError("No folder selected.")

            try:
                username, host = selected_credential.split('@@')
            except ValueError:
                raise ValueError("Invalid credential format.")

            # Retrieve the password from the database
            password = self.get_password(host, username)

            # Retrieve the folder paths from the database
            local_folder, remote_folder = self.get_folder_paths(selected_folder)

            if not host or not username or not password or not local_folder or not remote_folder:
                raise ValueError("Missing required information to save quick connect.")

            # Debugging output to verify the values being used
            print(f"Host: {host}")
            print(f"Username: {username}")
            print(f"Password: {'*' * len(password)}")  # Mask the password for security
            print(f"Local Folder: {local_folder}")
            print(f"Remote Folder: {remote_folder}")

            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            c.execute('''
                INSERT INTO quick_connects (host, username, password, local_folder, remote_folder) VALUES (?, ?, ?, ?, ?)
            ''', (host, username, password, local_folder, remote_folder))
            conn.commit()
            conn.close()
            self.load_quick_connects()
        except ValueError as ve:
            print(f"Error: {ve}")
        except sqlite3.Error as e:
            print(f"SQLite error: {e.args[0]}")
        except Exception as e:
            print(f"Unexpected error: {e}")

    def load_quick_connects(self):
        conn = sqlite3.connect(master_db_file)
        c = conn.cursor()
        c.execute('SELECT username, host, local_folder, remote_folder FROM quick_connects')
        rows = c.fetchall()
        self.quick_connect_dropdown.clear()
        for row in rows:
            username, host, local_folder, remote_folder = row
            self.quick_connect_dropdown.addItem(f"{username}@{host} | {local_folder} | {remote_folder}")
        conn.close()
        
class FTPManagerNotificationFilter(QtWidgets.QWidget):
    def __init__(self, parent=None, log_func=None):
        super().__init__(parent)
        self.log_func = log_func
        self.setWindowTitle('Notification Filter')
        self.setGeometry(100, 100, 800, 600)
        self.setWindowFlags(QtCore.Qt.Window)
        self.filters = []
        self.recent_messages = {}  # Dictionary to store recent messages
        self.message_queue = []  # Queue to store incoming messages
        self.deduplication_timeframe = 10  # Timeframe in seconds to consider messages as duplicates
        self.merge_messages_enabled = False
        self.merge_delay = 10  # Default merge delay
        self.create_database()

        self.filter_table = QtWidgets.QTableWidget(self)
        self.filter_table.setColumnCount(8)
        self.filter_table.setHorizontalHeaderLabels([
            'Enabled', 'Enabled Status', 'Type', 'Value', 'Delay (s)', 'Send to Log', 'Send to Notification', 'Merge Delay (s)'
        ])
        self.filter_table.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
        self.filter_table.setSelectionMode(QtWidgets.QTableView.SingleSelection)

        self.add_filter_button = QtWidgets.QPushButton('Add Filter', self)
        self.add_filter_button.clicked.connect(self.add_filter)

        self.edit_filter_button = QtWidgets.QPushButton('Edit Filter', self)
        self.edit_filter_button.clicked.connect(self.edit_filter)

        self.delete_filter_button = QtWidgets.QPushButton('Delete Filter', self)
        self.delete_filter_button.clicked.connect(self.delete_filter)

        self.reset_defaults_button = QtWidgets.QPushButton('Reset Default Filters', self)
        self.reset_defaults_button.clicked.connect(self.reset_default_filters)

        self.merge_delay_input = QtWidgets.QSpinBox(self)
        self.merge_delay_input.setRange(0, 3600)
        self.merge_delay_input.valueChanged.connect(self.update_merge_delay)

        self.merge_messages_checkbox = QtWidgets.QCheckBox('Merge Messages', self)
        self.merge_messages_checkbox.setChecked(self.merge_messages_enabled)
        self.merge_messages_checkbox.stateChanged.connect(self.toggle_merge_messages)

        self.load_merge_settings()

        button_layout = QtWidgets.QHBoxLayout()
        button_layout.addWidget(self.add_filter_button)
        button_layout.addWidget(self.edit_filter_button)
        button_layout.addWidget(self.delete_filter_button)
        button_layout.addWidget(self.reset_defaults_button)
        button_layout.addWidget(self.merge_delay_input)
        button_layout.addWidget(self.merge_messages_checkbox)

        for button in [self.add_filter_button, self.edit_filter_button, self.delete_filter_button, self.reset_defaults_button]:
            button.setFixedWidth(150)
            button.setFixedHeight(30)

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(self.filter_table)
        layout.addLayout(button_layout)
        self.setLayout(layout)

        self.load_filters()

    def toggle_merge_messages(self, state):
        self.merge_messages_enabled = state == QtCore.Qt.Checked
        self.save_merge_settings()

    def update_merge_delay(self, value):
        self.deduplication_timeframe = value
        self.save_merge_settings()

    def save_merge_settings(self):
        settings = QtCore.QSettings('notification_filters.ini', QtCore.QSettings.IniFormat)
        settings.setValue('merge_messages_enabled', self.merge_messages_enabled)
        settings.setValue('merge_delay', self.deduplication_timeframe)

    def load_merge_settings(self):
        settings = QtCore.QSettings('notification_filters.ini', QtCore.QSettings.IniFormat)
        self.merge_messages_enabled = settings.value('merge_messages_enabled', True, type=bool)
        self.deduplication_timeframe = settings.value('merge_delay', 10, type=int)
        self.merge_delay_input.setValue(self.deduplication_timeframe)
        self.merge_messages_checkbox.setChecked(self.merge_messages_enabled)

    def create_database(self):
        db_file = notification_db
        conn = sqlite3.connect(db_file)
        c = conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS filters (
                id INTEGER PRIMARY KEY,
                enabled INTEGER,
                type TEXT,
                value TEXT,
                delay INTEGER,
                send_to_log TEXT,
                send_to_notification TEXT,
                merge_delay INTEGER
            )
        ''')
        conn.commit()

        # Check if default filters already exist
        c.execute("SELECT COUNT(*) FROM filters")
        if c.fetchone()[0] == 0:
            c.execute('''
                INSERT INTO filters (enabled, type, value, delay, send_to_log, send_to_notification, merge_delay)
                VALUES
                (1, 'contains', 'Connecting to FTP server', 0, 'Allow', 'Block', 0),
                (1, 'contains', 'Logging in to FTP server', 0, 'Allow', 'Block', 0),
                (1, 'contains', 'Connected and logged in to FTP server', 3, 'Allow', 'Block', 3),
                (1, 'contains', 'Stored FTP connection for session', 0, 'Allow', 'Block', 0),
                (1, 'contains', 'Starting observer for local path', 3, 'Allow', 'Block', 3),
                (1, 'contains', 'Observer started successfully', 3, 'Allow', 'Block', 3),
                (1, 'contains', 'Queued file for upload', 0, 'Allow', 'Block', 0),
                (1, 'contains', 'Uploading file: Local Path', 0, 'Allow', 'Block', 0),
                (1, 'contains', 'File moved', 0, 'Allow', 'Block', 0),
                (1, 'contains', 'Verified upload:', 0, 'Allow', 'Allow', 0),
                (1, 'contains', 'Upload completed:', 0, 'Allow', 'Allow', 0),
                (1, 'contains', 'Upload confirmed:', 3, 'Allow', 'Allow', 3),
                (1, 'contains', 'Upload failed', 0, 'Allow', 'Allow', 0),
                (1, 'contains', 'Failed to verify upload', 0, 'Allow', 'Allow', 0),
                (1, 'contains', 'File not found on server', 0, 'Allow', 'Allow', 0),
                (1, 'contains', 'Unexpected error checking file existence', 0, 'Allow', 'Allow', 0),
                (1, 'contains', 'Error verifying upload', 0, 'Allow', 'Allow', 0),
                (1, 'contains', 'Upload successful:', 0, 'Allow', 'Allow', 0),
                (1, 'contains', '*', 3, 'Allow', 'Block', 3)
            ''')
            conn.commit()
        conn.close()

    def reset_default_filters(self):
        conn = sqlite3.connect(notification_db)
        c = conn.cursor()
        c.execute('DELETE FROM filters')
        conn.commit()
        c.execute('''
            INSERT INTO filters (enabled, type, value, delay, send_to_log, send_to_notification, merge_delay)
            VALUES
            (1, 'contains', 'Connecting to FTP server', 0, 'Allow', 'Block', 0),
            (1, 'contains', 'Logging in to FTP server', 0, 'Allow', 'Block', 0),
            (1, 'contains', 'Connected and logged in to FTP server', 0, 'Allow', 'Block', 0),
            (1, 'contains', 'Stored FTP connection for session', 0, 'Allow', 'Block', 0),
            (1, 'contains', 'Starting observer for local path', 0, 'Allow', 'Block', 0),
            (1, 'contains', 'Observer started successfully', 0, 'Allow', 'Block', 0),
            (1, 'contains', 'Queued file for upload', 0, 'Allow', 'Block', 0),
            (1, 'contains', 'Uploading file: Local Path', 0, 'Allow', 'Block', 0),
            (1, 'contains', 'File moved', 0, 'Allow', 'Block', 0),
            (1, 'contains', 'Verified upload:', 0, 'Allow', 'Allow', 0),
            (1, 'contains', 'Upload completed:', 0, 'Allow', 'Allow', 0),
            (1, 'contains', 'Upload confirmed:', 3, 'Allow', 'Allow', 3),
            (1, 'contains', 'Upload failed', 0, 'Allow', 'Allow', 0),
            (1, 'contains', 'Failed to verify upload', 0, 'Allow', 'Allow', 0),
            (1, 'contains', 'File not found on server', 0, 'Allow', 'Allow', 0),
            (1, 'contains', 'Unexpected error checking file existence', 0, 'Allow', 'Allow', 0),
            (1, 'contains', 'Error verifying upload', 0, 'Allow', 'Allow', 0),
            (1, 'contains', 'Upload successful:', 0, 'Allow', 'Allow', 0),
            (1, 'contains', '*', 3, 'Allow', 'Block', 3)
        ''')
        conn.commit()
        conn.close()
        self.reload_filters()  # Reload filters to apply changes instantly

    def load_filters(self):
        conn = sqlite3.connect(notification_db)
        c = conn.cursor()
        c.execute('SELECT * FROM filters')
        rows = c.fetchall()
        self.filters = rows
        self.update_filter_table()
        conn.close()

    def reload_filters(self):
        """ Reload filters from the database and update the internal list. """
        self.load_filters()

    def update_filter_table(self):
        self.filter_table.setRowCount(len(self.filters))
        for i, filter_data in enumerate(self.filters):
            for j, value in enumerate(filter_data[1:]):
                if j == 0:
                    enabled_button = QtWidgets.QPushButton('Enable' if value else 'Disable', self)
                    enabled_button.clicked.connect(lambda checked, row=i: self.toggle_filter_enabled(row))
                    self.filter_table.setCellWidget(i, j, enabled_button)
                    enabled_status = 'Enabled' if value else 'Disabled'
                    status_item = QtWidgets.QTableWidgetItem(enabled_status)
                    self.filter_table.setItem(i, j + 1, status_item)
                else:
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.filter_table.setItem(i, j + 1, item)

            if filter_data[1]:
                for j in range(self.filter_table.columnCount()):
                    item = self.filter_table.item(i, j)
                    if item is not None:
                        item.setBackground(QtGui.QColor(200, 255, 200))  # Light green
            else:
                for j in range(self.filter_table.columnCount()):
                    item = self.filter_table.item(i, j)
                    if item is not None:
                        item.setBackground(QtGui.QColor(255, 200, 200))  # Light red

    def toggle_filter_enabled(self, row):
        filter_id = self.filters[row][0]
        new_enabled_status = not self.filters[row][1]
        conn = sqlite3.connect(notification_db)
        c = conn.cursor()
        c.execute('UPDATE filters SET enabled=? WHERE id=?', (new_enabled_status, filter_id))
        conn.commit()
        conn.close()
        self.reload_filters()

    def add_filter(self):
        dialog = FTPManagerAddFilterDialog(self)
        if dialog.exec_():
            filter_data = dialog.get_filter_data()
            conn = sqlite3.connect(notification_db)
            c = conn.cursor()
            c.execute('INSERT INTO filters VALUES (NULL, ?, ?, ?, ?, ?, ?, ?)', filter_data)
            conn.commit()
            conn.close()
            self.reload_filters()  # Reload filters to apply changes instantly

    def edit_filter(self):
        current_row = self.filter_table.currentRow()
        if current_row >= 0:
            filter_id = self.filters[current_row][0]
            dialog = FTPManagerAddFilterDialog(self, filter_data=self.filters[current_row])
            if dialog.exec_():
                new_filter_data = dialog.get_filter_data()
                conn = sqlite3.connect(notification_db)
                c = conn.cursor()
                c.execute('UPDATE filters SET enabled=?, type=?, value=?, delay=?, send_to_log=?, send_to_notification=?, merge_delay=? WHERE id=?', (*new_filter_data, filter_id))
                conn.commit()
                conn.close()
                self.reload_filters()  # Reload filters to apply changes instantly

    def delete_filter(self):
        current_row = self.filter_table.currentRow()
        if current_row >= 0:
            filter_id = self.filters[current_row][0]
            conn = sqlite3.connect(notification_db)
            c = conn.cursor()
            c.execute('DELETE FROM filters WHERE id = ?', (filter_id,))
            conn.commit()
            conn.close()
            self.reload_filters()  # Reload filters to apply changes instantly

    def apply_filters(self, message):
        self.reload_filters()
        current_time = datetime.now().timestamp()

        # Check for deduplication
        if message in self.recent_messages:
            last_logged_time = self.recent_messages[message]
            if current_time - last_logged_time < self.deduplication_timeframe:
                self.recent_messages[message] = current_time
                return 'none', 0

        self.recent_messages[message] = current_time

        # Add to message queue for potential merging
        if self.merge_messages_enabled:
            self.message_queue.append((message, current_time))
            QtCore.QTimer.singleShot(self.merge_delay * 1000, self.process_message_queue)
            return 'none', 0

        # Process message immediately
        for filter_data in self.filters:
            if filter_data[1]:  # If the filter is enabled
                if self.match_filter(message, filter_data):
                    delay = int(filter_data[4])
                    if filter_data[5] == 'Allow' and filter_data[6] == 'Allow':
                        return 'both', delay
                    elif filter_data[5] == 'Allow':
                        return 'log', delay
                    elif filter_data[6] == 'Allow':
                        return 'notification', delay
        return 'none', 0

    def process_message_queue(self):
        current_time = datetime.now().timestamp()
        merged_message = []
        new_queue = []
        for message, timestamp in self.message_queue:
            if current_time - timestamp < self.merge_delay:
                new_queue.append((message, timestamp))
            else:
                if message not in merged_message:
                    merged_message.append(message)
        self.message_queue = new_queue

        if merged_message:
            if self.log_func:
                self.log_func('\n'.join(merged_message))

    def match_filter(self, message, filter_data):
        filter_type = filter_data[2]
        filter_value = filter_data[3]
        if filter_type == 'begins_with' and message.startswith(filter_value):
            return True
        elif filter_type == 'contains' and filter_value in message:
            return True
        elif filter_type == 'exact' and message == filter_value:
            return True
        return False

class FTPManagerAddFilterDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, filter_data=None):
        super().__init__(parent)
        self.setWindowTitle('Add/Edit Filter')
        self.setGeometry(100, 100, 600, 400)

        self.filter_type_combo = QtWidgets.QComboBox(self)
        self.filter_type_combo.addItems(['begins_with', 'contains', 'exact'])

        self.filter_value_input = QtWidgets.QLineEdit(self)

        self.delay_input = QtWidgets.QSpinBox(self)
        self.delay_input.setRange(0, 3600)

        self.send_to_log_combo = QtWidgets.QComboBox(self)
        self.send_to_log_combo.addItems(['Allow', 'Block'])

        self.send_to_notification_combo = QtWidgets.QComboBox(self)
        self.send_to_notification_combo.addItems(['Allow', 'Block'])

        self.merge_delay_input = QtWidgets.QSpinBox(self)
        self.merge_delay_input.setRange(0, 3600)

        self.ok_button = QtWidgets.QPushButton('OK', self)
        self.ok_button.clicked.connect(self.accept)

        self.cancel_button = QtWidgets.QPushButton('Cancel', self)
        self.cancel_button.clicked.connect(self.reject)

        layout = QtWidgets.QGridLayout()
        layout.addWidget(QtWidgets.QLabel('Filter Type:', self), 0, 0)
        layout.addWidget(self.filter_type_combo, 0, 1)
        layout.addWidget(QtWidgets.QLabel('Filter Value:', self), 1, 0)
        layout.addWidget(self.filter_value_input, 1, 1)
        layout.addWidget(QtWidgets.QLabel('Delay (seconds):', self), 2, 0)
        layout.addWidget(self.delay_input, 2, 1)
        layout.addWidget(QtWidgets.QLabel('Send to Log:', self), 3, 0)
        layout.addWidget(self.send_to_log_combo, 3, 1)
        layout.addWidget(QtWidgets.QLabel('Send to Notification:', self), 4, 0)
        layout.addWidget(self.send_to_notification_combo, 4, 1)
        layout.addWidget(QtWidgets.QLabel('Merge Delay (seconds):', self), 5, 0)
        layout.addWidget(self.merge_delay_input, 5, 1)
        layout.addWidget(self.ok_button, 6, 0)
        layout.addWidget(self.cancel_button, 6, 1)
        self.setLayout(layout)

        if filter_data:
            self.filter_type_combo.setCurrentText(filter_data[2])
            self.filter_value_input.setText(filter_data[3])
            self.delay_input.setValue(filter_data[4])
            self.send_to_log_combo.setCurrentText(filter_data[5])
            self.send_to_notification_combo.setCurrentText(filter_data[6])
            self.merge_delay_input.setValue(filter_data[7])

    def get_filter_data(self):
        return (
            1,  # Enabled
            self.filter_type_combo.currentText(),
            self.filter_value_input.text(),
            self.delay_input.value(),
            self.send_to_log_combo.currentText(),
            self.send_to_notification_combo.currentText(),
            self.merge_delay_input.value()
        )

class FolderLoadingWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    update_progress = QtCore.pyqtSignal(int)
    update_maximum = QtCore.pyqtSignal(int)
    disable_tree = QtCore.pyqtSignal(bool)
    show_progress = QtCore.pyqtSignal(bool)

    def __init__(self, ftp, folder_tree_widget):
        super().__init__()
        self.ftp = ftp
        self.folder_tree_widget = folder_tree_widget

    def run(self):
        try:
            self.disable_tree.emit(True)
            self.show_progress.emit(True)
            self.populate_folder_tree()
            self.finished.emit()
        except Exception as e:
            print(f'Error in folder loading worker: {e}')
            self.finished.emit()

    def populate_folder_tree(self):
        try:
            self.folder_tree_widget.clear()
            items = self.ftp.nlst('')
            self.update_maximum.emit(len(items))
            self.add_folder_items('', self.folder_tree_widget)
            self.show_progress.emit(False)
            self.disable_tree.emit(False)
        except Exception as e:
            print(f'Error populating folder tree: {e}')

    def add_folder_items(self, path, parent_item):
        try:
            items = [item for item in self.ftp.nlst(path) if item not in ['.', '..']]
            for index, item in enumerate(items):
                item_path = os.path.join(path, item)
                tree_item = QtWidgets.QTreeWidgetItem(parent_item, [item])
                if self.is_directory(item_path):
                    self.add_folder_items(item_path, tree_item)
                self.update_progress.emit(index + 1)
        except Exception as e:
            print(f'Error listing folders: {e}')

    def is_directory(self, path):
        try:
            self.ftp.cwd(path)
            self.ftp.cwd('..')
            return True
        except:
            return False

class FTPManagerFTPEventHandler(FileSystemEventHandler):
    log_signal = QtCore.pyqtSignal(str)

    def __init__(self, ftp, remote_folder, local_folder, log_func=None):
        self.ftp = ftp
        self.remote_folder = remote_folder
        self.local_folder = local_folder
        self.log_func = log_func  # This can be used if additional logging is needed

    def on_created(self, event):
        if not event.is_directory:
            self.upload_file(event.src_path)

    def on_modified(self, event):
        if not event.is_directory:
            self.upload_file(event.src_path)

    def on_deleted(self, event):
        if not event.is_directory:
            self.delete_file(event.src_path)

    def upload_file(self, local_path):
        relative_path = os.path.relpath(local_path, self.local_folder)
        remote_path = os.path.join(self.remote_folder, relative_path).replace('\\', '/')
        #self.log_signal.emit(f"Uploading file: Local Path: {local_path}, Relative Path: {relative_path}, Remote Path: {remote_path}")
        try:
            self.ftp_upload_thread = FTPManagerFTPUploadThread(self.ftp, local_path, remote_path)
            self.ftp_upload_thread.start()
        except Exception as e:
            self.log_signal.emit(f'Error starting upload thread: {e}')

    def delete_file(self, local_path):
        relative_path = os.path.relpath(local_path, self.local_folder)
        remote_path = os.path.join(self.remote_folder, relative_path).replace('\\', '/')
        #self.log_signal.emit(f"Deleting file: Local Path: {local_path}, Relative Path: {relative_path}, Remote Path: {remote_path}")
        try:
            self.ftp_delete_thread = FTPManagerFTPDeleteThread(self.ftp, remote_path)
            self.ftp_delete_thread.start()
        except Exception as e:
            self.log_signal.emit(f'Error starting delete thread: {e}')

class FTPManagerFTPEventHandlerWrapper(QtCore.QObject, FileSystemEventHandler):
    log_signal = QtCore.pyqtSignal(str)
    tray_notification_signal = QtCore.pyqtSignal(str, str)
    upload_complete_signal = QtCore.pyqtSignal(str, str, bool)
    reconnection_signal = QtCore.pyqtSignal()
    process_event_signal = QtCore.pyqtSignal()

    def __init__(self, ftp, remote_folder, local_folder, quickconnect_in_use, notifications_enabled, notification_filter, log_func, username, password):
        super().__init__()
        self.ftp = ftp
        self.remote_folder = remote_folder
        self.local_folder = local_folder
        self.quickconnect_in_use = quickconnect_in_use
        self.notifications_enabled = notifications_enabled
        self.notification_filter = notification_filter
        self.upload_queue = deque()
        self.uploading = False
        self.uploaded_files = set()
        self.last_modified_time = {}
        self.files_in_process = set()
        self.upload_complete_signal.connect(self.on_upload_complete)
        self.log_signal.connect(log_func)
        self.tray_notification_signal.connect(lambda title, message: log_func(message))
        self.reconnection_signal.connect(self.reconnect)
        self.process_event_signal.connect(self.process_event_queue)
        self.event_queue = []

        # Store FTP credentials
        self.ftp_host = self.ftp.host
        self.ftp_user = username
        self.ftp_pass = password

        # Move timer creation to the main thread
        QtCore.QTimer.singleShot(0, self.setup_timers)
        
    def check_connection(self):
        try:
            self.ftp.voidcmd("NOOP")
        except:
            self.log_signal.emit("Connection lost. Attempting to reconnect...")
            self.reconnection_signal.emit()

    def ensure_connection(self):
        try:
            self.ftp.voidcmd("NOOP")
            return True
        except:
            return self.reconnect()

    def reconnect(self):
        self.log_signal.emit("Attempting to reconnect...")
        try:
            self.ftp.close()
        except:
            pass

        max_retries = 3
        for attempt in range(max_retries):
            try:
                self.ftp = ftplib.FTP(self.ftp_host, timeout=30)
                self.ftp.login(self.ftp_user, self.ftp_pass)
                self.log_signal.emit("Reconnection successful")
                return True
            except Exception as e:
                self.log_signal.emit(f"Reconnection attempt {attempt + 1} failed: {str(e)}")
                if attempt < max_retries - 1:
                    time.sleep(5)  # Wait for 5 seconds before retrying

        self.log_signal.emit("Failed to reconnect after multiple attempts")
        return False

    def show_notification(self, title, message):
        if self.notifications_enabled:
            self.tray_notification_signal.emit(title, message)

    def setup_timers(self):
        self.connection_check_timer = QtCore.QTimer(self)
        self.connection_check_timer.timeout.connect(self.check_connection)
        self.connection_check_timer.start(60000)  # Check connection every minute

    # Event handlers
    def on_created(self, event):
        if not event.is_directory:
            self.queue_event('created', event.src_path)

    def on_modified(self, event):
        if not event.is_directory:
            self.queue_event('modified', event.src_path)

    def on_deleted(self, event):
        if not event.is_directory:
            self.queue_event('deleted', event.src_path)

    def on_moved(self, event):
        if not event.is_directory:
            self.queue_event('moved', (event.src_path, event.dest_path))

    def queue_event(self, event_type, path):
        self.event_queue.append((event_type, path))
        self.process_event_signal.emit()

    def process_event_queue(self):
        while self.event_queue:
            event_type, path = self.event_queue.pop(0)
            if isinstance(path, tuple):  # For moved events
                src_path, dest_path = path
                if src_path not in self.files_in_process and dest_path not in self.files_in_process:
                    self.files_in_process.add(dest_path)
                    self.move_remote_file(src_path, dest_path)
                    self.files_in_process.remove(dest_path)
            elif path not in self.files_in_process:
                self.files_in_process.add(path)
                if event_type in ['created', 'modified']:
                    self.queue_upload(path)
                elif event_type == 'deleted':
                    self.delete_file(path)
                self.files_in_process.remove(path)

    def queue_upload(self, local_path):
        try:
            if local_path not in self.upload_queue:
                self.upload_queue.append(local_path)
                self.log_signal.emit(f"Queued file for upload: {local_path}")
                if not self.uploading:
                    self.process_next_upload()
        except Exception as e:
            self.log_signal.emit(f"Error in queue_upload: {e}")

    def process_next_upload(self):
        try:
            if self.upload_queue and not self.uploading:
                self.uploading = True
                local_path = self.upload_queue.popleft()
                self.upload_file(local_path)
            else:
                self.uploading = False
        except Exception as e:
            self.log_signal.emit(f"Error in process_next_upload: {e}")
            self.uploading = False

    def upload_file(self, local_path, retries=3):
        if not self.ensure_connection():
            self.log_signal.emit(f"Failed to upload {local_path} due to connection issues.")
            self.uploading = False
            self.process_next_upload()
            return

        try:
            relative_path = os.path.relpath(local_path, self.local_folder)
            remote_path = os.path.join(self.remote_folder, relative_path).replace('\\', '/')
            self.log_signal.emit(f"Uploading file: Local Path: {local_path}, Relative Path: {relative_path}, Remote Path: {remote_path}")

            if not self.quickconnect_in_use and self.file_exists(remote_path):
                reply = QtWidgets.QMessageBox.question(None, 'Confirm Overwrite', f'File {remote_path} already exists. Do you want to overwrite it?', QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
                if reply == QtWidgets.QMessageBox.No:
                    self.log_signal.emit(f"File overwrite canceled: {remote_path}")
                    self.uploading = False
                    self.process_next_upload()
                    return

            with open(local_path, 'rb') as file:
                self.ftp.storbinary(f'STOR {remote_path}', file)

            local_size = os.path.getsize(local_path)
            remote_size = self.ftp.size(remote_path)

            if local_size == remote_size:
                self.log_signal.emit(f"Upload confirmed: {local_path} to {remote_path}")
                self.uploading = False
                self.process_next_upload()
            else:
                self.log_signal.emit(f"Size mismatch after upload: {local_path} to {remote_path} (local: {local_size}, remote: {remote_size})")
                if retries > 0:
                    self.log_signal.emit(f"Retrying upload: {local_path} to {remote_path} (remaining retries: {retries})")
                    time.sleep(5)  # Wait for 5 seconds before retrying
                    self.upload_file(local_path, retries - 1)
                else:
                    self.log_signal.emit(f"Failed to upload {local_path} to {remote_path} after multiple attempts.")
                    self.uploading = False
                    self.process_next_upload()

        except ftplib.all_errors as e:
            self.log_signal.emit(f'FTP error during upload: {e}')
            if retries > 0:
                self.log_signal.emit(f"Retrying upload: {local_path} to {remote_path} (remaining retries: {retries})")
                time.sleep(5)  # Wait for 5 seconds before retrying
                self.upload_file(local_path, retries - 1)
            else:
                self.log_signal.emit(f"Failed to upload {local_path} to {remote_path} after multiple attempts.")
                self.uploading = False
                self.process_next_upload()

    def on_upload_complete(self, local_path, remote_path, success):
        try:
            if success:
                self.log_signal.emit(f"Upload completed: {local_path} to {remote_path}")
                QtCore.QTimer.singleShot(1000, lambda: self.verify_upload(local_path, remote_path))
            else:
                self.log_signal.emit(f"Upload failed: {local_path} to {remote_path}")
                self.uploading = False
                self.process_next_upload()
        except Exception as e:
            self.log_signal.emit(f"Error in on_upload_complete: {e}")
            self.uploading = False
            self.process_next_upload()

    def verify_upload(self, local_path, remote_path, retries=5):
        try:
            if self.file_exists(remote_path):
                self.log_signal.emit(f"Verified upload: {local_path} exists on the server at {remote_path}")
                self.uploading = False
                self.process_next_upload()
            else:
                if retries > 0:
                    self.log_signal.emit(f"File not found on server, retrying... ({retries} attempts left)")
                    QtCore.QTimer.singleShot(1000, lambda: self.verify_upload(local_path, remote_path, retries - 1))
                else:
                    self.log_signal.emit(f"Failed to verify upload: {local_path} does not exist on the server at {remote_path}")
                    self.uploading = False
                    self.process_next_upload()
        except Exception as e:
            self.log_signal.emit(f"Error verifying upload: {e}")
            self.uploading = False
            self.process_next_upload()

    def file_exists(self, remote_path):
        if not self.ensure_connection():
            return False
        try:
            self.ftp.size(remote_path)
            return True
        except ftplib.error_perm as e:
            if str(e).startswith('550'):
                return False
            else:
                self.log_signal.emit(f"FTP error checking file existence: {e}")
                return False
        except Exception as e:
            self.log_signal.emit(f"Unexpected error checking file existence: {e}")
            return False

    def create_remote_folder(self, src_path):
        try:
            relative_path = os.path.relpath(src_path, self.local_folder)
            remote_path = os.path.join(self.remote_folder, relative_path).replace('\\', '/')
            self.ftp.mkd(remote_path)
            self.log_signal.emit(f"Created remote directory: {remote_path}")
        except ftplib.error_perm as e:
            if not str(e).startswith('550'):  # 550 error means directory already exists
                self.log_signal.emit(f"Error creating remote directory: {e}")
        except Exception as e:
            self.log_signal.emit(f"Error in create_remote_folder: {e}")

    def delete_file(self, src_path):
        try:
            relative_path = os.path.relpath(src_path, self.local_folder)
            remote_path = os.path.join(self.remote_folder, relative_path).replace('\\', '/')
            self.ftp.delete(remote_path)
            self.log_signal.emit(f"Deleted remote file: {remote_path}")
        except ftplib.error_perm as e:
            self.log_signal.emit(f"Error deleting remote file: {e}")
        except Exception as e:
            self.log_signal.emit(f"Error in delete_file: {e}")

    def delete_remote_folder(self, src_path):
        try:
            relative_path = os.path.relpath(src_path, self.local_folder)
            remote_path = os.path.join(self.remote_folder, relative_path).replace('\\', '/')
            self.remove_directory_recursive(remote_path)
            self.log_signal.emit(f"Deleted remote folder: {remote_path}")
        except Exception as e:
            self.log_signal.emit(f"Error in delete_remote_folder: {e}")

    def remove_directory_recursive(self, path):
        try:
            for (name, properties) in self.ftp.mlsd(path):
                if name in ['.', '..']:
                    continue
                elif properties['type'] == 'dir':
                    self.remove_directory_recursive(f"{path}/{name}")
                else:
                    self.ftp.delete(f"{path}/{name}")
            self.ftp.rmd(path)
        except Exception as e:
            self.log_signal.emit(f"Error in remove_directory_recursive: {e}")

    def move_remote_folder(self, src_path, dest_path):
        try:
            relative_src = os.path.relpath(src_path, self.local_folder)
            relative_dest = os.path.relpath(dest_path, self.local_folder)
            remote_src = os.path.join(self.remote_folder, relative_src).replace('\\', '/')
            remote_dest = os.path.join(self.remote_folder, relative_dest).replace('\\', '/')
            self.ftp.rename(remote_src, remote_dest)
            self.log_signal.emit(f"Moved remote folder: {remote_src} to {remote_dest}")
        except Exception as e:
            self.log_signal.emit(f"Error in move_remote_folder: {e}")

    def move_remote_file(self, src_path, dest_path):
        try:
            relative_src = os.path.relpath(src_path, self.local_folder)
            relative_dest = os.path.relpath(dest_path, self.local_folder)
            remote_src = os.path.join(self.remote_folder, relative_src).replace('\\', '/')
            remote_dest = os.path.join(self.remote_folder, relative_dest).replace('\\', '/')
            self.ftp.rename(remote_src, remote_dest)
            self.log_signal.emit(f"Moved remote file: {remote_src} to {remote_dest}")
        except Exception as e:
            self.log_signal.emit(f"Error in move_remote_file: {e}")

class FTPManagerObserverThread(QtCore.QThread):
    log_signal = QtCore.pyqtSignal(str)
    tray_notification_signal = QtCore.pyqtSignal(str, str)  # Title, Message

    def __init__(self, local_path, remote_path, ftp, log_func, quickconnect_in_use=False, notifications_enabled=True, notification_filter=None, username=None, password=None, parent=None):
        super().__init__(parent)
        self.local_path = local_path
        self.remote_path = remote_path
        self.ftp = ftp
        self.log_func = log_func
        self.quickconnect_in_use = quickconnect_in_use
        self.notifications_enabled = notifications_enabled
        self.notification_filter = notification_filter
        self.username = username
        self.password = password
        self.observer = None

    def run(self):
        try:
            if self.log_func:
                self.log_func(f"Starting observer for local path: {self.local_path}, remote path: {self.remote_path}")
            event_handler = FTPManagerFTPEventHandlerWrapper(
                self.ftp, self.remote_path, self.local_path, self.quickconnect_in_use, 
                self.notifications_enabled, self.notification_filter, self.log_func,
                self.username, self.password
            )
            event_handler.log_signal.connect(self.log_func)
            event_handler.tray_notification_signal.connect(self.tray_notification_signal.emit)
            self.observer = Observer()
            self.observer.schedule(event_handler, self.local_path, recursive=True)
            self.observer.start()
            if self.log_func:
                self.log_func("Observer started successfully")
            self.exec_()  # Keep the thread running
        except Exception as e:
            if self.log_func:
                self.log_func(f"Error starting observer: {e}")
            if debug_mode:
                print(f"Debug: Error starting observer: {e}")
            self.quit()

    def stop(self):
        try:
            if self.observer:
                if self.log_func:
                    self.log_func("Stopping observer")
                self.observer.stop()
                self.observer.join()
            self.quit()
            if self.log_func:
                self.log_func("Observer stopped successfully")
        except Exception as e:
            if self.log_func:
                self.log_func(f"Error stopping observer: {e}")
            if debug_mode:
                print(f"Debug: Error stopping observer: {e}")

    def log_func(self, message):
        try:
            self.log_signal.emit(message)
        except Exception as e:
            if debug_mode:
                print(f"Debug: Error emitting log signal: {e}")

class FTPManagerFTPUploadThread(QtCore.QThread):
    log_signal = QtCore.pyqtSignal(str)
    upload_complete_signal = QtCore.pyqtSignal(str, str, bool)

    def __init__(self, ftp, local_path, remote_path, log_func, upload_complete_callback, parent=None):
        super().__init__(parent)
        self.ftp = ftp
        self.local_path = local_path
        self.remote_path = remote_path
        self.log_func = log_func
        self.upload_complete_callback = upload_complete_callback
        self.log_signal.connect(self.log_func)

    def run(self):
        try:
            self.log_signal.emit(f"Starting upload: Local Path: {self.local_path}, Remote Path: {self.remote_path}")
            with open(self.local_path, 'rb') as file:
                self.ftp.storbinary(f'STOR {self.remote_path}', file)
            self.log_signal.emit(f"Upload successful: {self.local_path} to {self.remote_path}")
            self.upload_complete_signal.emit(self.local_path, self.remote_path, True)
        except FileNotFoundError:
            self.log_signal.emit(f"Error: Local file not found: {self.local_path}")
            self.upload_complete_signal.emit(self.local_path, self.remote_path, False)
        except ftplib.error_perm as e:
            self.log_signal.emit(f"FTP permission error during upload: {e}")
            self.upload_complete_signal.emit(self.local_path, self.remote_path, False)
        except ftplib.error_temp as e:
            self.log_signal.emit(f"Temporary FTP error during upload: {e}. Retrying...")
            self.retry_upload()
        except Exception as e:
            self.log_signal.emit(f"Unexpected error during upload: {e}")
            self.upload_complete_signal.emit(self.local_path, self.remote_path, False)
        finally:
            self.quit()

    def retry_upload(self):
        retries = 3
        for attempt in range(retries):
            try:
                with open(self.local_path, 'rb') as file:
                    self.ftp.storbinary(f'STOR {self.remote_path}', file)
                self.log_signal.emit(f"Retry upload successful: {self.local_path} to {self.remote_path}")
                self.upload_complete_signal.emit(self.local_path, self.remote_path, True)
                return
            except ftplib.error_temp as e:
                self.log_signal.emit(f"Retry {attempt + 1} failed: {e}")
            except Exception as e:
                self.log_signal.emit(f"Unexpected error during retry {attempt + 1}: {e}")
        self.log_signal.emit(f"Failed to upload {self.local_path} to {self.remote_path} after {retries} attempts.")
        self.upload_complete_signal.emit(self.local_path, self.remote_path, False)

class FTPManagerFTPDeleteThread(QtCore.QThread):
    log_signal = QtCore.pyqtSignal(str)  # Define the log_signal

    def __init__(self, ftp, remote_path, log_func, parent=None):
        super().__init__(parent)
        self.ftp = ftp
        self.remote_path = remote_path
        self.log_func = log_func
        self.log_signal.connect(self.log_func)  # Connect signal to the logging function

    def run(self):
        try:
            self.log_signal.emit(f"Starting delete: Remote Path: {self.remote_path}")
            self.ftp.delete(self.remote_path)
            self.log_signal.emit(f"Delete successful: {self.remote_path}")
        except ftplib.error_perm as e:
            self.log_signal.emit(f"FTP permission error during delete: {e}")
        except ftplib.error_temp as e:
            self.log_signal.emit(f"Temporary FTP error during delete: {e}. Retrying...")
            self.retry_delete()
        except Exception as e:
            self.log_signal.emit(f"Unexpected error during delete: {e}")
        finally:
            self.quit()

    def retry_delete(self):
        retries = 3
        for attempt in range(retries):
            try:
                self.ftp.delete(self.remote_path)
                self.log_signal.emit(f"Retry delete successful: {self.remote_path}")
                return
            except ftplib.error_temp as e:
                self.log_signal.emit(f"Retry {attempt + 1} failed: {e}")
            except Exception as e:
                self.log_signal.emit(f"Unexpected error during retry {attempt + 1}: {e}")
        self.log_signal.emit(f"Failed to delete {self.remote_path} after {retries} attempts.")

class FTPManagerFTPConnectThread(QtCore.QThread):
    connection_successful = QtCore.pyqtSignal(object)  # Emit FTP object on success
    connection_failed = QtCore.pyqtSignal(str)
    log_signal = QtCore.pyqtSignal(str)

    def __init__(self, host, username, password, remote_folder, parent=None):
        super().__init__(parent)
        self.host = host
        self.username = username
        self.password = password
        self.remote_folder = remote_folder

    def run(self):
        try:
            self.log_signal.emit(f"Connecting to FTP server: {self.host}")
            ftp = ftplib.FTP(self.host)
            ftp.login(self.username, self.password)
            self.log_signal.emit(f"Connected to FTP server: {self.host}")
            self.connection_successful.emit(ftp)  # Pass FTP object on success
        except Exception as e:
            self.log_signal.emit(f"Failed to connect to FTP server: {e}")
            self.connection_failed.emit(str(e))

class FTPManagerCredentialsManager(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(None)
        self.setWindowTitle('Credentials Manager')
        self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))    
        self.setGeometry(100, 100, 600, 400)
        self.setWindowFlags(QtCore.Qt.Window)  # Ensure it shows in the taskbar

        self.table = QtWidgets.QTableWidget(self)
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(['Select', 'Host', 'Username', 'Password'])
        self.table.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
        self.table.setSelectionMode(QtWidgets.QTableView.MultiSelection)

        self.load_credentials()

        self.delete_button = QtWidgets.QPushButton('Delete Selected')
        self.delete_button.clicked.connect(self.delete_selected_credentials)
        self.edit_button = QtWidgets.QPushButton('Edit Selected')
        self.edit_button.clicked.connect(self.edit_selected_credentials)
        self.add_button = QtWidgets.QPushButton('Add Credential')
        self.add_button.clicked.connect(self.add_credential)

        button_layout = QtWidgets.QHBoxLayout()
        button_layout.addWidget(self.add_button)
        button_layout.addWidget(self.edit_button)
        button_layout.addWidget(self.delete_button)

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(self.table)
        layout.addLayout(button_layout)

        self.setLayout(layout)

    def load_credentials(self):
        try:
            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            c.execute('SELECT * FROM credentials')
            rows = c.fetchall()
            self.table.setRowCount(len(rows))

            for i, row in enumerate(rows):
                select_item = QtWidgets.QTableWidgetItem()
                select_item.setCheckState(QtCore.Qt.Unchecked)
                select_item.setData(QtCore.Qt.UserRole, row[0])  # Store the ID in the UserRole
                self.table.setItem(i, 0, select_item)
                self.table.setItem(i, 1, QtWidgets.QTableWidgetItem(row[1]))
                self.table.setItem(i, 2, QtWidgets.QTableWidgetItem(row[2]))
                password_item = QtWidgets.QTableWidgetItem(row[3])
                password_item.setFlags(password_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.table.setItem(i, 3, password_item)

            conn.close()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"SQLite error: {e.args[0]}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

    def delete_selected_credentials(self):
        try:
            selected_items = self.table.selectionModel().selectedRows()
            if not selected_items:
                QtWidgets.QMessageBox.warning(self, 'No selection', 'No credentials selected for deletion.')
                return

            reply = QtWidgets.QMessageBox.question(self, 'Confirm Delete', 'Are you sure you want to delete the selected credentials?', QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            if reply == QtWidgets.QMessageBox.No:
                return

            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            for item in selected_items:
                row = item.row()
                cred_id = self.table.item(row, 0).data(QtCore.Qt.UserRole)
                c.execute('DELETE FROM credentials WHERE id=?', (cred_id,))
            conn.commit()
            conn.close()
            self.load_credentials()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"SQLite error: {e.args[0]}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

    def edit_selected_credentials(self):
        try:
            selected_items = self.table.selectionModel().selectedRows()
            if not selected_items:
                QtWidgets.QMessageBox.warning(self, 'No selection', 'No credentials selected for editing.')
                return

            if len(selected_items) > 1:
                reply = QtWidgets.QMessageBox.question(self, 'Multiple selection', 'Multiple credentials selected. Do you want to edit all selected items?', QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
                if reply == QtWidgets.QMessageBox.No:
                    return

            for item in selected_items:
                row = item.row()
                cred_data = [self.table.item(row, i).text() for i in range(1, 4)]
                dialog = FTPManagerEditCredentialDialog(self, cred_data)
                if dialog.exec_():
                    new_host, new_username, new_password = dialog.get_data()
                    cred_id = self.table.item(row, 0).data(QtCore.Qt.UserRole)
                    conn = sqlite3.connect(master_db_file)
                    c = conn.cursor()
                    c.execute('UPDATE credentials SET host=?, username=?, password=? WHERE id=?', (new_host, new_username, new_password, cred_id))
                    conn.commit()
                    conn.close()
            self.load_credentials()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"SQLite error: {e.args[0]}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

    def add_credential(self):
        dialog = FTPManagerEditCredentialDialog(self)
        if dialog.exec_():
            host, username, password = dialog.get_data()
            try:
                conn = sqlite3.connect(master_db_file)
                c = conn.cursor()
                c.execute("INSERT INTO credentials (host, username, password) VALUES (?, ?, ?)", (host, username, password))
                conn.commit()
                conn.close()
                self.load_credentials()
            except sqlite3.Error as e:
                QtWidgets.QMessageBox.critical(self, "Error", f"SQLite error: {e.args[0]}")
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")
        
class FTPManagerEditCredentialDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, credential=None):
        super().__init__(None)
        self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))   
        self.setWindowFlags(Qt.Window)
        self.setWindowTitle('Edit Credential')
        self.setGeometry(100, 100, 400, 200)

        self.credential = credential

        self.host_label = QtWidgets.QLabel('Host:')
        self.host_input = QtWidgets.QLineEdit(self)
        if self.credential:
            self.host_input.setText(self.credential[0])

        self.username_label = QtWidgets.QLabel('Username:')
        self.username_input = QtWidgets.QLineEdit(self)
        if self.credential:
            self.username_input.setText(self.credential[1])

        self.password_label = QtWidgets.QLabel('Password:')
        self.password_input = QtWidgets.QLineEdit(self)
        self.password_input.setEchoMode(QtWidgets.QLineEdit.Password)
        if self.credential:
            self.password_input.setText(self.credential[2])

        self.save_button = QtWidgets.QPushButton('Save', self)
        self.save_button.clicked.connect(self.accept)

        self.cancel_button = QtWidgets.QPushButton('Cancel', self)
        self.cancel_button.clicked.connect(self.reject)

        layout = QtWidgets.QGridLayout(self)
        layout.addWidget(self.host_label, 0, 0)
        layout.addWidget(self.host_input, 0, 1)
        layout.addWidget(self.username_label, 1, 0)
        layout.addWidget(self.username_input, 1, 1)
        layout.addWidget(self.password_label, 2, 0)
        layout.addWidget(self.password_input, 2, 1)
        layout.addWidget(self.save_button, 3, 0)
        layout.addWidget(self.cancel_button, 3, 1)

    def get_data(self):
        return self.host_input.text(), self.username_input.text(), self.password_input.text()

class FTPManagerFolderManager(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))   
        self.setWindowTitle('Folder Manager')
        self.setGeometry(100, 100, 600, 400)
        self.setWindowFlags(QtCore.Qt.Window)  # Ensure it shows in the taskbar

        self.table = QtWidgets.QTableWidget(self)
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(['Select', 'Name', 'Remote Path', 'Local Path'])
        self.table.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
        self.table.setSelectionMode(QtWidgets.QTableView.MultiSelection)

        self.load_folders()

        self.delete_button = QtWidgets.QPushButton('Delete Selected')
        self.delete_button.clicked.connect(self.delete_selected_folders)
        self.edit_button = QtWidgets.QPushButton('Edit Selected')
        self.edit_button.clicked.connect(self.edit_selected_folders)
        self.add_button = QtWidgets.QPushButton('Add Folder')
        self.add_button.clicked.connect(self.add_folder)

        button_layout = QtWidgets.QHBoxLayout()
        button_layout.addWidget(self.add_button)
        button_layout.addWidget(self.edit_button)
        button_layout.addWidget(self.delete_button)

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(self.table)
        layout.addLayout(button_layout)

        self.setLayout(layout)

    def load_folders(self):
        try:
            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            c.execute('SELECT * FROM folders')
            rows = c.fetchall()
            self.table.setRowCount(len(rows))

            for i, row in enumerate(rows):
                select_item = QtWidgets.QTableWidgetItem()
                select_item.setCheckState(QtCore.Qt.Unchecked)
                select_item.setData(QtCore.Qt.UserRole, row[0])  # Set the folder ID
                self.table.setItem(i, 0, select_item)
                self.table.setItem(i, 1, QtWidgets.QTableWidgetItem(row[1]))
                self.table.setItem(i, 2, QtWidgets.QTableWidgetItem(row[2]))
                self.table.setItem(i, 3, QtWidgets.QTableWidgetItem(row[3]))

            conn.close()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Database Error", f"Failed to load folders: {e}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

    def delete_selected_folders(self):
        selected_items = self.table.selectionModel().selectedRows()
        if not selected_items:
            QtWidgets.QMessageBox.warning(self, 'No selection', 'No folders selected for deletion.')
            return

        reply = QtWidgets.QMessageBox.question(self, 'Confirm Delete', 'Are you sure you want to delete the selected folders?', QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        if reply == QtWidgets.QMessageBox.No:
            return

        try:
            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            for item in selected_items:
                row = item.row()
                folder_id = self.table.item(row, 0).data(QtCore.Qt.UserRole)
                if folder_id is None:
                    raise ValueError(f"Invalid folder ID for row {row}.")
                c.execute('DELETE FROM folders WHERE id=?', (folder_id,))

            conn.commit()
            conn.close()
            self.load_folders()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Database Error", f"Failed to delete selected folders: {e}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

    def edit_selected_folders(self):
        selected_items = self.table.selectionModel().selectedRows()
        if not selected_items:
            QtWidgets.QMessageBox.warning(self, 'No selection', 'No folders selected for editing.')
            return

        if len(selected_items) > 1:
            reply = QtWidgets.QMessageBox.question(self, 'Multiple selection', 'Multiple folders selected. Do you want to edit all selected items?', QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            if reply == QtWidgets.QMessageBox.No:
                return

        try:
            for item in selected_items:
                row = item.row()
                folder_data = [self.table.item(row, i).text() for i in range(1, 4)]
                dialog = FTPManagerEditFolderDialog(self, folder_data)
                if dialog.exec_():
                    new_name, new_remote_path, new_local_path = dialog.get_data()
                    folder_id = self.table.item(row, 0).data(QtCore.Qt.UserRole)
                    conn = sqlite3.connect(master_db_file)
                    c = conn.cursor()
                    c.execute('UPDATE folders SET name=?, remote_path=?, local_path=? WHERE id=?', (new_name, new_remote_path, new_local_path, folder_id))
                    conn.commit()
                    conn.close()
            self.load_folders()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Database Error", f"Failed to edit selected folders: {e}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

    def add_folder(self):
        dialog = FTPManagerEditFolderDialog(self)
        if dialog.exec_():
            name, remote_path, local_path = dialog.get_data()
            try:
                conn = sqlite3.connect(master_db_file)
                c = conn.cursor()
                c.execute("INSERT INTO folders (name, remote_path, local_path) VALUES (?, ?, ?)", (name, remote_path, local_path))
                conn.commit()
                conn.close()
                self.load_folders()
                
                # Find the parent FTPManagerFTPApp
                parent = self
                while parent is not None:
                    if isinstance(parent, FTPManagerFTPApp):
                        parent.update_folder_dropdowns()
                        break
                    parent = parent.parent()
                
                if parent is None:
                    raise AttributeError("Cannot find parent FTPManagerFTPApp")
                
            except sqlite3.Error as e:
                QtWidgets.QMessageBox.critical(self, "Database Error", f"Failed to add new folder: {e}")
            except AttributeError as e:
                QtWidgets.QMessageBox.warning(self, "Warning", str(e))
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

class FTPManagerAddFolderDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, name=None, remote_path=None, local_path=None):
        super().__init__(None)
        self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))   
        self.setWindowTitle('Add/Edit Folder')
        self.setGeometry(100, 100, 400, 300)
        self.setWindowFlags(QtCore.Qt.Window)

        self.name_label = QtWidgets.QLabel('Name:')
        self.name_input = QtWidgets.QLineEdit()
        if name:
            self.name_input.setText(name)

        self.remote_path_label = QtWidgets.QLabel('Remote Path:')
        self.remote_path_input = QtWidgets.QLineEdit()
        if remote_path:
            self.remote_path_input.setText(remote_path)

        self.local_path_label = QtWidgets.QLabel('Local Path:')
        self.local_path_input = QtWidgets.QLineEdit()
        if local_path:
            self.local_path_input.setText(local_path)

        self.local_path_button = QtWidgets.QPushButton('Select Folder')
        self.local_path_button.clicked.connect(self.select_local_folder)

        self.ftp_host_dropdown = QtWidgets.QComboBox()
        self.load_ftp_hosts()
        self.connect_button = QtWidgets.QPushButton('Connect to FTP')
        self.connect_button.clicked.connect(self.connect_ftp_for_remote_selection)

        self.action_dropdown = QtWidgets.QComboBox()
        self.action_dropdown.addItems(["Do Nothing", "Copy Remote to Local", "Copy Local to Remote"])

        self.remote_folder_tree = QtWidgets.QTreeWidget(self)
        self.remote_folder_tree.setHeaderLabel('Remote Folders')

        self.ok_button = QtWidgets.QPushButton('OK')
        self.ok_button.clicked.connect(self.accept)

        self.cancel_button = QtWidgets.QPushButton('Cancel')
        self.cancel_button.clicked.connect(self.reject)

        layout = QtWidgets.QGridLayout()
        layout.addWidget(self.name_label, 0, 0)
        layout.addWidget(self.name_input, 0, 1, 1, 2)
        layout.addWidget(self.remote_path_label, 1, 0)
        layout.addWidget(self.remote_path_input, 1, 1)
        layout.addWidget(self.remote_folder_tree, 1, 2)
        layout.addWidget(self.local_path_label, 2, 0)
        layout.addWidget(self.local_path_input, 2, 1)
        layout.addWidget(self.local_path_button, 2, 2)
        layout.addWidget(self.ftp_host_dropdown, 3, 0)
        layout.addWidget(self.connect_button, 3, 1)
        layout.addWidget(self.action_dropdown, 3, 2)
        layout.addWidget(self.ok_button, 4, 0)
        layout.addWidget(self.cancel_button, 4, 1, 1, 2)

        self.setLayout(layout)

    def load_ftp_hosts(self):
        conn = sqlite3.connect(master_db_file)
        c = conn.cursor()
        c.execute('SELECT host, username FROM credentials')
        rows = c.fetchall()
        self.ftp_host_dropdown.clear()
        for row in rows:
            self.ftp_host_dropdown.addItem(f"{row[1]}@{row[0]}")
        conn.close()

    def connect_ftp_for_remote_selection(self):
        selected_host = self.ftp_host_dropdown.currentText()
        if selected_host:
            try:
                username, host = selected_host.split('@')
            except ValueError:
                print("Error: Invalid credential format.")
                return
            password = self.get_password(host, username)
            if password is None:
                print("Error: No password found for the given credentials.")
                return
            try:
                self.ftp = ftplib.FTP(host)
                self.ftp.login(username, password)
                self.populate_remote_folder_tree()
            except Exception as e:
                print(f'Error connecting to FTP server: {e}')
        else:
            print("Error: No host selected.")

    def select_local_folder(self):
        folder = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select Local Folder')
        if folder:
            self.local_path_input.setText(folder)

    def get_password(self, host, username):
        conn = sqlite3.connect(master_db_file)
        c = conn.cursor()
        c.execute('SELECT password FROM credentials WHERE host=? AND username=?', (host, username))
        row = c.fetchone()
        conn.close()
        return row[0] if row else None

    def populate_remote_folder_tree(self):
        self.remote_folder_tree.clear()
        self.add_remote_folder_items('', self.remote_folder_tree)

    def add_remote_folder_items(self, path, parent_item):
        try:
            items = self.ftp.nlst(path)
            for item in items:
                item_path = os.path.join(path, item)
                tree_item = QtWidgets.QTreeWidgetItem(parent_item, [item])
                if self.is_remote_directory(item_path):
                    self.add_remote_folder_items(item_path, tree_item)
        except Exception as e:
            print(f'Error listing remote folders: {e}')

    def is_remote_directory(self, path):
        current = self.ftp.pwd()
        try:
            self.ftp.cwd(path)
            self.ftp.cwd(current)
            return True
        except ftplib.error_perm:
            return False

    @staticmethod
    def get_folder_info(parent=None, name=None, remote_path=None, local_path=None):
        dialog = FTPManagerAddFolderDialog(parent, name, remote_path, local_path)
        result = dialog.exec_()
        return (dialog.name_input.text(), dialog.remote_path_input.text(), dialog.local_path_input.text(), result == QtWidgets.QDialog.Accepted)

class FTPManagerEditFolderDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, folder=None):
        super().__init__(None)
        self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))   
        self.setWindowTitle('Edit Folder')
        self.setGeometry(100, 100, 600, 400)

        self.folder = folder

        # Name
        self.name_label = QtWidgets.QLabel('Name:')
        self.name_input = QtWidgets.QLineEdit(self)
        self.name_input.setToolTip('Enter the name of the folder.')
        if self.folder:
            self.name_input.setText(self.folder[0])

        # Local Path
        self.local_path_label = QtWidgets.QLabel('Local Path:')
        self.local_path_input = QtWidgets.QLineEdit(self)
        self.local_path_button = QtWidgets.QPushButton('Select Folder', self)
        self.local_path_button.setToolTip('Click to choose a local directory.')
        self.local_path_button.clicked.connect(self.select_local_folder)
        if self.folder:
            self.local_path_input.setText(self.folder[2])

        # Remote Path
        self.remote_path_label = QtWidgets.QLabel('Remote Path:')
        self.remote_path_input = QtWidgets.QLineEdit(self)
        self.remote_path_input.setToolTip('Double-click a folder in the "Remote Folders" tree to select it.')
        if self.folder:
            self.remote_path_input.setText(self.folder[1])

        # Remote Folders Tree
        self.remote_folder_tree = QtWidgets.QTreeWidget(self)
        self.remote_folder_tree.setHeaderLabel('Remote Folders')
        self.remote_folder_tree.itemDoubleClicked.connect(self.set_remote_path)

        # FTP Host Dropdown and Connect Button
        self.ftp_host_dropdown = QtWidgets.QComboBox(self)
        self.load_ftp_hosts()
        self.connect_button = QtWidgets.QPushButton('Connect to FTP', self)
        self.connect_button.clicked.connect(self.connect_ftp_for_remote_selection)

        # Save and Cancel Buttons
        self.save_button = QtWidgets.QPushButton('Save', self)
        self.save_button.clicked.connect(self.accept)
        self.cancel_button = QtWidgets.QPushButton('Cancel', self)
        self.cancel_button.clicked.connect(self.reject)

        # Set consistent style for labels
        label_style = "background-color: lightgray; padding: 2px;"
        self.name_label.setStyleSheet(label_style)
        self.local_path_label.setStyleSheet(label_style)
        self.remote_path_label.setStyleSheet(label_style)

        # Layout
        layout = QtWidgets.QGridLayout(self)
        layout.addWidget(self.name_label, 0, 0)
        layout.addWidget(self.name_input, 0, 1, 1, 3)
        layout.addWidget(self.local_path_label, 1, 0)
        layout.addWidget(self.local_path_input, 1, 1, 1, 2)
        layout.addWidget(self.local_path_button, 1, 3)
        layout.addWidget(self.remote_path_label, 2, 0)
        layout.addWidget(self.remote_path_input, 2, 1, 1, 3)
        layout.addWidget(self.remote_folder_tree, 3, 0, 1, 4)
        layout.addWidget(self.ftp_host_dropdown, 4, 0, 1, 3)
        layout.addWidget(self.connect_button, 4, 3)
        layout.addWidget(self.save_button, 5, 0, 1, 2)
        layout.addWidget(self.cancel_button, 5, 2, 1, 2)

        self.setLayout(layout)

    def load_ftp_hosts(self):
        conn = sqlite3.connect(master_db_file)
        c = conn.cursor()
        c.execute('SELECT host, username FROM credentials')
        rows = c.fetchall()
        self.ftp_host_dropdown.clear()
        for row in rows:
            self.ftp_host_dropdown.addItem(f"{row[1]}@@{row[0]}")
        conn.close()

    def connect_ftp_for_remote_selection(self):
        selected_host = self.ftp_host_dropdown.currentText().strip()
        if selected_host:
            try:
                username, host = selected_host.split('@@')
            except ValueError:
                print("Error: Invalid credential format.")
                return
        else:
            print("Error: No host selected.")
            return

        password = self.get_password(host, username)
        if password is None:
            print("Error: No password found for the given credentials.")
            return

        self.ftp_thread = FTPManagerFTPConnectThread(host, username, password, None, self)
        self.ftp_thread.connection_successful.connect(self.on_ftp_connection_successful)
        self.ftp_thread.connection_failed.connect(self.on_ftp_connection_failed)
        self.ftp_thread.start()

    def on_ftp_connection_successful(self, ftp):
        self.ftp = ftp
        self.populate_remote_folder_tree()

    def on_ftp_connection_failed(self, error):
        print(f'Error connecting to FTP server: {error}')

    def select_local_folder(self):
        folder = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select Local Folder')
        if folder:
            self.local_path_input.setText(folder)

    def set_remote_path(self, item, column):
        self.remote_path_input.setText(self.get_item_path(item))

    def get_item_path(self, item):
        path = []
        while item:
            path.append(item.text(0))
            item = item.parent()
        return '/'.join(reversed(path))

    def get_password(self, host, username):
        conn = sqlite3.connect(master_db_file)
        c = conn.cursor()
        c.execute('SELECT password FROM credentials WHERE host=? AND username=?', (host, username))
        row = c.fetchone()
        conn.close()
        return row[0] if row else None

    def populate_remote_folder_tree(self):
        self.remote_folder_tree.clear()
        self.add_remote_folder_items('', self.remote_folder_tree)

    def add_remote_folder_items(self, path, parent_item):
        try:
            items = [item for item in self.ftp.nlst(path) if item not in ['.', '..']]
            for item in items:
                item_path = os.path.join(path, item)
                if self.is_remote_directory(item_path):
                    tree_item = QtWidgets.QTreeWidgetItem(parent_item, [item])
                    self.add_remote_folder_items(item_path, tree_item)
                else:
                    # Skip files
                    pass
        except Exception as e:
            print(f'Error listing remote folders: {e}')

    def is_remote_directory(self, path):
        current = self.ftp.pwd()
        try:
            self.ftp.cwd(path)
            self.ftp.cwd(current)
            return True
        except ftplib.error_perm:
            return False

    def get_data(self):
        return self.name_input.text(), self.remote_path_input.text(), self.local_path_input.text()

class FTPManagerQuickConnectManager(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))   
        self.setWindowTitle('Quick Connect Manager')
        self.setGeometry(100, 100, 600, 400)
        self.setWindowFlags(QtCore.Qt.Window)  # Ensure it shows in the taskbar

        self.table = QtWidgets.QTableWidget(self)
        self.table.setColumnCount(5)
        self.table.setHorizontalHeaderLabels(['Select', 'Host', 'Username', 'Local Folder', 'Remote Folder'])
        self.table.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
        self.table.setSelectionMode(QtWidgets.QTableView.MultiSelection)

        self.load_quick_connects()

        self.delete_button = QtWidgets.QPushButton('Delete Selected')
        self.delete_button.clicked.connect(self.delete_selected_quick_connects)
        self.edit_button = QtWidgets.QPushButton('Edit Selected')
        self.edit_button.clicked.connect(self.edit_selected_quick_connects)
        self.add_button = QtWidgets.QPushButton('Add Quick Connect')
        self.add_button.clicked.connect(self.add_quick_connect)

        button_layout = QtWidgets.QHBoxLayout()
        button_layout.addWidget(self.add_button)
        button_layout.addWidget(self.edit_button)
        button_layout.addWidget(self.delete_button)

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(self.table)
        layout.addLayout(button_layout)

        self.setLayout(layout)

    def load_quick_connects(self):
        try:
            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            c.execute('SELECT * FROM quick_connects')
            rows = c.fetchall()
            self.table.setRowCount(len(rows))

            for i, row in enumerate(rows):
                select_item = QtWidgets.QTableWidgetItem()
                select_item.setCheckState(QtCore.Qt.Unchecked)
                select_item.setData(QtCore.Qt.UserRole, row[0])  # Store the ID for deletion
                self.table.setItem(i, 0, select_item)
                self.table.setItem(i, 1, QtWidgets.QTableWidgetItem(row[1]))
                self.table.setItem(i, 2, QtWidgets.QTableWidgetItem(row[2]))
                self.table.setItem(i, 3, QtWidgets.QTableWidgetItem(row[3]))
                self.table.setItem(i, 4, QtWidgets.QTableWidgetItem(row[4]))

            conn.close()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Database Error", f"Failed to load quick connects: {e}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

    def delete_selected_quick_connects(self):
        try:
            selected_items = self.table.selectionModel().selectedRows()
            if not selected_items:
                QtWidgets.QMessageBox.warning(self, 'No selection', 'No quick connects selected for deletion.')
                return

            reply = QtWidgets.QMessageBox.question(self, 'Confirm Delete', 'Are you sure you want to delete the selected quick connects?', QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            if reply == QtWidgets.QMessageBox.No:
                return

            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            for item in selected_items:
                row = item.row()
                select_item = self.table.item(row, 0)
                if select_item.checkState() == QtCore.Qt.Checked:
                    quick_connect_id = self.table.item(row, 0).data(QtCore.Qt.UserRole)
                    c.execute('DELETE FROM quick_connects WHERE id=?', (quick_connect_id,))
            conn.commit()
            conn.close()
            self.load_quick_connects()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Database Error", f"Failed to delete selected quick connects: {e}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

    def edit_selected_quick_connects(self):
        try:
            selected_items = self.table.selectionModel().selectedRows()
            if not selected_items:
                QtWidgets.QMessageBox.warning(self, 'No selection', 'No quick connects selected for editing.')
                return

            if len(selected_items) > 1:
                reply = QtWidgets.QMessageBox.question(self, 'Multiple selection', 'Multiple quick connects selected. Do you want to edit all selected items?', QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
                if reply == QtWidgets.QMessageBox.No:
                    return

            for item in selected_items:
                row = item.row()
                select_item = self.table.item(row, 0)
                if select_item.checkState() == QtCore.Qt.Checked:
                    quick_connect_data = [self.table.item(row, i).text() for i in range(1, 5)]
                    quick_connect_id = self.table.item(row, 0).data(QtCore.Qt.UserRole)
                    quick_connect_data.append(quick_connect_id)  # Append the ID for editing
                    dialog = FTPManagerEditQuickConnectDialog(self, quick_connect_data)
                    if dialog.exec_():
                        new_host, new_username, new_password, new_local_folder, new_remote_folder = dialog.get_data()
                        conn = sqlite3.connect(master_db_file)
                        c = conn.cursor()
                        c.execute('UPDATE quick_connects SET host=?, username=?, password=?, local_folder=?, remote_folder=? WHERE id=?', (new_host, new_username, new_password, new_local_folder, new_remote_folder, quick_connect_id))
                        conn.commit()
                        conn.close()
            self.load_quick_connects()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Database Error", f"Failed to edit selected quick connects: {e}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

    def add_quick_connect(self):
        try:
            dialog = FTPManagerEditQuickConnectDialog(self)
            if dialog.exec_():
                host, username, password, local_folder, remote_folder = dialog.get_data()
                conn = sqlite3.connect(master_db_file)
                c = conn.cursor()
                c.execute("INSERT INTO quick_connects (host, username, password, local_folder, remote_folder) VALUES (?, ?, ?, ?, ?)", (host, username, password, local_folder, remote_folder))
                conn.commit()
                conn.close()
            self.load_quick_connects()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Database Error", f"Failed to add new quick connect: {e}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

class FTPManagerEditQuickConnectDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, quick_connects=None):
        super().__init__(None)
        self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))   
        self.setWindowTitle('Edit Quick Connects')
        self.setGeometry(100, 100, 500, 600)

        self.quick_connects = quick_connects

        self.scroll_area = QtWidgets.QScrollArea(self)
        self.scroll_area.setWidgetResizable(True)
        self.scroll_widget = QtWidgets.QWidget()
        self.scroll_layout = QtWidgets.QVBoxLayout(self.scroll_widget)
        
        self.quick_connect_widgets = []

        if self.quick_connects:
            for quick_connect in self.quick_connects:
                self.add_quick_connect_section(quick_connect)

        self.scroll_area.setWidget(self.scroll_widget)

        self.save_all_button = QtWidgets.QPushButton('Save All', self)
        self.save_all_button.clicked.connect(self.save_all)

        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.addWidget(self.scroll_area)
        main_layout.addWidget(self.save_all_button)
        self.setLayout(main_layout)

    def add_quick_connect_section(self, quick_connect):
        section_widget = QtWidgets.QWidget()
        layout = QtWidgets.QGridLayout(section_widget)
        section_index = len(self.quick_connect_widgets)
        self.quick_connect_widgets.append(section_widget)

        host_label = QtWidgets.QLabel('Host:')
        host_input = QtWidgets.QLineEdit(section_widget)
        host_input.setText(quick_connect[0])

        username_label = QtWidgets.QLabel('Username:')
        username_input = QtWidgets.QLineEdit(section_widget)
        username_input.setText(quick_connect[1])

        password_label = QtWidgets.QLabel('Password:')
        password_input = QtWidgets.QLineEdit(section_widget)
        password_input.setEchoMode(QtWidgets.QLineEdit.Password)
        password_input.setText(quick_connect[2])

        local_folder_label = QtWidgets.QLabel('Local Folder:')
        local_folder_input = QtWidgets.QLineEdit(section_widget)
        local_folder_input.setText(quick_connect[3])
        local_folder_button = QtWidgets.QPushButton('Select Folder', section_widget)
        local_folder_button.clicked.connect(lambda: self.select_local_folder(local_folder_input))

        remote_folder_label = QtWidgets.QLabel('Remote Folder:')
        remote_folder_input = QtWidgets.QLineEdit(section_widget)
        remote_folder_input.setText(quick_connect[4])

        save_button = QtWidgets.QPushButton('Save', section_widget)
        save_button.clicked.connect(lambda: self.save_quick_connect(section_index))

        layout.addWidget(host_label, 0, 0)
        layout.addWidget(host_input, 0, 1, 1, 2)
        layout.addWidget(username_label, 1, 0)
        layout.addWidget(username_input, 1, 1, 1, 2)
        layout.addWidget(password_label, 2, 0)
        layout.addWidget(password_input, 2, 1, 1, 2)
        layout.addWidget(local_folder_label, 3, 0)
        layout.addWidget(local_folder_input, 3, 1)
        layout.addWidget(local_folder_button, 3, 2)
        layout.addWidget(remote_folder_label, 4, 0)
        layout.addWidget(remote_folder_input, 4, 1, 1, 2)
        layout.addWidget(save_button, 5, 0, 1, 3)

        section_widget.setLayout(layout)
        section_widget.setFrameStyle(QtWidgets.QFrame.Box | QtWidgets.QFrame.Plain)

        self.scroll_layout.addWidget(section_widget)

    def select_local_folder(self, local_folder_input):
        folder = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select Local Folder')
        if folder:
            local_folder_input.setText(folder)

    def save_quick_connect(self, index):
        section_widget = self.quick_connect_widgets[index]
        host_input = section_widget.findChild(QtWidgets.QLineEdit, section_widget.layout().itemAtPosition(0, 1).widget().objectName())
        username_input = section_widget.findChild(QtWidgets.QLineEdit, section_widget.layout().itemAtPosition(1, 1).widget().objectName())
        password_input = section_widget.findChild(QtWidgets.QLineEdit, section_widget.layout().itemAtPosition(2, 1).widget().objectName())
        local_folder_input = section_widget.findChild(QtWidgets.QLineEdit, section_widget.layout().itemAtPosition(3, 1).widget().objectName())
        remote_folder_input = section_widget.findChild(QtWidgets.QLineEdit, section_widget.layout().itemAtPosition(4, 1).widget().objectName())

        # Assuming we have a method to save the data to the database
        quick_connect_id = self.quick_connects[index][5]  # Assuming the ID is stored in the last position of the list
        self.update_quick_connect_in_db(quick_connect_id, host_input.text(), username_input.text(), password_input.text(), local_folder_input.text(), remote_folder_input.text())

    def save_all(self):
        for index in range(len(self.quick_connect_widgets)):
            self.save_quick_connect(index)

    def update_quick_connect_in_db(self, quick_connect_id, host, username, password, local_folder, remote_folder):
        try:
            conn = sqlite3.connect(master_db_file)
            c = conn.cursor()
            c.execute('UPDATE quick_connects SET host=?, username=?, password=?, local_folder=?, remote_folder=? WHERE id=?',
                      (host, username, password, local_folder, remote_folder, quick_connect_id))
            conn.commit()
            conn.close()
        except sqlite3.Error as e:
            QtWidgets.QMessageBox.critical(self, "Database Error", f"Failed to update quick connect: {e}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Unexpected error: {e}")

    def get_data(self):
        return [(self.host_input.text(), self.username_input.text(), self.password_input.text(), self.local_folder_input.text(), self.remote_folder_input.text()) for widget in self.quick_connect_widgets]
    
class FTPManagerFTPManagerWindow(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))
        self.setWindowTitle('FTP Manager')
        self.setGeometry(100, 100, 800, 600)
        self.setWindowFlags(QtCore.Qt.Window)
        self.initUI()

    def initUI(self):
        layout = QtWidgets.QVBoxLayout(self)

        # Dropdown to select tab session
        self.session_dropdown = QtWidgets.QComboBox(self)
        self.session_dropdown.currentIndexChanged.connect(self.on_session_change)

        # Button to select multiple folders
        self.select_folders_button = QtWidgets.QPushButton('Select Folders', self)
        self.select_folders_button.clicked.connect(self.select_folders)

        # Button to select multiple files
        self.select_files_button = QtWidgets.QPushButton('Select Files', self)
        self.select_files_button.clicked.connect(self.select_files)

        # Area to drag and drop files/folders
        self.drag_drop_area = FTPManagerDropArea(self)
        self.drag_drop_area.setFixedHeight(200)

        # Remote file tree viewer
        self.remote_file_tree = QtWidgets.QTreeWidget(self)
        self.remote_file_tree.setHeaderLabel('Remote Files')

        # Progress bar for folder loading
        self.progress_bar = QtWidgets.QProgressBar(self)
        self.progress_bar.setVisible(False)

        # Adding widgets to the layout
        layout.addWidget(self.session_dropdown)
        layout.addWidget(self.select_folders_button)
        layout.addWidget(self.select_files_button)
        layout.addWidget(self.drag_drop_area)
        layout.addWidget(self.remote_file_tree)
        layout.addWidget(self.progress_bar)

        self.setLayout(layout)

    def on_session_change(self):
        try:
            selected_session = self.session_dropdown.currentText()
            self.log(f"Session change requested: {selected_session}")
            if selected_session:
                session_name = selected_session.replace(" (Disconnected)", "")
                self.log(f"Processed session name: {session_name}")
                if not self.parent().is_session_connected(session_name):
                    self.log(f"Session {session_name} is not connected.")
                    QtWidgets.QMessageBox.warning(self, "Session Not Connected", "The selected session is not connected.")
                    return
                self.connect_to_session(session_name)
        except Exception as e:
            error_message = f"Error changing session: {e}"
            self.log(error_message)
            QtWidgets.QMessageBox.critical(self, "Error", error_message)

    def connect_to_session(self, session_name):
        try:
            self.log(f"Attempting to connect to session: {session_name}")
            self.ftp = self.parent().get_ftp_connection(session_name)
            if self.ftp is None:
                raise ValueError(f"No FTP connection found for session: {session_name}")
            self.log(f"FTP connection obtained for session: {session_name}")
            self.log(f"Connected to session: {session_name}")
            self.start_folder_loading_thread()
        except ValueError as ve:
            error_message = str(ve)
            self.log(error_message)
            QtWidgets.QMessageBox.critical(self, "Connection Error", error_message)
        except Exception as e:
            error_message = f"Error connecting to session {session_name}: {e}"
            self.log(error_message)
            QtWidgets.QMessageBox.critical(self, "Connection Error", error_message)

    def log(self, message):
        print(message)

    def select_folders(self):
        # Open a dialog to select multiple folders
        folder = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select Folder')
        if folder:
            self.upload_folders([folder])

    def select_files(self):
        # Open a dialog to select multiple files
        files, _ = QtWidgets.QFileDialog.getOpenFileNames(self, 'Select Files')
        if files:
            self.upload_files(files)

    def upload_folders(self, folders):
        try:
            for folder in folders:
                self.log(f"Uploading folder: {folder}")
                self.ftp_upload_folder(folder)
            self.log("Folders uploaded successfully")
        except Exception as e:
            self.log(f"Error uploading folders: {e}")

    def upload_files(self, files):
        try:
            for file in files:
                self.log(f"Uploading file: {file}")
                self.ftp_upload_file(file)
            self.log("Files uploaded successfully")
        except Exception as e:
            self.log(f"Error uploading files: {e}")

    def ftp_upload_folder(self, folder):
        try:
            for root, dirs, files in os.walk(folder):
                for directory in dirs:
                    local_dir = os.path.join(root, directory)
                    remote_dir = os.path.relpath(local_dir, folder)
                    self.ftp.mkd(remote_dir)
                    self.log(f"Created remote directory: {remote_dir}")
                for file in files:
                    local_file = os.path.join(root, file)
                    remote_file = os.path.relpath(local_file, folder)
                    with open(local_file, 'rb') as f:
                        self.ftp.storbinary(f'STOR {remote_file}', f)
                    self.log(f"Uploaded file: {local_file} to {remote_file}")
        except Exception as e:
            self.log(f"Error uploading folder {folder}: {e}")

    def ftp_upload_file(self, file):
        try:
            remote_file = os.path.basename(file)
            with open(file, 'rb') as f:
                self.ftp.storbinary(f'STOR {remote_file}', f)
            self.log(f"Uploaded file: {file} to {remote_file}")
        except Exception as e:
            self.log(f"Error uploading file {file}: {e}")

    def start_folder_loading_thread(self):
        try:
            self.folder_loading_thread = QtCore.QThread()
            self.folder_loading_worker = FolderLoadingWorker(self.ftp, self.remote_file_tree)
            self.folder_loading_worker.moveToThread(self.folder_loading_thread)
            self.folder_loading_thread.started.connect(self.folder_loading_worker.run)
            self.folder_loading_worker.finished.connect(self.folder_loading_thread.quit)
            self.folder_loading_worker.finished.connect(self.folder_loading_worker.deleteLater)
            self.folder_loading_thread.finished.connect(self.folder_loading_thread.deleteLater)
            self.folder_loading_worker.update_progress.connect(self.progress_bar.setValue)
            self.folder_loading_worker.update_maximum.connect(self.progress_bar.setMaximum)
            self.folder_loading_worker.disable_tree.connect(self.remote_file_tree.setDisabled)
            self.folder_loading_worker.show_progress.connect(self.progress_bar.setVisible)
            self.folder_loading_thread.start()
        except Exception as e:
            error_message = f"Error starting folder loading thread: {e}"
            self.log(error_message)
            QtWidgets.QMessageBox.critical(self, "Thread Error", error_message)

class FTPManagerDropArea(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.initUI()

    def initUI(self):
        layout = QtWidgets.QVBoxLayout(self)

        # Label for the drag and drop area
        label = QtWidgets.QLabel("Drag and Drop Area", self)
        label.setAlignment(QtCore.Qt.AlignCenter)

        # Central text "DRAG HERE"
        drag_here_label = QtWidgets.QLabel("DRAG HERE", self)
        drag_here_label.setAlignment(QtCore.Qt.AlignCenter)
        drag_here_label.setStyleSheet('font-size: 24px; font-weight: bold; color: #555;')

        layout.addWidget(label)
        layout.addStretch()
        layout.addWidget(drag_here_label)
        layout.addStretch()

        self.setLayout(layout)
        self.setStyleSheet('''
            DropArea {
                border: 2px dashed #aaa;
                background-color: lightgray;
                padding: 20px;
                margin: 10px;
                border-radius: 10px;
            }
        ''')

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dropEvent(self, event):
        urls = event.mimeData().urls()
        paths = [url.toLocalFile() for url in urls]
        self.parent().upload_files(paths)

class FTPManagerTutorialWindow(QWidget):
    def __init__(self, parent=None):
        super(FTPManagerTutorialWindow, self).__init__(parent)
        self.setWindowIcon(QtGui.QIcon(resource_path("app_icon.ico")))   
        self.setWindowTitle("Interactive Tutorial")
        self.setGeometry(100, 100, 800, 600)
        self.setWindowFlags(Qt.Window)

        self.layout = QVBoxLayout()

        self.webView = QWebEngineView()
        self.webView.setStyleSheet("background-color: #ffffff;")  # White background for the content
        
        self.layout.addWidget(self.webView)

        self.navigation_layout = QHBoxLayout()
        self.navigation_layout.setContentsMargins(10, 10, 10, 10)  # Margin for cleaner look

        self.back_button = QPushButton("Previous")
        self.back_button.setStyleSheet(self.button_style())
        self.back_button.clicked.connect(self.go_to_previous_page)
        self.navigation_layout.addWidget(self.back_button)

        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setStyleSheet(self.progress_bar_style())
        self.navigation_layout.addWidget(self.progress_bar)

        self.next_button = QPushButton("Next")
        self.next_button.setStyleSheet(self.button_style())
        self.next_button.clicked.connect(self.go_to_next_page)
        self.navigation_layout.addWidget(self.next_button)

        self.start_button = QPushButton("Start Using App")
        self.start_button.setStyleSheet(self.button_style())
        self.start_button.clicked.connect(self.close)
        self.navigation_layout.addWidget(self.start_button)

        self.layout.addLayout(self.navigation_layout)
        self.setLayout(self.layout)

        self.current_page_index = 0
        self.tutorial_pages = [
            self.create_welcome_page(),
            self.create_menu_bar_page(),
            self.create_tabs_page(),
            self.create_ftp_connection_page(),
            self.create_credentials_manager_page(),
            self.create_folder_manager_page(),
            self.create_quick_connect_page(),
            self.create_logging_page(),
            self.create_tray_icon_page(),
            self.create_about_page(),
            self.create_company_info_page()
        ]

        self.load_tutorial_page(self.current_page_index)

    def load_tutorial_page(self, index):
        self.webView.setHtml(self.tutorial_pages[index])
        self.progress_bar.setValue(int((index + 1) / len(self.tutorial_pages) * 100))

    def go_to_previous_page(self):
        if self.current_page_index > 0:
            self.current_page_index -= 1
            self.load_tutorial_page(self.current_page_index)

    def go_to_next_page(self):
        if self.current_page_index < len(self.tutorial_pages) - 1:
            self.current_page_index += 1
            self.load_tutorial_page(self.current_page_index)

    def open_link_in_browser(self, url):
        QtGui.QDesktopServices.openUrl(url)

    def button_style(self):
        return """
        QPushButton {
            background-color: #4CAF50; /* Green */
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            font-size: 16px;
            margin: 4px 2px;
        }
        QPushButton:hover {
            background-color: #45a049;
        }
        """

    def progress_bar_style(self):
        return """
        QProgressBar {
            border: 1px solid #bbb;
            border-radius: 5px;
            text-align: center;
        }
        QProgressBar::chunk {
            background-color: #4CAF50;
            width: 20px;
        }
        """

    def create_welcome_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h1>Welcome to FTP Manager Interactive Tutorial</h1>
            <p>In this tutorial, you will learn how to use the key features of the FTP Manager application in detail.</p>
            <p>Let's get started!</p>
        </body>
        </html>
        """

    def create_menu_bar_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Menu Bar</h2>
            <p>The menu bar provides access to the main features of the application:</p>
            <ul>
                <li><b>File</b>: Open new tabs, close tabs, and close all tabs.
                    <ul>
                        <li><b>New Tab</b>: Opens a new tab to start a new FTP session.</li>
                        <li><b>Close Tab</b>: Closes the currently active tab.</li>
                        <li><b>Close All Tabs</b>: Closes all open tabs.</li>
                    </ul>
                </li>
                <li><b>View</b>: Access Credential Manager, Folder Manager, and FTP Manager.
                    <ul>
                        <li><b>Credential Manager</b>: Opens the Credential Manager to manage saved FTP credentials.</li>
                        <li><b>Folder Manager</b>: Opens the Folder Manager to manage folder pairs for synchronization.</li>
                        <li><b>Open FTP Manager</b>: Opens the FTP Manager window.</li>
                    </ul>
                </li>
                <li><b>Help</b>: View information about the application, access the tutorial, and find donation options.
                    <ul>
                        <li><b>About</b>: Shows information about the FTP Manager application.</li>
                        <li><b>Donate</b>: Opens a dialog with information on how to donate to support the development of the application.</li>
                        <li><b>Tutorial</b>: Opens this tutorial to guide you through using the application.</li>
                    </ul>
                </li>
            </ul>
        </body>
        </html>
        """

    def create_tabs_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Tabs</h2>
            <p>The FTP Manager uses tabs to manage multiple FTP connections. Each tab represents a separate FTP session. Here is how you can manage tabs:</p>
            <ul>
                <li><b>New Tab Button</b>: Located at the end of the menu bar, clicking this button opens a new tab for a new FTP session.</li>
                <li><b>Tabs</b>: You can navigate between multiple open tabs to switch between different FTP sessions.</li>
                <li><b>Context Menu</b>: Right-click on a tab to open the context menu with options to rename the tab or close it.</li>
                <li><b>Close Tab Button</b>: Each tab has a close button ('X') to close the tab.</li>
            </ul>
        </body>
        </html>
        """

    def create_ftp_connection_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Connecting to an FTP Server</h2>
            <p>To connect to an FTP server, follow these steps:</p>
            <ul>
                <li><b>Host</b>: Enter the FTP servers host address in the Host input field.</li>
                <li><b>Username</b>: Enter your username in the Username input field.</li>
                <li><b>Password</b>: Enter your password in the Password input field. The password will be hidden for security.</li>
                <li><b>Connect Button</b>: Click the 'Connect' button to establish a connection with the FTP server.</li>
                <li><b>Save Credentials</b>: Click Save Credentials to save the current host, username, and password for future use.</li>
                <li><b>Saved Credentials Dropdown</b>: Use this dropdown to select previously saved credentials for quick access.</li>
                <li><b>Quick Connect Now</b>: This button allows for immediate connection using the selected credentials and folder setup.</li>
            </ul>
        </body>
        </html>
        """

    def create_credentials_manager_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Credential Manager</h2>
            <p>The Credential Manager allows you to manage saved FTP credentials:</p>
            <ul>
                <li><b>Add Credential</b>: Click 'Add Credential' to open a dialog where you can enter a new host, username, and password.</li>
                <li><b>Edit Selected</b>: Select a credential from the list and click 'Edit Selected' to modify the details.</li>
                <li><b>Delete Selected</b>: Select one or more credentials and click 'Delete Selected' to remove them from the list.</li>
                <li><b>Credential Table</b>: Displays all saved credentials with columns for Host, Username, and Password (masked).</li>
            </ul>
        </body>
        </html>
        """

    def create_folder_manager_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Folder Manager</h2>
            <p>The Folder Manager helps you manage local and remote folders for synchronization:</p>
            <ul>
                <li><b>Add Folder</b>: Click 'Add Folder' to open a dialog where you can specify the local and remote paths for a new folder pair.</li>
                <li><b>Edit Selected</b>: Select a folder pair from the list and click 'Edit Selected' to modify the paths.</li>
                <li><b>Delete Selected</b>: Select one or more folder pairs and click 'Delete Selected' to remove them.</li>
                <li><b>Folder Table</b>: Displays all folder pairs with columns for Name, Remote Path, and Local Path.</li>
            </ul>
        </body>
        </html>
        """

    def create_quick_connect_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Quick Connect</h2>
            <p>Quick Connect allows you to quickly connect to frequently used FTP servers:</p>
            <ul>
                <li><b>Quick Connect Dropdown</b>: Select a saved connection from this dropdown.</li>
                <li><b>Quick Connect Now Button</b>: Click this button to connect to the selected server immediately.</li>
                <li><b>Save Quick Connect</b>: Click this button to save the current connection details for future quick access.</li>
            </ul>
        </body>
        </html>
        """

    def create_logging_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>Logging</h2>
            <p>The application maintains a detailed log of actions and events:</p>
            <ul>
                <li><b>Log Area</b>: Displays the log messages in real-time as they occur.</li>
                <li><b>Save Log Button</b>: Click this button to save the log messages to a file for later review.</li>
                <li><b>Log Toggle</b>: Use this checkbox to show or hide the log section.</li>
            </ul>
        </body>
        </html>
        """

    def create_tray_icon_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                ul { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>System Tray Icon</h2>
            <p>The application provides a system tray icon for quick access:</p>
            <ul>
                <li><b>Open</b>: Opens the application window.</li>
                <li><b>Quick Connect Menu</b>: Access saved quick connections directly from the tray icon.</li>
                <li><b>Managers Menu</b>: Quickly access the Credential Manager, Folder Manager, and Quick Connect Manager.</li>
                <li><b>Quit</b>: Exit the application.</li>
            </ul>
        </body>
        </html>
        """

    def create_about_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
            </style>
        </head>
        <body>
            <h2>About</h2>
            <p>This is an FTP Manager application developed by The Solutions To Problems, LLC (TSTP). For more information, visit our website or follow us on our social media channels.</p>
        </body>
        </html>
        """

    def create_company_info_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h2 { color: #333; }
                p { font-size: 14px; }
                .button-row {
                    display: flex;
                    justify-content: space-around;
                    margin-top: 20px;
                }
                .social-button {
                    background-color: #4CAF50;
                    border: none;
                    color: white;
                    padding: 10px 24px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    font-size: 16px;
                    cursor: pointer;
                }
                .social-button:hover {
                    background-color: #45a049;
                }
            </style>
        </head>
        <body>
            <h2>About The Solutions To Problems, LLC (TSTP)</h2>
            <p>Custom Solutions at The Heart of Innovation: Your Challenge, Our Mission</p>
            <p>At The Solutions To Problems, LLC (TSTP), we are not just about developing software; we are about creating solutions. Our foundation is built on the belief that the best innovations arise from addressing real, tangible problems.</p>
            <p>This philosophy has led us to develop a range of products that are as diverse as they are functional, each born from a need, a frustration, or a gap in existing technological offerings. Our mission is simple yet profound: to eliminate productivity issues across all aspects of computer usage, transforming challenges into opportunities for efficiency and ease.</p>
            <p>The Essence of Our Innovation: Driven by User Needs</p>
            <p>Every TSTP product stems from a direct need or problem articulated by users like you. Our development process is a testament to our commitment to listening, understanding, and acting on the challenges you face, ensuring that our solutions not only meet but exceed expectations.</p>
            <p>Your Input: The Catalyst for Our Next Solution</p>
            <p>This approach to solving specific, real-world problems exemplifies how we operate. But what about the challenges you face daily? Whether it is a task that could be faster, a process that could be smoother, or a problem you think no one has tackled yet, we want to hear from you.</p>
            <p>Your experiences, struggles, and needs are the seeds from which our next solutions will grow. By sharing your challenges with us, you are not just finding a solution for yourself; you are contributing to a future where technology makes all our lives easier.</p>
            <p>Get Involved</p>
            <p>Reach out to us at Support@TSTP.xyz with your ideas, challenges, or feedback on our existing tools. Explore our product range at <a href="https://www.tstp.xyz" target="_blank">TSTP.xyz</a> and let us know how we can tailor our technologies to better serve your needs.</p>
            <p>At The Solutions To Problems, LLC, your challenges are our inspiration. Together, let us redefine the boundaries of what technology can achieve, creating custom solutions that bring peace, efficiency, and innovation to every computing session.</p>
            <div class="button-row">
                <a class="social-button" href="https://www.linkedin.com/company/thesolutions-toproblems/" target="_blank">LinkedIn</a>
                <a class="social-button" href="https://www.facebook.com/profile.php?id=61557162643039" target="_blank">Facebook</a>
                <a class="social-button" href="https://twitter.com/TSTP_LLC" target="_blank">Twitter</a>
                <a class="social-button" href="https://www.youtube.com/@yourpststudios/" target="_blank">YouTube</a>
                <a class="social-button" href="https://github.com/TSTP-Enterprises" target="_blank">GitHub</a>
            </div>
        </body>
        </html>
        """

################################ FTP MANAGER END ################################

################################ NETWORK PASSWORD TOOL START ####################

class NetworkPasswordPasswordRetriever(QThread):
    password_retrieved = pyqtSignal(str, str, str)
    progress_updated = pyqtSignal(int)

    def __init__(self, profiles):
        super().__init__()
        self.profiles = profiles

    def run(self):
        for i, profile in enumerate(self.profiles):
            try:
                result = subprocess.check_output(f'netsh wlan show profile "{profile}" key=clear', shell=True, text=True, stderr=subprocess.DEVNULL)
                password_line = [line for line in result.split('\n') if 'Key Content' in line]
                if password_line:
                    password = password_line[0].split(':')[1].strip()
                else:
                    password = ''
                self.password_retrieved.emit(profile, password, '')
            except subprocess.CalledProcessError as e:
                self.password_retrieved.emit(profile, '', str(e))
            self.progress_updated.emit(int((i + 1) / len(self.profiles) * 100))

class NetworkPassTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.profiles = []
        self.passwords = {}
        self.compact_mode = False
        self.initUI()

    def initUI(self):
        self.setWindowTitle('TSTP:Network Password Tool')
        self.setGeometry(100, 100, 710, 300)
        self.setMinimumWidth(710)
        self.setMaximumWidth(710)
        self.setWindowIcon(QIcon(resource_path("app_icon.ico")))

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)

        self.layout = QVBoxLayout()
        self.central_widget.setLayout(self.layout)

        self.create_menu()
        self.create_search_bar()
        self.create_scroll_area()
        self.create_bottom_buttons()
        self.create_status_bar()

    def create_menu(self):
        self.menu_bar = self.menuBar()

        file_menu = self.menu_bar.addMenu('File')
        
        refresh_action = QAction('Refresh Profiles', self)
        refresh_action.triggered.connect(self.refresh_profiles)
        file_menu.addAction(refresh_action)

        export_action = QAction('Export Passwords', self)
        export_action.triggered.connect(self.export_passwords)
        file_menu.addAction(export_action)
        
        exit_action = QAction('Exit', self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        view_menu = self.menu_bar.addMenu('View')
        
        compact_mode_action = QAction('Compact Mode', self)
        compact_mode_action.triggered.connect(self.toggle_compact_mode)
        view_menu.addAction(compact_mode_action)

        help_menu = self.menu_bar.addMenu('Help')
        tutorial_action = QAction('Show Tutorial', self)
        tutorial_action.triggered.connect(self.open_np_tutorial)
        help_menu.addAction(tutorial_action)
        
    def open_np_tutorial(self):
        tutorial_window = NetworkPasswordTutorialWindow(self)
        tutorial_window.exec_() 

    def create_search_bar(self):
        search_layout = QHBoxLayout()
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText('Search networks...')
        self.search_bar.textChanged.connect(self.filter_networks)
        search_layout.addWidget(self.search_bar)
        self.layout.addLayout(search_layout)

    def create_scroll_area(self):
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.network_container = QWidget()
        self.network_layout = QVBoxLayout()
        self.network_container.setLayout(self.network_layout)
        self.scroll_area.setWidget(self.network_container)
        self.layout.addWidget(self.scroll_area)

    def create_bottom_buttons(self):
        self.button_layout_bottom = QHBoxLayout()
        
        self.refresh_button = QPushButton('Refresh Profiles')
        self.refresh_button.clicked.connect(self.refresh_profiles)
        self.button_layout_bottom.addWidget(self.refresh_button)

        self.toggle_all_button = QPushButton('Toggle All')
        self.toggle_all_button.clicked.connect(self.toggle_all_groupboxes)
        self.button_layout_bottom.addWidget(self.toggle_all_button)

        self.save_button = QPushButton('Export Passwords')
        self.save_button.clicked.connect(self.export_passwords)
        self.button_layout_bottom.addWidget(self.save_button)

        self.show_all_button = QPushButton('Show All Passwords')
        self.show_all_button.clicked.connect(self.toggle_all_passwords)
        self.button_layout_bottom.addWidget(self.show_all_button)

        self.compact_mode_button = QPushButton('Compact Mode')
        self.compact_mode_button.clicked.connect(self.toggle_compact_mode)
        self.button_layout_bottom.addWidget(self.compact_mode_button)

        self.layout.addLayout(self.button_layout_bottom)

    def create_status_bar(self):
        self.status_bar = QLabel('Ready')
        self.layout.addWidget(self.status_bar)

        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        self.layout.addWidget(self.progress_bar)

    def load_profiles(self):
        self.profiles = []
        self.passwords = {}
        try:
            result = subprocess.check_output('netsh wlan show profile', shell=True, text=True)
            self.profiles = [line.split(':')[1].strip() for line in result.split('\n') if 'All User Profile' in line]
            self.status_bar.setText(f'Found {len(self.profiles)} networks')
            self.retrieve_passwords()
        except subprocess.CalledProcessError as e:
            QMessageBox.critical(self, 'Error', f'Failed to retrieve network profiles.\n{str(e)}')

    def retrieve_passwords(self):
        self.progress_bar.setVisible(True)
        self.password_retriever = NetworkPasswordPasswordRetriever(self.profiles)
        self.password_retriever.password_retrieved.connect(self.on_password_retrieved)
        self.password_retriever.progress_updated.connect(self.progress_bar.setValue)
        self.password_retriever.finished.connect(self.on_password_retrieval_finished)
        self.password_retriever.start()

    def on_password_retrieved(self, profile, password, error):
        self.passwords[profile] = password
        if error:
            print(f"Error retrieving password for {profile}: {error}")

    def on_password_retrieval_finished(self):
        self.progress_bar.setVisible(False)
        self.populate_network_list()

    def populate_network_list(self):
        for i in reversed(range(self.network_layout.count())): 
            self.network_layout.itemAt(i).widget().setParent(None)

        for profile in self.profiles:
            self.create_profile_groupbox(profile)

    def create_profile_groupbox(self, profile_name):
        frame = QFrame()
        frame.setFrameShape(QFrame.Box)
        frame.setLayout(QHBoxLayout())

        checkbox = QCheckBox(profile_name)
        checkbox.setChecked(True)
        checkbox.setStyleSheet("text-align: left;")  # Ensure text is aligned to the left
        checkbox.stateChanged.connect(lambda state, fr=frame: self.toggle_groupbox(fr, state))
        frame.layout().addWidget(checkbox)

        password_field = QLineEdit()
        password_field.setEchoMode(QLineEdit.Password)
        password_field.setReadOnly(True)
        password_field.setFixedWidth(300)
        password_field.setText(self.passwords.get(profile_name, ''))
        frame.layout().addWidget(password_field)

        show_password_button = QPushButton('Show')
        show_password_button.setFixedSize(75, 30)
        show_password_button.clicked.connect(lambda: self.toggle_password_visibility(password_field, show_password_button))
        frame.layout().addWidget(show_password_button)

        copy_password_button = QPushButton('Copy')
        copy_password_button.setFixedSize(75, 30)
        copy_password_button.clicked.connect(lambda: self.copy_to_clipboard(password_field.text()))
        frame.layout().addWidget(copy_password_button)

        self.network_layout.addWidget(frame)

    def toggle_groupbox(self, frame, state):
        for i in range(1, frame.layout().count()):
            item = frame.layout().itemAt(i)
            if item and item.widget():
                item.widget().setVisible(state == Qt.Checked)
        frame.setFixedHeight(40 if state == Qt.Unchecked else frame.sizeHint().height())

    def toggle_all_groupboxes(self):
        all_checked = all(self.network_layout.itemAt(i).widget().findChild(QCheckBox).isChecked() 
                          for i in range(self.network_layout.count()))
        new_state = not all_checked
        for i in range(self.network_layout.count()):
            frame = self.network_layout.itemAt(i).widget()
            checkbox = frame.findChild(QCheckBox)
            checkbox.setChecked(new_state)

    def toggle_password_visibility(self, password_field, button):
        if password_field.echoMode() == QLineEdit.Password:
            password_field.setEchoMode(QLineEdit.Normal)
            button.setText('Hide')
        else:
            password_field.setEchoMode(QLineEdit.Password)
            button.setText('Show')

    def toggle_all_passwords(self):
        show_all = self.show_all_button.text() == 'Show All Passwords'
        for i in range(self.network_layout.count()):
            frame = self.network_layout.itemAt(i).widget()
            password_field = frame.findChild(QLineEdit)
            show_button = frame.findChildren(QPushButton)[0]
            password_field.setEchoMode(QLineEdit.Normal if show_all else QLineEdit.Password)
            show_button.setText('Hide' if show_all else 'Show')
        self.show_all_button.setText('Hide All Passwords' if show_all else 'Show All Passwords')

    def copy_to_clipboard(self, text):
        clipboard = QApplication.instance().clipboard()
        clipboard.setText(text)
        self.status_bar.setText('Password copied to clipboard')

    def export_passwords(self):
        export_format, ok = QInputDialog.getItem(self, "Select Export Format", 
                                                 "Choose the export format:", 
                                                 ["Text File", "CSV File", "JSON File", "XML File"], 0, False)
        if ok and export_format:
            file_filter = "Text files (*.txt)" if export_format == "Text File" else \
                          "CSV files (*.csv)" if export_format == "CSV File" else \
                          "JSON files (*.json)" if export_format == "JSON File" else \
                          "XML files (*.xml)"
            file_name, _ = QFileDialog.getSaveFileName(self, "Save File", "", file_filter)
            if file_name:
                try:
                    if export_format == "Text File":
                        self.export_to_text(file_name)
                    elif export_format == "CSV File":
                        self.export_to_csv(file_name)
                    elif export_format == "JSON File":
                        self.export_to_json(file_name)
                    else:
                        self.export_to_xml(file_name)
                    self.status_bar.setText(f'Passwords exported to {file_name}')
                except Exception as e:
                    QMessageBox.critical(self, 'Error', f'Failed to export passwords.\n{str(e)}')

    def export_to_text(self, file_name):
        with open(file_name, 'w') as file:
            for profile, password in self.passwords.items():
                file.write(f'Network: {profile}\nPassword: {password}\n\n')

    def export_to_csv(self, file_name):
        with open(file_name, 'w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(['Network', 'Password'])
            for profile, password in self.passwords.items():
                writer.writerow([profile, password])

    def export_to_json(self, file_name):
        with open(file_name, 'w') as file:
            json.dump(self.passwords, file, indent=4)

    def export_to_xml(self, file_name):
        root = ET.Element("Networks")
        for profile, password in self.passwords.items():
            network = ET.SubElement(root, "Network")
            ET.SubElement(network, "Profile").text = profile
            ET.SubElement(network, "Password").text = password

        tree = ET.ElementTree(root)
        tree.write(file_name, encoding='utf-8', xml_declaration=True)

    def filter_networks(self):
        search_text = self.search_bar.text().lower()
        for i in range(self.network_layout.count()):
            frame = self.network_layout.itemAt(i).widget()
            frame.setVisible(search_text in frame.findChild(QCheckBox).text().lower())

    def refresh_profiles(self):
        self.load_profiles()

    def toggle_compact_mode(self):
        if not self.compact_mode:
            self.compact_mode_button.setText('Full Mode')
            self.setMinimumWidth(400)
            self.setMaximumWidth(400)
            self.setGeometry(100, 100, 350, 150)
            self.search_bar.hide()
            self.scroll_area.hide()
            self.toggle_all_button.hide()
            self.show_all_button.hide()
            for i in range(self.network_layout.count()):
                self.network_layout.itemAt(i).widget().hide()
            self.compact_layout = QVBoxLayout()
            self.compact_dropdown = QComboBox()
            self.compact_dropdown.addItems(self.profiles)
            self.compact_dropdown.currentIndexChanged.connect(self.show_compact_profile)
            self.compact_layout.addWidget(self.compact_dropdown)
            self.compact_profile_container = QVBoxLayout()
            self.compact_layout.addLayout(self.compact_profile_container)
            self.layout.insertLayout(3, self.compact_layout)
            self.compact_mode = True
        else:
            self.compact_mode_button.setText('Compact Mode')
            self.setMinimumWidth(710)
            self.setMaximumWidth(710)
            self.setGeometry(100, 100, 710, 300)
            self.search_bar.show()
            self.scroll_area.show()
            self.toggle_all_button.show()
            self.show_all_button.show()
            for i in range(self.network_layout.count()):
                self.network_layout.itemAt(i).widget().show()
            self.clear_layout(self.compact_profile_container)
            self.layout.removeItem(self.compact_layout)
            self.compact_dropdown.deleteLater()
            self.compact_profile_container.deleteLater()
            self.compact_layout.deleteLater()
            self.compact_mode = False

    def show_compact_profile(self, index):
        profile_name = self.compact_dropdown.itemText(index)
        self.clear_layout(self.compact_profile_container)
        self.create_profile_groupbox_compact(profile_name)

    def create_profile_groupbox_compact(self, profile_name):
        groupbox = QGroupBox(profile_name)
        layout = QFormLayout()

        password_layout = QHBoxLayout()
        password_field = QLineEdit()
        password_field.setEchoMode(QLineEdit.Password)
        password_field.setReadOnly(True)
        password_field.setText(self.passwords.get(profile_name, ''))
        password_layout.addWidget(password_field)

        show_password_button = QPushButton('Show')
        show_password_button.setFixedSize(75, 30)
        show_password_button.clicked.connect(lambda: self.toggle_password_visibility(password_field, show_password_button))
        password_layout.addWidget(show_password_button)

        copy_password_button = QPushButton('Copy')
        copy_password_button.setFixedSize(75, 30)
        copy_password_button.clicked.connect(lambda: self.copy_to_clipboard(password_field.text()))
        password_layout.addWidget(copy_password_button)

        layout.addRow('Password:', password_layout)
        groupbox.setLayout(layout)
        self.compact_profile_container.addWidget(groupbox)

    def clear_layout(self, layout):
        while layout.count():
            child = layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

    def show_tutorial(self):
        tutorial = QDialog(self)
        tutorial.setWindowTitle('Advanced Network Password Viewer Tutorial')
        tutorial.setFixedSize(660,400)
        tutorial_layout = QVBoxLayout()

        tutorial_text = QTextEdit()
        tutorial_text.setReadOnly(True)
        tutorial_text.setFont(QFont('Arial', 10))
        tutorial_text.setHtml("""
        <h2>Welcome to the Advanced Network Password Viewer!</h2>
        <p>This application helps you manage and view Wi-Fi network passwords on your system. Here's how to use it:</p>
        <ol>
            <li><b>View Networks:</b> All saved Wi-Fi networks are displayed in the main window.</li>
            <li><b>Show/Hide Details:</b> Click the checkbox next to each network to show or hide its details.</li>
            <li><b>View Passwords:</b> Click the 'Show' button next to a password field to reveal the password.</li>
            <li><b>Copy Passwords:</b> Use the 'Copy' button to copy a password to your clipboard.</li>
            <li><b>Search Networks:</b> Use the search bar at the top to filter networks by name.</li>
            <li><b>Refresh Networks:</b> Click 'Refresh Profiles' to update the list of networks.</li>
            <li><b>Show All Passwords:</b> Use this button to reveal all passwords at once.</li>
            <li><b>Export Passwords:</b> Click 'Export Passwords' to save all passwords in various formats.</li>
            <li><b>Toggle All:</b> Use this to show/hide details for all networks at once.</li>
            <li><b>Compact Mode:</b> Switch between full and compact views for easier navigation.</li>
        </ol>
        <p><b>Note:</b> This tool requires administrative privileges to access network passwords.</p>
        """)
        tutorial_layout.addWidget(tutorial_text)

        buttons = QDialogButtonBox(QDialogButtonBox.Ok)
        buttons.accepted.connect(tutorial.accept)
        tutorial_layout.addWidget(buttons)

        tutorial.setLayout(tutorial_layout)
        tutorial.setMinimumSize(500, 400)
        tutorial.exec_()
        
    def check_admin_privileges(self):
        try:
            is_admin = os.getuid() == 0
        except AttributeError:
            is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
        if not is_admin:
            self.prompt_restart_as_admin()

    def prompt_restart_as_admin(self):
        msg_box = QMessageBox()
        msg_box.setIcon(QMessageBox.Warning)
        msg_box.setText("This program is not running with administrative privileges.")
        msg_box.setInformativeText("Would you like to restart the program as an administrator?")
        msg_box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        msg_box.setDefaultButton(QMessageBox.Yes)
        reply = msg_box.exec()

        if reply == QMessageBox.Yes:
            self.restart_as_admin()

    def restart_as_admin(self):
        if sys.platform == 'win32':
            script = os.path.abspath(sys.argv[0])
            params = ' '.join([script] + sys.argv[1:])
            ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, params, None, 1)
        else:
            # For other OSes, additional implementation is required
            print("This feature is not implemented for non-Windows platforms.")
        sys.exit()
        
class NetworkPasswordTutorialWindow(QDialog):
    def __init__(self, parent=None):
        super(NetworkPasswordTutorialWindow, self).__init__(parent)
        self.setWindowTitle("Interactive Tutorial")
        self.setGeometry(100, 100, 850, 600)
        self.setWindowModality(Qt.ApplicationModal)

        self.layout = QVBoxLayout()

        self.webView = QWebEngineView()
        self.layout.addWidget(self.webView)

        self.navigation_layout = QHBoxLayout()
        self.home_button = QPushButton("Home")
        self.home_button.clicked.connect(self.go_to_home_page)
        self.navigation_layout.addWidget(self.home_button)

        self.back_button = QPushButton("Previous")
        self.back_button.clicked.connect(self.go_to_previous_page)
        self.navigation_layout.addWidget(self.back_button)

        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.go_to_next_page)
        self.navigation_layout.addWidget(self.next_button)

        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.navigation_layout.addWidget(self.progress_bar)

        self.start_button = QPushButton("Start Using App")
        self.start_button.clicked.connect(self.close)
        self.navigation_layout.addWidget(self.start_button)

        self.layout.addLayout(self.navigation_layout)
        self.setLayout(self.layout)

        self.current_page_index = 0
        self.tutorial_pages = [
            self.create_welcome_page(),
            self.create_admin_privileges_page(),
            self.create_interface_overview_page(),
            self.create_view_networks_page(),
            self.create_refresh_profiles_page(),
            self.create_export_passwords_page(),
            self.create_about_us_page()
        ]

        self.load_tutorial_page(self.current_page_index)

    def create_welcome_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; line-height: 1.6; }
            </style>
        </head>
        <body>
            <h1>Welcome to the Interactive Tutorial</h1>
            <p>In this tutorial, you will learn how to use the key features of the Network Password Tool.</p>
            <p>Let's get started!</p>
        </body>
        </html>
        """

    def create_interface_overview_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; line-height: 1.6; }
                ul { list-style-type: disc; margin-left: 20px; }
            </style>
        </head>
        <body>
            <h1>Interface Overview</h1>
            <p>The main interface of the Network Password Tool consists of several key components:</p>
            <ul>
                <li><b>Menu Bar:</b> Contains options for refreshing profiles, exporting passwords, and accessing the tutorial.</li>
                <li><b>Search Bar:</b> Allows you to filter networks by name.</li>
                <li><b>Network List:</b> Displays all saved Wi-Fi networks.</li>
                <li><b>Bottom Buttons:</b> Buttons for refreshing profiles, exporting passwords, and toggling views.</li>
                <li><b>Status Bar:</b> Displays status messages and progress information.</li>
            </ul>
        </body>
        </html>
        """

    def create_view_networks_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; line-height: 1.6; }
                ol { list-style-type: decimal; margin-left: 20px; }
            </style>
        </head>
        <body>
            <h1>Viewing Networks</h1>
            <p>To view the saved Wi-Fi networks and their passwords:</p>
            <ol>
                <li>Run the application. The main window will display all saved Wi-Fi networks.</li>
                <li>Click the checkbox next to a network to show or hide its details.</li>
                <li>Click the 'Show' button next to the password field to reveal the password.</li>
                <li>Use the 'Copy' button to copy the password to your clipboard.</li>
            </ol>
        </body>
        </html>
        """

    def create_refresh_profiles_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; line-height: 1.6; }
            </style>
        </head>
        <body>
            <h1>Refreshing Profiles</h1>
            <p>To refresh the list of network profiles:</p>
            <ol>
                <li>Click the 'Refresh Profiles' button in the menu or at the bottom of the main window.</li>
                <li>The application will retrieve the latest list of saved Wi-Fi networks.</li>
                <li>New networks will be added to the list, and any removed networks will be updated accordingly.</li>
            </ol>
        </body>
        </html>
        """

    def create_export_passwords_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; line-height: 1.6; }
                ul { list-style-type: disc; margin-left: 20px; }
            </style>
        </head>
        <body>
            <h1>Exporting Passwords</h1>
            <p>To export the network passwords:</p>
            <ol>
                <li>Click the 'Export Passwords' button in the menu or at the bottom of the main window.</li>
                <li>Select the desired export format (Text File, CSV File, JSON File) and click 'OK'.</li>
                <li>Choose the location to save the file and enter a file name.</li>
                <li>Click 'Save' to export the passwords to the selected file format.</li>
            </ol>
        </body>
        </html>
        """

    def create_admin_privileges_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; line-height: 1.6; }
            </style>
        </head>
        <body>
            <h1>Admin Privileges</h1>
            <p>This tool requires administrative privileges to access network passwords. If the program is not running with admin privileges:</p>
            <ol>
                <li>The application will prompt you to restart with administrative privileges.</li>
                <li>Click 'Yes' to restart the application as an administrator.</li>
                <li>If running on Windows, the application will automatically restart with the necessary privileges.</li>
            </ol>
        </body>
        </html>
        """

    def create_about_us_page(self):
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; }
                h1 { color: #333; }
                p { font-size: 14px; line-height: 1.6; }
            </style>
        </head>
        <body>
            <h1>About Us</h1>
            <p><b>Custom Solutions at The Heart of Innovation: Your Challenge, Our Mission</b></p>
            <p>At The Solutions To Problems, LLC (TSTP), we are not just about developing software; we are about creating solutions. Our foundation is built on the belief that the best innovations arise from addressing real, tangible problems. This philosophy has led us to develop a range of products that are as diverse as they are functional, each born from a need, a frustration, or a gap in existing technological offerings. Our mission is simple yet profound: to eliminate productivity issues across all aspects of computer usage, transforming challenges into opportunities for efficiency and ease.</p>
            <p><b>The Essence of Our Innovation: Driven by User Needs</b></p>
            <p>Every TSTP product stems from a direct need or problem articulated by users like you. Our development process is a testament to our commitment to listening, understanding, and acting on the challenges you face, ensuring that our solutions not only meet but exceed expectations.</p>
            <p><b>Your Input: The Catalyst for Our Next Solution</b></p>
            <p>This approach to solving specific, real-world problems exemplifies how we operate. But what about the challenges you face daily? Whether it is a task that could be faster, a process that could be smoother, or a problem you think no one has tackled yet, we want to hear from you.</p>
            <p>Your experiences, struggles, and needs are the seeds from which our next solutions will grow. By sharing your challenges with us, you are not just finding a solution for yourself; you are contributing to a future where technology makes all our lives easier.</p>
            <p><b>Get Involved</b></p>
            <p>Reach out to us at Support@TSTP.xyz with your ideas, challenges, or feedback on our existing tools. Explore our product range at <a href="https://www.tstp.xyz">TSTP.xyz</a> and let us know how we can tailor our technologies to better serve your needs.</p>
            <p>At The Solutions To Problems, LLC, your challenges are our inspiration. Together, let us redefine the boundaries of what technology can achieve, creating custom solutions that bring peace, efficiency, and innovation to every computing session.</p>
            <p>Connect with us on:</p>
            <ul>
                <li><a href="https://www.linkedin.com/company/thesolutions-toproblems/">LinkedIn</a></li>
                <li><a href="https://www.facebook.com/profile.php?id=61557162643039">Facebook</a></li>
                <li><a href="https://twitter.com/TSTP_LLC">Twitter</a></li>
                <li><a href="https://www.youtube.com/@yourpststudios/">YouTube</a></li>
                <li><a href="https://github.com/TSTP-Enterprises">GitHub</a></li>
            </ul>
        </body>
        </html>
        """

    def load_tutorial_page(self, index):
        self.webView.setHtml(self.tutorial_pages[index])
        self.progress_bar.setValue(int((index + 1) / len(self.tutorial_pages) * 100))
    
    def go_to_next_page(self):
        if self.current_page_index < len(self.tutorial_pages) - 1:
            self.current_page_index += 1
            self.load_tutorial_page(self.current_page_index)

    def go_to_previous_page(self):
        if self.current_page_index > 0:
            self.current_page_index -= 1
            self.load_tutorial_page(self.current_page_index)

    def go_to_home_page(self):
        self.current_page_index = 0
        self.load_tutorial_page(self.current_page_index)

################################ NETWORK PASSWORD TOOL END ######################

################################ SPEED TEST TOOL START ##########################

class SpeedTestGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.db_path = "C:\\TSTP\\NetworkTools\\network_tools.db"
        self.results = None
        self.download_speed = 0
        self.upload_speed = 0
        self.log = []
        self.dark_mode_enabled = False
        self.initUI()
        self.is_compact_mode = False

    def initUI(self):
        self.setWindowTitle("TSTP:NT - Speed Test")
        self.setGeometry(100, 100, 800, 900)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        title_label = QLabel("Network Speed Test Tool")
        title_label.setStyleSheet("font-size: 24px; font-weight: bold;")
        main_layout.addWidget(title_label)

        self.info_label = QLabel("Press 'Start Speed Test' to begin.")
        self.info_label.setStyleSheet("font-size: 18px;")
        main_layout.addWidget(self.info_label)

        results_layout = QHBoxLayout()

        # Scrollable Local IP section
        self.scroll_area_left = QScrollArea()
        self.scroll_area_left.setWidgetResizable(True)
        self.scroll_area_left.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.result_box = QWidget()
        self.scroll_area_left.setWidget(self.result_box)
        self.result_box_layout = QVBoxLayout(self.result_box)
        results_layout.addWidget(self.scroll_area_left)

        # Scrollable additional info section
        self.scroll_area_right = QScrollArea()
        self.scroll_area_right.setWidgetResizable(True)
        self.scroll_area_right.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.additional_info_box = QWidget()
        self.scroll_area_right.setWidget(self.additional_info_box)
        self.additional_info_layout = QVBoxLayout(self.additional_info_box)
        results_layout.addWidget(self.scroll_area_right)

        main_layout.addLayout(results_layout)

        button_layout = QHBoxLayout()
        self.start_button = QPushButton("Start Speed Test")
        self.start_button.clicked.connect(self.startSpeedTest)
        self.start_button.setStyleSheet("""
            QPushButton {
                padding: 10px;
                font-size: 16px;
                background-color: #343a40;
                color: white;
                border: none;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #23272b;
            }
            QPushButton:disabled {
                background-color: #6c757d;
                color: #fff;
            }
        """)
        button_layout.addWidget(self.start_button)

        self.export_button = QPushButton("Export Results")
        self.export_button.clicked.connect(self.exportResults)
        self.export_button.setVisible(False)
        self.export_button.setStyleSheet("""
            QPushButton {
                padding: 10px;
                font-size: 16px;
                background-color: #5a6268;
                color: white;
                border: none;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #434a4f;
            }
        """)
        button_layout.addWidget(self.export_button)

        main_layout.addLayout(button_layout)

        dropdown_layout = QHBoxLayout()
        self.download_size_dropdown = QComboBox()
        self.download_size_dropdown.addItems(["1MB", "5MB", "10MB", "20MB", "30MB", "40MB", "50MB", "100MB", "1000MB"])
        dropdown_layout.addWidget(QLabel("Download Size:"))
        dropdown_layout.addWidget(self.download_size_dropdown)

        self.upload_size_dropdown = QComboBox()
        self.upload_size_dropdown.addItems(["1MB", "5MB", "10MB", "20MB", "30MB", "40MB", "50MB", "100MB"])
        dropdown_layout.addWidget(QLabel("Upload Size:"))
        dropdown_layout.addWidget(self.upload_size_dropdown)

        self.adapter_dropdown = QComboBox()
        self.adapter_dropdown.addItems([adapter for adapter, snics in psutil.net_if_addrs().items()])
        dropdown_layout.addWidget(QLabel("Adapter:"))
        dropdown_layout.addWidget(self.adapter_dropdown)

        main_layout.addLayout(dropdown_layout)

        self.figure, self.ax = plt.subplots()
        self.canvas = FigureCanvas(self.figure)
        self.canvas.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        main_layout.addWidget(self.canvas)

        self.log_text_edit = QTextEdit()
        self.log_text_edit.setReadOnly(True)
        self.log_text_edit.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        main_layout.addWidget(self.log_text_edit)

        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        self.progress_bar.setFixedHeight(30)
        self.progress_bar.setFormat("%p%")
        main_layout.addWidget(self.progress_bar)

        self.speed_bar = QProgressBar()
        self.speed_bar.setVisible(False)
        self.speed_bar.setFixedHeight(30)
        self.speed_bar.setMaximum(100)  # Cap at 100Mbps for the pseudo speedometer
        self.speed_bar.setFormat("%v Mbps")
        main_layout.addWidget(self.speed_bar)

        self.initMenu()
        self.initStatusBar()

        current_dir = os.path.dirname(os.path.realpath(__file__))
        icon_path = os.path.join(current_dir, 'app_icon.ico')
        self.setWindowIcon(QIcon(icon_path))

        # Create System Tray Icon
        self.trayIcon = QSystemTrayIcon(self)
        self.trayIcon.setIcon(QIcon(icon_path))

        # Tray icon click event
        self.trayIcon.activated.connect(self.onTrayIconActivated)

    def updateResults(self, results):
        self.results = results
        local_ips = self.results['client']['local_ip']
        external_ip = self.results['client']['external_ip']
        hostname = socket.gethostname()
        self.info_label.setText("Test Complete.")
        self.download_speed = results['download_speed']
        self.upload_speed = results['upload_speed']
        self.plotResults()
        self.export_button.setVisible(True)
        self.progress_bar.setVisible(False)
        self.speed_bar.setVisible(False)
        self.start_button.setEnabled(True)

        # Clear previous results
        self.clearLayout(self.result_box_layout)
        self.clearLayout(self.additional_info_layout)

        for adapter, ip in local_ips.items():
            adapter_widget = QWidget()
            adapter_layout = QVBoxLayout(adapter_widget)
            adapter_layout.addWidget(QLabel(f"Adapter: {adapter}"))
            adapter_layout.addWidget(QLabel(f"IP: {ip}"))
            adapter_widget.setStyleSheet("""
                QWidget {
                    margin: 5px;
                    padding: 5px;
                    border: 1px solid #ccc;
                    border-radius: 5px;
                }
            """)
            self.result_box_layout.addWidget(adapter_widget)

        self.additional_info_layout.addWidget(QLabel(f"WAN IP: {external_ip}"))
        self.additional_info_layout.addWidget(QLabel(f"Hostname: {hostname}"))
        download_label = QLabel(f"Download Speed: {self.download_speed:.2f} Mbps")
        download_label.setStyleSheet("background-color: #007BFF; color: white; padding: 10px; border-radius: 5px;")
        self.additional_info_layout.addWidget(download_label)
        upload_label = QLabel(f"Upload Speed: {self.upload_speed:.2f} Mbps")
        upload_label.setStyleSheet("background-color: #28a745; color: white; padding: 10px; border-radius: 5px;")
        self.additional_info_layout.addWidget(upload_label)
        adapter_label = QLabel(f"Used Adapter: {self.adapter_dropdown.currentText()} (IP: {local_ips[self.adapter_dropdown.currentText()]})")
        adapter_label.setStyleSheet("background-color: #ffc107; color: black; padding: 10px; border-radius: 5px;")
        self.additional_info_layout.addWidget(adapter_label)

        if self.connectToDB():
            try:
                self.cursor.execute("""INSERT INTO speed_tests (timestamp, local_ip, external_ip, hostname, download_speed, upload_speed)
                                       VALUES (?, ?, ?, ?, ?, ?)""", (datetime.now().strftime('%Y-%m-%d %H:%M:%S'), ', '.join(local_ips.values()), external_ip, hostname, self.download_speed, self.upload_speed))
                self.conn.commit()
            except sqlite3.Error as e:
                QMessageBox.warning(self, "Database Error", f"Failed to save speed test results to the database:\n{str(e)}")
            finally:
                self.conn.close()

    def toggleCompactMode(self):
        if self.is_compact_mode:
            self.setGeometry(100, 100, 800, 900)
            self.canvas.setVisible(True)
            self.result_box.setVisible(True)
            self.additional_info_box.setVisible(True)
            self.log_text_edit.setVisible(True)
            self.is_compact_mode = False
            self.compact_mode_action.setText('Compact Mode')
        else:
            self.setGeometry(100, 100, 400, 200)
            self.canvas.setVisible(False)
            self.result_box.setVisible(False)
            self.additional_info_box.setVisible(False)
            self.log_text_edit.setVisible(True)
            self.is_compact_mode = True
            self.compact_mode_action.setText('Normal Mode')

    def initMenu(self):
        menubar = self.menuBar()
        menubar.setStyleSheet("""
            QMenuBar {
                background-color: #343a40;
                color: #fff;
                padding: 5px;
            }
            QMenuBar::item {
                padding: 5px 10px;
            }
            QMenuBar::item:selected {
                background-color: #212529;
            }
        """)

        file_menu = menubar.addMenu('File')
        file_menu.setStyleSheet("""
            QMenu {
                background-color: #fff;
                color: #000;
                padding: 5px;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #007bff;
                color: #fff;
            }
        """)

        export_action = QAction('Export Results', self)
        export_action.triggered.connect(self.exportResults)
        file_menu.addAction(export_action)

        file_menu.addSeparator()

        exit_action = QAction('Exit', self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        view_menu = menubar.addMenu('View')
        view_menu.setStyleSheet("""
            QMenu {
                background-color: #fff;
                color: #000;
                padding: 5px;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #007bff;
                color: #fff;
            }
        """)

        toggle_theme_action = QAction('Toggle Dark Mode', self)
        toggle_theme_action.triggered.connect(self.toggleDarkMode)
        view_menu.addAction(toggle_theme_action)

        self.compact_mode_action = QAction('Compact Mode', self)
        self.compact_mode_action.triggered.connect(self.toggleCompactMode)
        view_menu.addAction(self.compact_mode_action)

        tools_menu = menubar.addMenu('Tools')
        tools_menu.setStyleSheet("""
            QMenu {
                background-color: #fff;
                color: #000;
                padding: 5px;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #007bff;
                color: #fff;
            }
        """)

        speed_test_action = QAction('Start Speed Test', self)
        speed_test_action.triggered.connect(self.startSpeedTest)
        tools_menu.addAction(speed_test_action)

        help_menu = menubar.addMenu('Help')
        help_menu.setStyleSheet("""
            QMenu {
                background-color: #fff;
                color: #000;
                padding: 5px;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #007bff;
                color: #fff;
            }
        """)

        about_action = QAction('About', self)
        about_action.triggered.connect(self.showAboutDialog)
        help_menu.addAction(about_action)

    def clearLayout(self, layout):
        if layout is not None:
            while layout.count():
                child = layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()

    def initStatusBar(self):
        self.statusBar().setStyleSheet("""
            QStatusBar {
                background-color: #fff;
                border-top: 1px solid #ccc;
                padding: 5px;
            }
            QLabel {
                color: #000;
            }
        """)
        self.statusBar().showMessage("Ready")

    def onTrayIconActivated(self, reason):
        if reason == QSystemTrayIcon.Trigger:
            self.show()

    def closeEvent(self, event):
        event.ignore()
        self.hide()
        self.trayIcon.showMessage("Application Minimized", "Application will keep running in the system tray.")

    def startSpeedTest(self):
        self.statusBar().showMessage("Speed test started...")
        self.start_button.setDisabled(True)
        self.progress_bar.setVisible(True)
        self.speed_bar.setVisible(True)
        self.test_thread = SpeedTestThread(
            download_size=self.download_size_dropdown.currentText(),
            upload_size=self.upload_size_dropdown.currentText(),
            selected_adapter=self.adapter_dropdown.currentText()
        )
        self.test_thread.update_signal.connect(self.updateResults)
        self.test_thread.progress_signal.connect(self.updateProgress)
        self.test_thread.error_signal.connect(self.handleError)
        self.test_thread.log_signal.connect(self.updateLog)
        self.test_thread.start()

    def updateProgress(self, test_type, progress, speed):
        self.info_label.setText(f"{test_type.capitalize()} Progress: {progress:.2f}% at {speed:.2f} Mbps")
        self.progress_bar.setValue(int(progress))
        self.speed_bar.setValue(int(speed))

        if test_type == 'download':
            self.updateLog(f"Download speed: {speed:.2f} Mbps")
        elif test_type == 'upload':
            self.updateLog(f"Upload speed: {speed:.2f} Mbps")

    def updateLog(self, message):
        self.log.append(message)
        self.log_text_edit.append(message)
        self.log_text_edit.verticalScrollBar().setValue(self.log_text_edit.verticalScrollBar().maximum())

    def connectToDB(self):
        try:
            self.conn = sqlite3.connect(self.db_path)
            self.cursor = self.conn.cursor()
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Database Error", f"Failed to connect to the database:\n{str(e)}")
            return False
        return True

    def handleError(self, error_message):
        QMessageBox.critical(self, "Speed Test Failed", error_message)
        self.start_button.setEnabled(True)
        self.progress_bar.setVisible(False)
        self.speed_bar.setVisible(False)
        self.statusBar().showMessage("Speed test failed")

    def plotResults(self):
        labels = ['Download', 'Upload']
        speeds = [self.download_speed, self.upload_speed]
        self.ax.clear()
        self.ax.bar(labels, speeds, color=['skyblue', 'lightgreen'])
        self.ax.set_ylabel('Speed in Mbps')
        self.ax.set_title('Speed Test Results')
        if self.dark_mode_enabled:
            self.ax.set_facecolor('#343a40')
            self.ax.spines['bottom'].set_color('white')
            self.ax.spines['top'].set_color('white')
            self.ax.spines['left'].set_color('white')
            self.ax.spines['right'].set_color('white')
            self.ax.tick_params(axis='x', colors='white')
            self.ax.tick_params(axis='y', colors='white')
            self.ax.yaxis.label.set_color('white')
            self.ax.title.set_color('white')
        self.canvas.draw()

    def displayResults(self, local_ip, external_ip, hostname):
        self.results_box_layout.addWidget(QLabel(f"Local IP: {local_ip}"))
        self.results_box_layout.addWidget(QLabel(f"WAN IP: {external_ip}"))
        self.results_box_layout.addWidget(QLabel(f"Hostname: {hostname}"))
        self.results_box_layout.addWidget(QLabel(f"Download Speed: {self.download_speed:.2f} Mbps"))
        self.results_box_layout.addWidget(QLabel(f"Upload Speed: {self.upload_speed:.2f} Mbps"))

    def exportResults(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        file_name, _ = QFileDialog.getSaveFileName(self, "Save Results", "", "CSV Files (*.csv);;Text Files (*.txt);;PDF Files (*.pdf);;HTML Files (*.html)", options=options)
        if file_name:
            if file_name.endswith('.csv'):
                self.export_to_csv(file_name)
            elif file_name.endswith('.txt'):
                self.export_to_txt(file_name)
            elif file_name.endswith('.pdf'):
                self.export_to_pdf(file_name)
            elif file_name.endswith('.html'):
                self.export_to_html(file_name)
            else:
                QMessageBox.warning(self, "Export Failed", "Unsupported file format")

    def export_to_csv(self, file_name):
        try:
            with open(file_name, 'w', newline='') as csvfile:
                fieldnames = ['Timestamp', 'Local IP', 'WAN IP', 'Hostname', 'Download Speed (Mbps)', 'Upload Speed (Mbps)']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerow({
                    'Timestamp': self.results['timestamp'],
                    'Local IP': ', '.join(self.results['client']['local_ip']),
                    'WAN IP': self.results['client']['external_ip'],
                    'Hostname': socket.gethostname(),
                    'Download Speed (Mbps)': self.download_speed,
                    'Upload Speed (Mbps)': self.upload_speed
                })
            QMessageBox.information(self, "Export Successful", f"The results were successfully exported to {file_name}.")
        except Exception as e:
            QMessageBox.warning(self, "Export Failed", f"Failed to export the results:\n{str(e)}")

    def export_to_txt(self, file_name):
        try:
            with open(file_name, 'w') as txtfile:
                txtfile.write(f"Timestamp: {self.results['timestamp']}\n")
                txtfile.write(f"Local IP: {', '.join(self.results['client']['local_ip'])}\n")
                txtfile.write(f"WAN IP: {self.results['client']['external_ip']}\n")
                txtfile.write(f"Hostname: {socket.gethostname()}\n")
                txtfile.write(f"Download Speed: {self.download_speed:.2f} Mbps\n")
                txtfile.write(f"Upload Speed: {self.upload_speed:.2f} Mbps\n")
            QMessageBox.information(self, "Export Successful", f"The results were successfully exported to {file_name}.")
        except Exception as e:
            QMessageBox.warning(self, "Export Failed", f"Failed to export the results:\n{str(e)}")

    def export_to_pdf(self, file_name):
        try:
            pdf = FPDF()
            pdf.add_page()
            pdf.set_font("Arial", size=12)
            pdf.cell(200, 10, txt="Speed Test Results", ln=True, align='C')
            pdf.cell(200, 10, txt=f"Timestamp: {self.results['timestamp']}", ln=True, align='L')
            pdf.cell(200, 10, txt=f"Local IP: {', '.join(self.results['client']['local_ip'])}", ln=True, align='L')
            pdf.cell(200, 10, txt=f"WAN IP: {self.results['client']['external_ip']}", ln=True, align='L')
            pdf.cell(200, 10, txt=f"Hostname: {socket.gethostname()}", ln=True, align='L')
            pdf.cell(200, 10, txt=f"Download Speed: {self.download_speed:.2f} Mbps", ln=True, align='L')
            pdf.cell(200, 10, txt=f"Upload Speed: {self.upload_speed:.2f} Mbps", ln=True, align='L')
            pdf.output(file_name)
            QMessageBox.information(self, "Export Successful", f"The results were successfully exported to {file_name}.")
        except Exception as e:
            QMessageBox.warning(self, "Export Failed", f"Failed to export the results:\n{str(e)}")

    def export_to_html(self, file_name):
        try:
            soup = BeautifulSoup('<html><head><title>Speed Test Results</title></head><body></body></html>', 'html.parser')
            body = soup.body
            body.append(soup.new_tag('h1'))
            body.h1.string = "Speed Test Results"
            body.append(soup.new_tag('p'))
            body.p.append(soup.new_tag('strong'))
            body.p.strong.string = f"Timestamp: {self.results['timestamp']}"
            body.append(soup.new_tag('p'))
            body.p.append(soup.new_tag('strong'))
            body.p.strong.string = f"Local IP: {', '.join(self.results['client']['local_ip'])}"
            body.append(soup.new_tag('p'))
            body.p.append(soup.new_tag('strong'))
            body.p.strong.string = f"WAN IP: {self.results['client']['external_ip']}"
            body.append(soup.new_tag('p'))
            body.p.append(soup.new_tag('strong'))
            body.p.strong.string = f"Hostname: {socket.gethostname()}"
            body.append(soup.new_tag('p'))
            body.p.append(soup.new_tag('strong'))
            body.p.strong.string = f"Download Speed: {self.download_speed:.2f} Mbps"
            body.append(soup.new_tag('p'))
            body.p.append(soup.new_tag('strong'))
            body.p.strong.string = f"Upload Speed: {self.upload_speed:.2f} Mbps"
            with open(file_name, 'w') as htmlfile:
                htmlfile.write(soup.prettify())
            QMessageBox.information(self, "Export Successful", f"The results were successfully exported to {file_name}.")
        except Exception as e:
            QMessageBox.warning(self, "Export Failed", f"Failed to export the results:\n{str(e)}")

    def restartTest(self):
        self.export_button.setVisible(False)
        self.start_button.setEnabled(True)
        self.info_label.setText("Press 'Start Speed Test' to begin.")
        self.ax.clear()
        self.canvas.draw()
        self.statusBar().showMessage("Ready")
        self.log_text_edit.clear()
        self.log = []

    def toggleDarkMode(self):
        self.dark_mode_enabled = not self.dark_mode_enabled
        self.applyDarkMode()

    def applyDarkMode(self):
        if self.dark_mode_enabled:
            self.setStyleSheet("""
                QMainWindow {
                    background-color: #212529;
                }
                QLabel {
                    color: #fff;
                }
                QTextEdit {
                    background-color: #212529;
                    color: #fff;
                }
                QMenuBar {
                    background-color: #343a40;
                    color: #fff;
                }
                QMenuBar::item:selected {
                    background-color: #212529;
                }
                QMenu {
                    background-color: #343a40;
                    color: #fff;
                }
                QMenu::item:selected {
                    background-color: #212529;
                }
                QToolBar {
                    background-color: #343a40;
                    border: none;
                }
                QStatusBar {
                    background-color: #343a40;
                    color: #fff;
                }
                QProgressBar {
                    background-color: #343a40;
                    color: #fff;
                    border: none;
                    border-radius: 5px;
                    text-align: center;
                }
                QProgressBar::chunk {
                    background-color: #007bff;
                    border-radius: 5px;
                }
            """)
        else:
            self.setStyleSheet("")

    def showAboutDialog(self):
        about_text = """
        <h2>TSTP:NT - Speed Test</h2>
        <p>Version: 1.0</p>
        <p>This application performs speed tests to measure network bandwidth.</p>
        <p>Developed by: Your Name</p>
        <p>Contact: your.email@example.com</p>
        """
        QMessageBox.about(self, "About TSTP:NT - Speed Test", about_text)

    def showHistoricalResults(self):
        if self.connectToDB():
            try:
                self.cursor.execute("SELECT * FROM speed_tests ORDER BY timestamp DESC")
                results = self.cursor.fetchall()
                if results:
                    historical_dialog = QDialog(self)
                    historical_dialog.setWindowTitle("Historical Speed Test Results")
                    layout = QVBoxLayout(historical_dialog)

                    table = QTableWidget(len(results), 6)
                    table.setHorizontalHeaderLabels(["Timestamp", "Local IP", "WAN IP", "Hostname", "Download Speed", "Upload Speed"])

                    for row, result in enumerate(results):
                        timestamp, local_ip, external_ip, hostname, download_speed, upload_speed = result
                        table.setItem(row, 0, QTableWidgetItem(str(timestamp)))
                        table.setItem(row, 1, QTableWidgetItem(local_ip))
                        table.setItem(row, 2, QTableWidgetItem(external_ip))
                        table.setItem(row, 3, QTableWidgetItem(hostname))
                        table.setItem(row, 4, QTableWidgetItem(f"{download_speed:.2f} Mbps"))
                        table.setItem(row, 5, QTableWidgetItem(f"{upload_speed:.2f} Mbps"))

                    table.resizeColumnsToContents()
                    layout.addWidget(table)

                    historical_dialog.setLayout(layout)
                    historical_dialog.exec_()
                else:
                    QMessageBox.information(self, "No Historical Results", "No historical speed test results found.")
            except sqlite3.Error as e:
                QMessageBox.warning(self, "Database Error", f"Failed to retrieve historical speed test results:\n{str(e)}")
            finally:
                self.conn.close()

    def clearHistoricalResults(self):
        confirm = QMessageBox.question(self, "Clear Historical Results", "Are you sure you want to clear all historical speed test results?",
                                       QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if confirm == QMessageBox.Yes:
            if self.connectToDB():
                try:
                    self.cursor.execute("DELETE FROM speed_tests")
                    self.conn.commit()
                    QMessageBox.information(self, "Clear Successful", "All historical speed test results have been cleared.")
                except sqlite3.Error as e:
                    QMessageBox.warning(self, "Database Error", f"Failed to clear historical speed test results:\n{str(e)}")
                finally:
                    self.conn.close()

class SpeedTestThread(QThread):
    update_signal = pyqtSignal(dict)
    progress_signal = pyqtSignal(str, float, float)
    error_signal = pyqtSignal(str)
    log_signal = pyqtSignal(str)

    def __init__(self, download_size, upload_size, selected_adapter):
        super().__init__()
        self.download_size = download_size
        self.upload_size = upload_size
        self.selected_adapter = selected_adapter

    def run(self):
        try:
            self.progress_signal.emit('download', 0, 0)
            self.progress_signal.emit('upload', 0, 0)
            self.log_signal.emit("Starting download speed test...")

            download_speed = self.test_download_speed()

            self.log_signal.emit("Starting upload speed test...")
            upload_speed = self.test_upload_speed()

            self.log_signal.emit("Starting ping test...")
            ping = self.test_ping()

            local_ip, external_ip = self.get_ip_addresses()

            results = {
                'download_speed': download_speed,
                'upload_speed': upload_speed,
                'ping': ping,
                'server': 'Custom Server',
                'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
                'bytes_received': None,
                'bytes_sent': None,
                'client': {
                    'local_ip': local_ip,
                    'external_ip': external_ip
                }
            }
            self.emit_results(results)
        except Exception as e:
            self.error_signal.emit(f"General Error: {str(e)}")

    def test_download_speed(self):
        try:
            url = f"http://ipv4.download.thinkbroadband.com/{self.download_size}.zip"
            start_time = time.time()
            response = requests.get(url, stream=True)
            response.raise_for_status()
            total_size = int(response.headers.get('content-length', 0))
            downloaded_size = 0

            for data in response.iter_content(1024):
                downloaded_size += len(data)
                elapsed_time = time.time() - start_time
                if elapsed_time > 0:
                    speed = (downloaded_size / elapsed_time) * 8 / 1e6  # Convert to Mbps
                    progress = (downloaded_size / total_size) * 100
                    self.progress_signal.emit('download', progress, speed)
                    self.log_signal.emit(f"Download progress: {progress:.2f}%, Speed: {speed:.2f} Mbps")

            return speed
        except requests.RequestException as e:
            raise Exception(f"HTTP Request Error: {str(e)}")
        except Exception as e:
            raise Exception(f"Download Speed Test Error: {str(e)}")

    def test_upload_speed(self):
        try:
            url = "http://httpbin.org/post"
            data = b"x" * int(self.upload_size.split('MB')[0]) * 1024 * 1024
            start_time = time.time()
            response = requests.post(url, data=data)
            response.raise_for_status()
            elapsed_time = time.time() - start_time

            if elapsed_time > 0:
                speed = (len(data) / elapsed_time) * 8 / 1e6  # Convert to Mbps
                self.progress_signal.emit('upload', 100, speed)
                self.log_signal.emit(f"Upload progress: 100%, Speed: {speed:.2f} Mbps")
                return speed
            else:
                raise Exception("Elapsed time for upload test is zero or negative.")
        except requests.RequestException as e:
            raise Exception(f"HTTP Request Error: {str(e)}")
        except Exception as e:
            raise Exception(f"Upload Speed Test Error: {str(e)}")

    def test_ping(self):
        try:
            hostname = "google.com"
            port = 80
            start_time = time.time()
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((hostname, port))
            s.close()
            elapsed_time = time.time() - start_time
            ping = elapsed_time * 1000  # Convert to milliseconds
            self.log_signal.emit(f"Ping: {ping:.2f} ms")
            return ping
        except socket.error as e:
            raise Exception(f"Socket Error: {str(e)}")
        except Exception as e:
            raise Exception(f"Ping Test Error: {str(e)}")

    def get_ip_addresses(self):
        try:
            ip_addresses = {}
            for interface, snics in psutil.net_if_addrs().items():
                for snic in snics:
                    if snic.family == socket.AF_INET:
                        ip_addresses[interface] = snic.address
            external_ip = requests.get("https://api.ipify.org").text
            return ip_addresses, external_ip
        except Exception as e:
            raise Exception(f"IP Retrieval Error: {str(e)}")

    def emit_results(self, results):
        try:
            self.update_signal.emit(results)
        except Exception as e:
            self.error_signal.emit(f"Emit Results Error: {str(e)}")

################################ SPEED TEST TOOL END ############################

################################ NETWORK MONITOR START ##########################

def format_bytes(size):
    # Dynamically adjust the unit of measurement
    units = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB']
    for unit in units:
        if size < 1024:
            return f"{size:.2f} {unit}", unit
        size /= 1024
    return f"{size:.2f} PB", 'PB'

class NetworkTrafficMonitor(QMainWindow):
    def __init__(self, history_length=120):
        super().__init__()
        self.db_path = local_db_path
        self.history_length = history_length
        self.sent_history = [0] * history_length
        self.recv_history = [0] * history_length
        self.network_interfaces = list(psutil.net_io_counters(pernic=True).keys())
        self.current_interface = self.network_interfaces[0] if self.network_interfaces else 'None'
        self.alert_threshold = 100 * 1024**2  # 100 MB as default threshold for alerts

        self.sent_bytes_prev = psutil.net_io_counters(pernic=True).get(self.current_interface, psutil.net_io_counters()).bytes_sent
        self.recv_bytes_prev = psutil.net_io_counters(pernic=True).get(self.current_interface, psutil.net_io_counters()).bytes_recv

        self.dark_mode_enabled = False

        self.initUI()
        self.initMenu()
        self.initToolbar()
        self.initStatusBar()
        self.initLogging()
        self.initTimer(500)

    def initUI(self):
        self.initDB()
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)

        self.figure = Figure(figsize=(6, 4), dpi=100)
        self.canvas = FigureCanvas(self.figure)
        self.canvas.setStyleSheet("background-color:transparent;")

        self.interface_selector = QComboBox()
        self.interface_selector.addItems(self.network_interfaces)
        self.interface_selector.currentIndexChanged.connect(self.changeInterface)
        self.interface_selector.setStyleSheet("""
            QComboBox {
                padding: 5px;
                border: 1px solid #ccc;
                border-radius: 5px;
                background-color: #fff;
            }
            QComboBox::drop-down {
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 20px;
                border-left-width: 1px;
                border-left-color: #ccc;
                border-left-style: solid;
                border-top-right-radius: 5px;
                border-bottom-right-radius: 5px;
            }
        """)

        self.sent_data_label = QLabel('Sent: 0 MB/sec')
        self.recv_data_label = QLabel('Received: 0 MB/sec')
        stats_layout = QHBoxLayout()
        stats_layout.addWidget(self.sent_data_label)
        stats_layout.addWidget(self.recv_data_label)

        # Extended interval options
        self.update_interval_box = QComboBox()
        self.interval_options = ['0.5 Seconds', '1 Second', '2 Seconds', '5 Seconds', '10 Seconds', '30 Seconds',
                                 '1 Minute', '5 Minutes', '10 Minutes', '15 Minutes', '30 Minutes', '45 Minutes',
                                 '1 Hour', '2 Hours', '3 Hours', '6 Hours', '12 Hours', '24 Hours']
        self.update_interval_box.addItems(self.interval_options)
        self.update_interval_box.currentIndexChanged.connect(self.changeUpdateInterval)
        self.update_interval_box.setStyleSheet("""
            QComboBox {
                padding: 5px;
                border: 1px solid #ccc;
                border-radius: 5px;
                background-color: #fff;
            }
            QComboBox::drop-down {
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 20px;
                border-left-width: 1px;
                border-left-color: #ccc;
                border-left-style: solid;
                border-top-right-radius: 5px;
                border-bottom-right-radius: 5px;
            }
        """)

        self.export_button = QPushButton('Export Data')
        self.export_button.clicked.connect(self.exportData)
        self.export_button.setStyleSheet("""
            QPushButton {
                padding: 5px 10px;
                border: none;
                border-radius: 5px;
                background-color: #007BFF;
                color: #fff;
            }
            QPushButton:hover {
                background-color: #0056b3;
            }
        """)

        self.toggle_theme_button = QPushButton('Toggle Dark Mode')
        self.toggle_theme_button.clicked.connect(self.toggleDarkMode)
        self.toggle_theme_button.setStyleSheet("""
            QPushButton {
                padding: 5px 10px;
                border: none;
                border-radius: 5px;
                background-color: #6c757d;
                color: #fff;
            }
            QPushButton:hover {
                background-color: #5a6268;
            }
        """)

        self.stats_button = QPushButton('View Detailed Stats')
        self.stats_button.clicked.connect(self.showDetailedStats)
        self.stats_button.setStyleSheet("""
            QPushButton {
                padding: 5px 10px;
                border: none;
                border-radius: 5px;
                background-color: #28a745;
                color: #fff;
            }
            QPushButton:hover {
                background-color: #218838;
            }
        """)

        layout.addWidget(self.interface_selector)
        layout.addWidget(self.canvas)
        layout.addLayout(stats_layout)
        layout.addWidget(self.update_interval_box)
        layout.addWidget(self.export_button)
        layout.addWidget(self.toggle_theme_button)
        layout.addWidget(self.stats_button)

        self.setWindowTitle('TSTP:NT - Traffic Monitor')
        self.setGeometry(100, 100, 800, 600)
        self.setStyleSheet("background-color: #f8f9fa;")
        
        current_dir = os.path.dirname(os.path.realpath(__file__))
        icon_path = os.path.join(current_dir, 'app_icon4.ico')
        self.setWindowIcon(QIcon(icon_path))
        
        # Create System Tray Icon
        self.trayIcon = QSystemTrayIcon(self)
        self.trayIcon.setIcon(QIcon(icon_path))

        # Tray icon click event
        self.trayIcon.activated.connect(self.onTrayIconActivated)

        # Tray menu
        trayMenu = QMenu(self)
        openAction = QAction("Open", self)
        openAction.triggered.connect(self.show)
        closeAction = QAction("Close", self)
        closeAction.triggered.connect(qApp.quit)
        trayMenu.addAction(openAction)
        trayMenu.addAction(closeAction)
        self.trayIcon.setToolTip('TSTP:NT - Traffic Monitor')

        self.trayIcon.setContextMenu(trayMenu)
        self.trayIcon.show()

    def initDB(self):
        if not os.path.exists(os.path.dirname(local_db_path)):
            os.makedirs(os.path.dirname(local_db_path))
        conn = sqlite3.connect(local_db_path)
        cursor = conn.cursor()
        cursor.execute("""CREATE TABLE IF NOT EXISTS users (
                            username TEXT PRIMARY KEY,
                            password TEXT NOT NULL,
                            root_folder TEXT NOT NULL,
                            permissions TEXT NOT NULL)""")
        cursor.execute("""CREATE TABLE IF NOT EXISTS logs (
                            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                            message TEXT NOT NULL)""")
        cursor.execute("""CREATE TABLE IF NOT EXISTS speed_tests (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                            local_ip TEXT NOT NULL,
                            external_ip TEXT NOT NULL,
                            hostname TEXT NOT NULL,
                            download_speed REAL NOT NULL,
                            upload_speed REAL NOT NULL)""")
        cursor.execute("""CREATE TABLE IF NOT EXISTS network_traffic (
                            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                            interface TEXT NOT NULL,
                            sent_bytes BIGINT NOT NULL,
                            recv_bytes BIGINT NOT NULL)""")
        cursor.execute("""CREATE TABLE IF NOT EXISTS network_scans (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                            target TEXT NOT NULL,
                            result TEXT NOT NULL)""")
        cursor.execute("""CREATE TABLE IF NOT EXISTS ftp_server_events (
                            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                            event TEXT NOT NULL,
                            details TEXT)""")
        cursor.execute("""CREATE TABLE IF NOT EXISTS ssh_server_logs (
                            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                            message TEXT NOT NULL)""")
        cursor.execute("""CREATE TABLE IF NOT EXISTS ssh_client_sessions (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                            hostname TEXT NOT NULL,
                            username TEXT NOT NULL,
                            command TEXT NOT NULL,
                            output TEXT)""")
        cursor.execute("""CREATE TABLE IF NOT EXISTS ftp_client_actions (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                            action TEXT NOT NULL,
                            details TEXT NOT NULL)""")
        conn.commit()
        conn.close()

    def initMenu(self):
        menubar = self.menuBar()
        menubar.setStyleSheet("""
            QMenuBar {
                background-color: #343a40;
                color: #fff;
                padding: 5px;
            }
            QMenuBar::item {
                padding: 5px 10px;
            }
            QMenuBar::item:selected {
                background-color: #212529;
            }
        """)
        
        file_menu = menubar.addMenu('File')
        file_menu.setStyleSheet("""
            QMenu {
                background-color: #fff;
                color: #000;
                padding: 5px;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #007bff;
                color: #fff;
            }
        """)
        
        export_action = QAction('Export Data', self)
        export_action.triggered.connect(self.exportData)
        file_menu.addAction(export_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction('Exit', self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        view_menu = menubar.addMenu('View')
        view_menu.setStyleSheet("""
            QMenu {
                background-color: #fff;
                color: #000;
                padding: 5px;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #007bff;
                color: #fff;
            }
        """)
        
        detailed_stats_action = QAction('Detailed Statistics', self)
        detailed_stats_action.triggered.connect(self.showDetailedStats)
        view_menu.addAction(detailed_stats_action)
        
        toggle_theme_action = QAction('Toggle Dark Mode', self)
        toggle_theme_action.triggered.connect(self.toggleDarkMode)
        view_menu.addAction(toggle_theme_action)
        
        tools_menu = menubar.addMenu('Tools')
        tools_menu.setStyleSheet("""
            QMenu {
                background-color: #fff;
                color: #000;
                padding: 5px;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #007bff;
                color: #fff;
            }
        """)
        
        speed_test_action = QAction('Speed Test', self)
        speed_test_action.triggered.connect(self.showSpeedTest)
        tools_menu.addAction(speed_test_action)
        
        network_scan_action = QAction('Network Scan', self)
        network_scan_action.triggered.connect(self.showNetworkScan)
        tools_menu.addAction(network_scan_action)
        
        network_info_action = QAction('Network Info', self)
        network_info_action.triggered.connect(self.showNetworkInfo)
        tools_menu.addAction(network_info_action)
        
        help_menu = menubar.addMenu('Help')
        help_menu.setStyleSheet("""
            QMenu {
                background-color: #fff;
                color: #000;
                padding: 5px;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #007bff;
                color: #fff;
            }
        """)
        
        help_action = QAction('Help', self)
        help_action.triggered.connect(self.showHelp)
        help_menu.addAction(help_action)
        
        about_action = QAction('About', self)
        about_action.triggered.connect(self.showAbout)
        help_menu.addAction(about_action)

    def initToolbar(self):
        toolbar = QToolBar("Main Toolbar")
        toolbar.setIconSize(QSize(16, 16))
        toolbar.setStyleSheet("""
            QToolBar {
                background-color: #fff;
                border: 1px solid #ccc;
            }
            QToolButton {
                padding: 5px;
            }
            QToolButton:hover {
                background-color: #f0f0f0;
            }
        """)
        self.addToolBar(toolbar)
        
        export_action = QAction(QIcon('export_icon.png'), 'Export Data', self)
        export_action.triggered.connect(self.exportData)
        toolbar.addAction(export_action)
        
        detailed_stats_action = QAction(QIcon('stats_icon.png'), 'Detailed Statistics', self)
        detailed_stats_action.triggered.connect(self.showDetailedStats)
        toolbar.addAction(detailed_stats_action)
        
        speed_test_action = QAction(QIcon('speed_test_icon.png'), 'Speed Test', self)
        speed_test_action.triggered.connect(self.showSpeedTest)
        toolbar.addAction(speed_test_action)
        
        network_scan_action = QAction(QIcon('network_scan_icon.png'), 'Network Scan', self)
        network_scan_action.triggered.connect(self.showNetworkScan)
        toolbar.addAction(network_scan_action)
        
        network_info_action = QAction(QIcon('network_info_icon.png'), 'Network Info', self)
        network_info_action.triggered.connect(self.showNetworkInfo)
        toolbar.addAction(network_info_action)

    def initStatusBar(self):
        self.statusBar().setStyleSheet("""
            QStatusBar {
                background-color: #fff;
                border-top: 1px solid #ccc;
                padding: 5px;
            }
            QLabel {
                color: #000;
            }
        """)
        self.statusBar().showMessage("Ready")

    def initLogging(self):
        self.log_file = open('network_traffic_log.csv', 'w', newline='')
        self.log_writer = csv.writer(self.log_file)
        self.log_writer.writerow(['Timestamp', 'Sent Bytes/sec', 'Received Bytes/sec'])

    def initTimer(self, interval):
        self.timer = QTimer()
        self.timer.timeout.connect(self.updateStats)
        self.timer.start(interval)
        
    def changeInterface(self, index):
        # Update the current_interface, and reset the prev counters
        self.current_interface = self.network_interfaces[index]
        counters = psutil.net_io_counters(pernic=True).get(self.current_interface, None)
        if counters:
            self.sent_bytes_prev = counters.bytes_sent
            self.recv_bytes_prev = counters.bytes_recv

    def changeUpdateInterval(self, index):
        # Convert selected interval to milliseconds for QTimer
        intervals_ms = [500, 1000, 2000, 5000, 10000, 30000,
                        60000, 300000, 600000, 900000, 1800000, 2700000,
                        3600000, 7200000, 10800000, 21600000, 43200000, 86400000]
        self.timer.start(intervals_ms[index])

    def toggleDarkMode(self):
        self.dark_mode_enabled = not self.dark_mode_enabled
        self.applyDarkMode()
        
    def applyDarkMode(self):
        if self.dark_mode_enabled:
            self.setStyleSheet("""
                QMainWindow {
                    background-color: #212121;
                }
                QLabel {
                    color: #fff;
                }
                QComboBox {
                    background-color: #424242;
                    color: #fff;
                    border: 1px solid #616161;
                }
                QComboBox QAbstractItemView {
                    background-color: #424242;
                    color: #fff;
                    selection-background-color: #616161;
                }
                QPushButton {
                    background-color: #424242;
                    color: #fff;
                }
                QPushButton:hover {
                    background-color: #616161;
                }
                QMenuBar {
                    background-color: #212121;
                    color: #fff;
                }
                QMenuBar::item {
                    background-color: #212121;
                    color: #fff;
                }
                QMenuBar::item:selected {
                    background-color: #424242;
                }
                QMenu {
                    background-color: #424242;
                    color: #fff;
                }
                QMenu::item:selected {
                    background-color: #616161;
                }
                QToolBar {
                    background-color: #212121;
                    border: none;
                }
                QStatusBar {
                    background-color: #212121;
                    color: #fff;
                }
            """)
        else:
            self.setStyleSheet("")

    def exportData(self):
        try:
            file_dialog = QFileDialog()
            file_dialog.setNameFilter("CSV Files (*.csv)")
            file_dialog.setDefaultSuffix("csv")
            file_path, _ = file_dialog.getSaveFileName(self, "Export Data", "", "CSV Files (*.csv)")
            if file_path:
                with open(file_path, 'w', newline='') as file:
                    writer = csv.writer(file)
                    writer.writerow(['Time', 'Sent Bytes/sec', 'Received Bytes/sec'])
                    for i in range(self.history_length):
                        writer.writerow([i, self.sent_history[i], self.recv_history[i]])
                QMessageBox.information(self, 'Export Successful', 'Data exported successfully.')
        except Exception as e:
            QMessageBox.critical(self, 'Export Failed', f'Failed to export data: {e}')

    def checkAlerts(self, sent_per_sec, recv_per_sec):
        if sent_per_sec > self.alert_threshold or recv_per_sec > self.alert_threshold:
            QMessageBox.warning(self, 'Threshold Alert', 'Network traffic exceeded the defined threshold.')

    def connectToDB(self):
        try:
            self.conn = sqlite3.connect(self.db_path)
            return self.conn.cursor()
        except sqlite3.Error as e:
            QMessageBox.critical(self, 'Database Connection Failed', f'Failed to connect to database: {e}')
            return None

    def logNetworkTraffic(self, interface, sent_bytes, recv_bytes):
        cursor = self.connectToDB()
        if cursor:
            try:
                cursor.execute("""INSERT INTO network_traffic (interface, sent_bytes, recv_bytes) 
                                  VALUES (?, ?, ?)""", (interface, sent_bytes, recv_bytes))
                self.conn.commit()
            except sqlite3.Error as e:
                QMessageBox.critical(self, 'Database Error', f'Failed to log network traffic: {e}')
            finally:
                self.conn.close()

    def updateStats(self):
        try:
            counters = psutil.net_io_counters(pernic=True).get(self.current_interface, None)
            if counters:
                new_sent_bytes = counters.bytes_sent
                new_recv_bytes = counters.bytes_recv

                sent_per_sec = new_sent_bytes - self.sent_bytes_prev
                recv_per_sec = new_recv_bytes - self.recv_bytes_prev

                self.logNetworkTraffic(self.current_interface, sent_per_sec, recv_per_sec)  # Log to DB

                self.sent_history.append(sent_per_sec)
                self.recv_history.append(recv_per_sec)
                self.sent_history = self.sent_history[-self.history_length:]
                self.recv_history = self.recv_history[-self.history_length:]

                self.sent_bytes_prev = new_sent_bytes
                self.recv_bytes_prev = new_recv_bytes

                formatted_sent, _ = format_bytes(sent_per_sec)
                formatted_recv, _ = format_bytes(recv_per_sec)

                self.sent_data_label.setText(f'Sent: {formatted_sent}/sec')
                self.recv_data_label.setText(f'Received: {formatted_recv}/sec')

                self.checkAlerts(sent_per_sec, recv_per_sec)
                self.plot()
        except Exception as e:
            QMessageBox.critical(self, 'Update Error', f'Failed to update network stats: {e}')

    def plot(self):
        try:
            self.figure.clear()
            ax = self.figure.add_subplot(111)
            ax.plot([value / 1024**2 for value in self.sent_history], label='Sent', color='blue')
            ax.plot([value / 1024**2 for value in self.recv_history], label='Received', color='green')

            ax.set_title('Network Traffic Over Time (MB)')
            ax.set_xlabel('Time (updates)')
            ax.set_ylabel('Traffic (MB/sec)')
            ax.legend(loc='upper right')
            self.applyPlotDarkMode(ax)
            self.canvas.draw()
        except Exception as e:
            QMessageBox.critical(self, 'Plot Error', f'Failed to plot network traffic: {e}')
        
    def applyPlotDarkMode(self, ax):
        if self.dark_mode_enabled:
            ax.set_facecolor('#212121')
            ax.figure.set_facecolor('#212121')
            ax.tick_params(colors='white', which='both')
            ax.yaxis.label.set_color('white')
            ax.xaxis.label.set_color('white')
            ax.title.set_color('white')
            ax.spines['bottom'].set_color('white')
            ax.spines['top'].set_color('white')
            ax.spines['left'].set_color('white')
            ax.spines['right'].set_color('white')
            ax.grid(color='#424242', linestyle='--', linewidth=0.5)
        else:
            ax.set_facecolor('white')
            ax.figure.set_facecolor('white')
            ax.tick_params(colors='black', which='both')
            ax.yaxis.label.set_color('black')
            ax.xaxis.label.set_color('black')
            ax.title.set_color('black')
            ax.spines['bottom'].set_color('black')
            ax.spines['top'].set_color('black')
            ax.spines['left'].set_color('black')
            ax.spines['right'].set_color('black')
            ax.grid(color='#ccc', linestyle='--', linewidth=0.5)

    def showDetailedStats(self):
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM network_traffic")
            data = cursor.fetchall()
            detailed_stats_window = QDialog(self)
            detailed_stats_window.setWindowTitle('Detailed Network Statistics')
            layout = QVBoxLayout(detailed_stats_window)
            table = QTableWidget(len(data), 4)
            table.setHorizontalHeaderLabels(['Timestamp', 'Interface', 'Sent Bytes', 'Received Bytes'])
            for i, row in enumerate(data):
                for j, item in enumerate(row):
                    table.setItem(i, j, QTableWidgetItem(str(item)))
            layout.addWidget(table)
            detailed_stats_window.setLayout(layout)
            detailed_stats_window.exec_()
        except sqlite3.Error as e:
            QMessageBox.critical(self, 'Database Error', f'Failed to retrieve detailed stats: {e}')

    def showSpeedTest(self):
        # Implement speed test functionality here
        pass

    def showNetworkScan(self):
        # Implement network scan functionality here
        pass

    def showNetworkInfo(self):
        # Implement network info functionality here
        pass

    def showHelp(self):
        # Implement help functionality here
        pass

    def showAbout(self):
        # Implement about functionality here
        pass

    def closeEvent(self, event):
        self.trayIcon.hide()
        self.log_file.close()
        event.accept()

    def onTrayIconActivated(self, reason):
        if reason == QSystemTrayIcon.Trigger:
            self.show()

################################ NETWORK MONITOR END ############################

def setup_notes_environment(notes_dir='notes', default_notes_dir='default_notes'):
    # Paths for the directories and files
    notes_path = os.path.join(notes_dir, 'simple_notes.txt')
    default_notes_path = os.path.join(default_notes_dir, 'default_notes.txt')

    # Ensure 'notes' directory exists
    os.makedirs(notes_dir, exist_ok=True)
    # Check if 'simple_notes.txt' exists, if not, create and write content
    if not os.path.isfile(notes_path):
        with open(notes_path, 'w', encoding='utf-8') as file:
            file.write("""
          
-
                       
ALL NOTES AVAILABLE
-Logged into DC
-Confirmed user name
-Created user account
-Ensured groups are set
-Ensured user is in the correct OU
-Confirmed settings are correct
-Created manage contact
-Sending completion message
-Logged into O365
-Confirmed user email
-Created email account
""")

    # Ensure 'default_notes' directory exists
    os.makedirs(default_notes_dir, exist_ok=True)
    # Check if 'default_notes.txt' exists, if not, create and write content
    if not os.path.isfile(default_notes_path):
        with open(default_notes_path, 'w', encoding='utf-8') as file:
            file.write("""
DC New Hire Default
-Logged into DC
-Confirmed user name
-Created user account
-Ensured groups are set
-Ensured user is in the correct OU
-Confirmed settings are correct
-
-Created manage contact
-
-Sending completion message
-
-
-
-
-

O365 New Hire Default
-Logged into O365
-Confirmed user email
-Created email account
-Assigned licenses
-Ensured groups are set
-Confirmed settings are correct
-Ensured MFA is enforced
-
-Created manage contact
-
-Sending completion message
-
-
-
-
-
""")

default_config = {
    "savePath": os.path.join(os.path.expanduser("~"), "Desktop"),
    "gifResolution": "640x480",
    "minimizeOnClose": False
}

timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

config_path = "C:\\TSTP\\OmniOmega\\Settings\\"
config_file_path = "C:\\TSTP\\OmniOmega\\Settings\\config.json"
create_config_file(config_file_path, default_config)
config = read_config_file(config_file_path)
db_path = "C:\\TSTP\\OmniOmega\\Settings\\config.db"
icon_path = resource_path('app_icon.ico')
logo_path = resource_path('logo.png')
notifications_toggle = True
            
themes = {
"Light - Default UI": """
""",
"Dark - Dark": """
    QMainWindow, QDialog, QWidget {
        background-color: #333333;
        color: #CCCCCC;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #555555;
        color: #EEEEEE;
        border: 1px solid #777777;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #666666;
    }
    QTabBar::tab, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu {
        background-color: #555555;
        color: #EEEEEE;
        border: 1px solid #777777;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #666666;
        border-color: #EEEEEE;
    }
""",
"Light - Zinc": """
    QMainWindow, QDialog, QWidget {
        background-color: #65737E;
        color: #C0C5CE;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #A7ADBA;
        color: #4F5B66;
        border: 1px solid #C0C5CE;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #B0B6C3;
    }
    QTabBar::tab {
        background-color: #A7ADBA;
        color: #4F5B66;
        border: 1px solid #C0C5CE;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #B0B6C3;
        border-color: #FFFFFF;
    }
""",
"Light - Light": """
    QMainWindow, QDialog, QWidget {
        background-color: #F0F0F0;
        color: #333333;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #FFFFFF;
        color: #333333;
        border: 1px solid #CCCCCC;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #E8E8E8;
    }
    QTabBar::tab {
        background-color: #FFFFFF;
        color: #333333;
        border: 1px solid #CCCCCC;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #E8E8E8;
        border-color: #333333;
    }
""",
"Light - Retro": """
    QMainWindow, QDialog, QWidget {
        background-color: #008080;
        color: #FFFF00;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #004040;
        color: #FFFF00;
        border: 1px solid #00FFFF;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #006060;
    }
    QTabBar::tab {
        background-color: #004040;
        color: #FFFF00;
        border: 1px solid #00FFFF;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #006060;
        border-color: #FFFF00;
    }
""",
"Light - Business": """
    QMainWindow, QDialog, QWidget {
        background-color: #E5E7E9;
        color: #5D6D7E;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #ABB2B9;
        color: #17202A;
        border: 1px solid #566573;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #BFC9CA;
    }
    QTabBar::tab {
        background-color: #ABB2B9;
        color: #17202A;
        border: 1px solid #566573;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #BFC9CA;
        border-color: #E5E7E9;
    }
""",
"Dark - Cyber": """
    QMainWindow, QDialog, QWidget {
        background-color: #1A1A1D;
        color: #C3073F;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #1F2833;
        color: #66FCF1;
        border: 1px solid #45A29E;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #0B0C10;
    }
    QTabBar::tab {
        background-color: #1F2833;
        color: #66FCF1;
        border: 1px solid #45A29E;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #0B0C10;
        border-color: #66FCF1;
    }
""",
"Dark - Nature": """
    QMainWindow, QDialog, QWidget {
        background-color: #3E6251;
        color: #A3BCB6;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #A3BCB6;
        color: #355E3B;
        border: 1px solid #4A7748;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #4A7748;
    }
    QTabBar::tab {
        background-color: #A3BCB6;
        color: #355E3B;
        border: 1px solid #4A7748;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #4A7748;
        border-color: #A3BCB6;
    }
""",            
"Dark - Ocean": """
    QMainWindow, QDialog, QWidget {
        background-color: #224870;
        color: #E0FFFF;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #2A5298;
        color: #D0E8F2;
        border: 1px solid #3E7BB6;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #1E415D;
    }
    QTabBar::tab {
        background-color: #2A5298;
        color: #D0E8F2;
        border: 1px solid #3E7BB6;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #1E415D;
        border-color: #E0FFFF;
    }
""",
"Dark - Sunset": """
    QMainWindow, QDialog, QWidget {
        background-color: #2C5364;
        color: #FFC371;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #0F2027;
        color: #F1E1B3;
        border: 1px solid #407BFF;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #1C4048;
    }
    QTabBar::tab {
        background-color: #0F2027;
        color: #F1E1B3;
        border: 1px solid #407BFF;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #1C4048;
        border-color: #FFC371;
    }
""",
"Dark - Gothic": """
    QMainWindow, QDialog, QWidget {
        background-color: #0A0A0B;
        color: #C1C1C1;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #333334;
        color: #E1E1E1;
        border: 1px solid #4D4D4F;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #1D1D1F;
    }
    QTabBar::tab {
        background-color: #333334;
        color: #E1E1E1;
        border: 1px solid #4D4D4F;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #1D1D1F;
        border-color: #C1C1C1;
    }
""",
"Light - Vintage": """
    QMainWindow, QDialog, QWidget {
        background-color: #FFDAB9;
        color: #806B2A;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #D2B48C;
        color: #404030;
        border: 1px solid #8B4513;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #A0522D;
    }
    QTabBar::tab {
        background-color: #D2B48C;
        color: #404030;
        border: 1px solid #8B4513;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #A0522D;
        border-color: #FFDAB9;
    }
""",
"Dark - Eclipse": """
    QMainWindow, QDialog, QWidget {
        background-color: #31353D;
        color: #EFEFEF;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #445878;
        color: #CDD2DE;
        border: 1px solid #5B7385;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #56687E;
    }
    QTabBar::tab {
        background-color: #445878;
        color: #CDD2DE;
        border: 1px solid #5B7385;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #56687E;
        border-color: #EFEFEF;
    }
""",
"Light - Mint": """
    QMainWindow, QDialog, QWidget {
        background-color: #E0FFEF;
        color: #33673B;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #98DFAF;
        color: #2A5334;
        border: 1px solid #3B7753;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #89C997;
    }
    QTabBar::tab {
        background-color: #98DFAF;
        color: #2A5334;
        border: 1px solid #3B7753;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #89C997;
        border-color: #E0FFEF;
    }
""",
"Dark - Royal": """
    QMainWindow, QDialog, QWidget {
        background-color: #46344E;
        color: #F1E4E8;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #8E4162;
        color: #DEC3C3;
        border: 1px solid #976390;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #77567A;
    }
    QTabBar::tab {
        background-color: #8E4162;
        color: #DEC3C3;
        border: 1px solid #976390;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #77567A;
        border-color: #F1E4E8;
    }
""",
"Dark - Neon": """
    QMainWindow, QDialog, QWidget {
        background-color: #1A1A1D;
        color: #C3073F;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #333333;
        color: #08D9D6;
        border: 1px solid #252525;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #0B0C10;
    }
    QTabBar::tab {
        background-color: #333333;
        color: #08D9D6;
        border: 1px solid #252525;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #0B0C10;
        border-color: #08D9D6;
    }
""",
"Light - Safari": """
    QMainWindow, QDialog, QWidget {
        background-color: #F7F1E3;
        color: #876445;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #D8CAB8;
        color: #5D5C61;
        border: 1px solid #B8B2A7;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #BC986A;
    }
    QTabBar::tab {
        background-color: #D8CAB8;
        color: #5D5C61;
        border: 1px solid #B8B2A7;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #BC986A;
        border-color: #F7F1E3;
    }
""",
"Dark - Deep Sea": """
    QMainWindow, QDialog, QWidget {
        background-color: #0A3D62;
        color: #E4F9FF;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #0B4F6C;
        color: #EAF6F6;
        border: 1px solid #3282B8;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #1B6A89;
    }
    QTabBar::tab {
        background-color: #0B4F6C;
        color: #EAF6F6;
        border: 1px solid #3282B8;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #1B6A89;
        border-color: #E4F9FF;
    }
""",
"Fun - Burgundy": """
    QMainWindow, QDialog, QWidget {
        background-color: #800020;
        color: #FADADD;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #900C3F;
        color: #FFD5CD;
        border: 1px solid #C70039;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #B80F0A;
    }
    QTabBar::tab {
        background-color: #900C3F;
        color: #FFD5CD;
        border: 1px solid #C70039;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #B80F0A;
        border-color: #FADADD;
    }
""",
"Dark - Forest Night": """
    QMainWindow, QDialog, QWidget {
        background-color: #154734;
        color: #E4E4E4;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #1E5631;
        color: #A4C3B2;
        border: 1px solid #356859;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #2E8B57;
    }
    QTabBar::tab {
        background-color: #1E5631;
        color: #A4C3B2;
        border: 1px solid #356859;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #2E8B57;
        border-color: #E4E4E4;
    }
""",
"Dark - Midnight Blue": """
    QMainWindow, QDialog, QWidget {
        background-color: #191970;
        color: #B0C4DE;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #000080;
        color: #E6E6FA;
        border: 1px solid #4169E1;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #0000CD;
    }
    QTabBar::tab {
        background-color: #000080;
        color: #E6E6FA;
        border: 1px solid #4169E1;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #0000CD;
        border-color: #B0C4DE;
    }
""",
"Light - Teal Blue": """
    QMainWindow, QDialog, QWidget {
        background-color: #367588;
        color: #EFF6EE;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #2C6975;
        color: #DBE7E4;
        border: 1px solid #48A9A6;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #3B8289;
    }
    QTabBar::tab {
        background-color: #2C6975;
        color: #DBE7E4;
        border: 1px solid #48A9A6;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #3B8289;
        border-color: #EFF6EE;
    }
""",
"Fun - Vampire": """
    QMainWindow, QDialog, QWidget {
        background-color: #33032F;
        color: #FFD9E8;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #5A0B4D;
        color: #FFCCF9;
        border: 1px solid #8A2BE2;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #7D297E;
    }
    QTabBar::tab {
        background-color: #5A0B4D;
        color: #FFCCF9;
        border: 1px solid #8A2BE2;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #7D297E;
        border-color: #FFD9E8;
    }
""",
"Dark - Retro Console": """
    QMainWindow, QDialog, QWidget {
        background-color: #1A1A1A;
        color: #13A10E;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #003300;
        color: #4CAF50;
        border: 1px solid #00FF00;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #005700;
    }
    QTabBar::tab {
        background-color: #003300;
        color: #4CAF50;
        border: 1px solid #00FF00;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #005700;
        border-color: #13A10E;
    }
""",
"Fun - Zombie": """
    QMainWindow, QDialog, QWidget {
        background-color: #3E3D32;
        color: #E1E8B6;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #5C5B3D;
        color: #DAE4A7;
        border: 1px solid #6C706E;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #727449;
    }
    QTabBar::tab {
        background-color: #5C5B3D;
        color: #DAE4A7;
        border: 1px solid #6C706E;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #727449;
        border-color: #E1E8B6;
    }
""",
"Light - Windows XP": """
    QMainWindow, QDialog, QWidget {
        background-color: #5B8DD3;
        color: #000000;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QCheckBox, QRadioButton, QSlider, QProgressBar {
        background-color: #FFFFFF;
        color: #000000;
        border: 2px solid #B0C4DE;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #B0C4DE;
    }
    QPushButton:pressed {
        background-color: #ADD8E6;
        border-style: inset;
    }
    QComboBox:hover, QLineEdit:hover, QTextEdit:hover {
        border-color: #1E90FF;
    }
    QMenuBar, QMenu {
        background-color: #B0C4DE;
        color: #000000;
    }
    QMenu::item:selected {
        background-color: #ADD8E6;
        color: #000000;
    }
    QStatusBar {
        background-color: #B0C4DE;
        color: #000000;
    }
    QToolBar {
        background-color: #B0C4DE;
        border-bottom: 2px solid #1E90FF;
    }
    QTabBar::tab {
        background-color: #B0C4DE;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #ADD8E6;
        border-color: #1E90FF;
    }
""",
"Light - Windows 8": """
    QMainWindow, QDialog, QWidget {
        background-color: #E1E1E1;
        color: #000000;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QCheckBox, QRadioButton, QSlider, QProgressBar {
        background-color: #FFFFFF;
        color: #000000;
        border: 1px solid #707070;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #CCCCCC;
    }
    QPushButton:pressed {
        background-color: #BBBBBB;
        border-style: inset;
    }
    QComboBox:hover, QLineEdit:hover, QTextEdit:hover {
        border-color: #606060;
    }
    QMenuBar, QMenu {
        background-color: #CCCCCC;
        color: #000000;
    }
    QMenu::item:selected {
        background-color: #BBBBBB;
        color: #000000;
    }
    QStatusBar {
        background-color: #CCCCCC;
        color: #000000;
    }
    QToolBar {
        background-color: #CCCCCC;
        border-bottom: 1px solid #505050;
    }
    QTabBar::tab {
        background-color: #CCCCCC;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #BBBBBB;
        border-color: #404040;
    }
""",
"Dark - Techno 3D": """
    QMainWindow, QDialog, QWidget {
        background-color: #1e1e1e;
        color: #00ff00;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #333333;
        color: #00ff00;
        border: 1px solid #005500;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #005500;
    }
    QTabBar::tab {
        background-color: #333333;
        color: #00ff00;
        border: 1px solid #005500;
        padding: 5px;
        margin: 2px;
    }
    QTabBar::tab:selected {
        background-color: #005500;
        border-color: #00ff00;
    }
""",
"Dark - Cosmic Pulse": """
    QMainWindow, QDialog, QWidget {
        background-color: #0a0a0a;
        color: #ff57c7;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #260026;
        color: #ff57c7;
        border: 2px solid #bd00bd;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #3d003d;
    }
    QTabBar::tab {
        background-color: #260026;
        color: #ff57c7;
        border: 1px solid #bd00bd;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #3d003d;
        border-color: #ff57c7;
    }
""",
"Dark - Neon Glow": """
    QMainWindow, QDialog, QWidget {
        background-color: #222222;
        color: #7efff5;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #2b2b2b;
        color: #7efff5;
        border: 1px solid #00ffff;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #3a3a3a;
    }
    QTabBar::tab {
        background-color: #2b2b2b;
        color: #7efff5;
        border: 1px solid #00ffff;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #3a3a3a;
        border-color: #7efff5;
    }
""",
"Dark - Crystal Ice": """
    QMainWindow, QDialog, QWidget {
        background-color: #082032;
        color: #dbe2ef;
        border: 1px solid #b1c4e0;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #334756;
        color: #dbe2ef;
        border: 2px solid #b1c4e0;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #2c394b;
    }
    QTabBar::tab {
        background-color: #334756;
        color: #dbe2ef;
        border: 1px solid #b1c4e0;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #2c394b;
        border-color: #a4b2d1;
    }
""",
"Dark - Mystic Shadow": """
    QMainWindow, QDialog, QWidget {
        background-color: #0f0f0f;
        color: #e0e0e0;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #221122;
        color: #cc88cc;
        border: 2px groove #ff55ff;
        padding: 3px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #331133;
    }
    QTabBar::tab {
        background-color: #221122;
        color: #cc88cc;
        border: 1px solid #ff55ff;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #331133;
        border-color: #ff55ff;
    }
""",
"3D - Aurora Spectrum": """
    QMainWindow, QDialog, QWidget {
        background-color: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #243B55, stop:1 #141E30);
        color: #88CCF1;
        border: 1px solid #336699;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #112233, stop:0.5 #334455, stop:1 #556677);
        color: #AACCFF;
        border: 2px solid rgba(255, 255, 255, 0.5);
        padding: 2px;
        margin: 2px;
        border-radius: 5px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #334455, stop:1 #556677);
    }
    QTabBar::tab {
        background-color: rgba(17, 34, 51, 0.8);
        color: #88CCF1;
        border: 1px solid #AACCFF;
        padding: 5px;
        margin: 2px;
        border-radius: 4px;
    }
    QTabBar::tab:selected {
        background-color: rgba(33, 66, 99, 0.9);
        border-color: #88CCF1;
    }
""",
"3D - Quantum Leap": """
    QMainWindow, QDialog, QWidget {
        background-color: qradialgradient(cx:0.5, cy:0.5, radius: 1.5, fx:0.5, fy:0.5, stop:0 #360033, stop:1 #0b8793);
        color: #FFFFFF;
        border: 1px solid #018786;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: qradialgradient(cx:0.5, cy:0.5, radius: 1, fx:0.5, fy:0.5, stop:0 #ff5f6d, stop:1 #ffc371);
        color: #FFFFFF;
        border: 2px solid #FF0266;
        padding: 2px;
        margin: 2px;
        border-radius: 8px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: qradialgradient(cx:0.5, cy:0.5, radius: 0.7, fx:0.5, fy:0.5, stop:0 #ffc371, stop:1 #ff5f6d);
    }
    QTabBar::tab {
        background-color: rgba(0, 8, 69, 0.8);
        color: #FFF;
        border: 1px solid #FF0266;
        padding: 5px;
        border-radius: 3px;
    }
    QTabBar::tab:selected {
        background-color: rgba(0, 18, 89, 0.9);
        border-color: #FF0266;
    }
""",
"Dark - Yellow & Black": """
    QMainWindow, QDialog, QWidget {
        background-color: #1a1a1a;
        color: #ffff55;
        border: 1px solid #018786;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #2b2b2b;
        color: #ffff55;
        border: 1px solid #ffff55;
        padding: 2px;
        margin: 2px;
        border-radius: 3px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #333333;
        border-color: #ffff33;
    }
    QTabBar::tab {
        background-color: #2b2b2b;
        color: #ffff55;
        border: 1px solid #ffff55;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #333333;
        border-color: #ffff33;
    }
""",
"Dark - Green & Black": """
    QMainWindow, QDialog, QWidget {
        background-color: #1a1a1a;
        color: #55ff55;
        border: 1px solid #018786;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #2b2b2b;
        color: #55ff55;
        border: 1px solid #55ff55;
        padding: 2px;
        margin: 2px;
        border-radius: 3px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #333333;
        border-color: #33ff33;
    }
    QTabBar::tab {
        background-color: #2b2b2b;
        color: #55ff55;
        border: 1px solid #55ff55;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #333333;
        border-color: #33ff33;
    }
""",
"Dark - Blue & Black": """
    QMainWindow, QDialog, QWidget {
        background-color: #1a1a1a;
        color: #5599ff;
        border: 1px solid #018786;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #2b2b2b;
        color: #5599ff;
        border: 1px solid #5599ff;
        padding: 2px;
        margin: 2px;
        border-radius: 3px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #333333;
        border-color: #3377ff;
    }
    QTabBar::tab {
        background-color: #2b2b2b;
        color: #5599ff;
        border: 1px solid #5599ff;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #333333;
        border-color: #3377ff;
    }
""",
"Dark - Red & Black": """
    QMainWindow, QDialog, QWidget {
        background-color: #1a1a1a;
        color: #ff5555;
        border: 1px solid #018786;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #2b2b2b;
        color: #ff5555;
        border: 1px solid #ff5555;
        padding: 2px;
        margin: 2px;
        border-radius: 3px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #333333;
        border-color: #ff3333;
    }
    QTabBar::tab {
        background-color: #2b2b2b;
        color: #ff5555;
        border: 1px solid #ff5555;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #333333;
        border-color: #ff3333;
    }
""",
"3D - Vivid Spectrum": """
    QMainWindow, QDialog, QWidget {
        background-color: qradialgradient(cx:0.5, cy:0.5, radius: 1.5, fx:0.5, fy:0.5, stop:0 #2e1437, stop:1 #120d26);
        color: #FFFFFF;
        border: 2px solid #4a235a;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: qradialgradient(cx:0.5, cy:0.5, radius: 1, fx:0.5, fy:0.5, stop:0 #21618c, stop:1 #f7dc6f);
        color: #FFFFFF;
        border: 2px solid #148f77;
        padding: 2px;
        margin: 2px;
        border-radius: 10px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: qradialgradient(cx:0.5, cy:0.5, radius: 0.7, fx:0.5, fy:0.5, stop:0 #f7dc6f, stop:1 #21618c);
    }
    QTabBar::tab {
        background-color: rgba(40, 55, 71, 0.9);
        color: #ecf0f1;
        border: 1px solid #3498db;
        padding: 5px;
        border-radius: 5px;
    }
    QTabBar::tab:selected {
        background-color: rgba(21, 67, 96, 0.9);
        border-color: #9b59b6;
    }
""",
"Fun - Eye Strain": """
    QMainWindow, QDialog, QWidget {
        background-color: #5c94fc;
        color: #ffffff;
        border: 1px solid #018786;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #ff0000;
        color: #ffffff;
        border: 2px solid #ffd700;
        padding: 2px;
        margin: 2px;
        border-radius: 5px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #ff6347;
    }
    QTabBar::tab {
        background-color: #ff0000;
        color: #ffffff;
        border: 1px solid #ffd700;
        padding: 5px;
        border-radius: 3px;
    }
    QTabBar::tab:selected {
        background-color: #ff6347;
        border-color: #ffd700;
    }
""",
"Fun - Kirby": """
    QMainWindow, QDialog, QWidget {
        background-color: #fce4ec;
        color: #f06292;
        border: 1px solid #018786;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #f06292;
        color: #fce4ec;
        border: 2px solid #ec407a;
        padding: 2px;
        margin: 2px;
        border-radius: 8px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #ec407a;
    }
    QTabBar::tab {
        background-color: #f06292;
        color: #fce4ec;
        border: 1px solid #f8bbd0;
        padding: 5px;
        border-radius: 4px;
    }
    QTabBar::tab:selected {
        background-color: #ec407a;
        border-color: #f06292;
    }
    QMenu::item:selected {
        background-color: #D6EAF8; /* Light sky blue for selected menu items */
        color: #212121;
    }
""",
"Fun - Gaming": """
    QMainWindow, QDialog, QWidget {
        background-color: #5C94FC; /* Sky blue reminiscent of the game's backgrounds */
        color: #000000;
        border: 1px solid #F2F2F2;
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #FFD966; /* Soft yellow for inputs, resembling the coins */
        color: #333333;
        border: 2px solid #B35900; /* Brick color */
        padding: 2px;
        margin: 2px;
        border-radius: 4px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #F4D03F;
        border-color: #CC8400;
    }
    QTabBar::tab {
        background-color: #F7F7F7;
        color: #666666;
        border: 1px solid #CCCCCC;
        padding: 5px;
        border-radius: 3px;
    }
    QTabBar::tab:selected {
        background-color: #E7E7E7;
        border-color: #555555;
    }
    /* Custom styling for top bar and other white areas */
    QMenuBar, QMenu {
        background-color: #F7F7F7; /* Clouds color */
        color: #333333;
    }
    QMenu::item:selected {
        background-color: #D6EAF8; /* Light sky blue for selected menu items */
        color: #212121;
    }
    QStatusBar, QToolBar, QDockWidget {
        background-color: #F7F7F7;
        border: 1px solid #AAB7B8;
    }
""",
"Dark - Midnight Streets": """
    QMainWindow, QDialog, QWidget {
        background-color: #1C2833; /* Deep night sky */
        color: #EAECEE; /* Soft light color for text */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QCheckBox, QGroupBox, QStatusBar, QMenuBar, QMenu, QToolBar, QSpinBox {
        background-color: #2C3E50; /* Dark ocean blue */
        color: #ABB2B9; /* Silver for text */
        border: 2px solid #283747; /* Dark metallic border */
        padding: 2px;
        margin: 2px;
        border-radius: 5px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #273746; /* Slightly lighter dark blue on hover */
        border-color: #1B4F72; /* Slightly lighter dark blue border on hover */
    }
    QHeaderView::section, QTabBar::tab, QTabWidget::pane {
        background-color: #212F3C; /* Dark blue for headers and tabs */
        color: #EAECEE; /* Light text color */
        border: 1px solid #1B2631; /* Dark border for separation */
        padding: 5px;
        border-radius: 4px;
    }
    QTabBar::tab:selected, QTabWidget::tab-bar {
        background-color: #1A5276; /* Selected tab color */
        border-color: #154360; /* Selected tab border */
    }
    QTableWidget, QTableView {
        gridline-color: #283747; /* Grid line color for tables */
        background-color: #2C3E50; /* Background color for tables */
    }
    QTableWidget::item, QTableView::item {
        color: #EAECEE; /* Text color for table items */
        border: 1px solid #283747; /* Border color for table items */
    }
    QTableWidget::item:selected, QTableView::item:selected {
        background-color: #273746; /* Background color for selected table items */
        color: #D5D8DC; /* Text color for selected table items */
    }
    QScrollBar:vertical, QScrollBar:horizontal {
        border: 2px solid #2C3E50;
        background: #2C3E50;
        width: 15px;
        margin: 15px 3px 15px 3px;
        border-radius: 4px;
    }
    QScrollBar::handle:vertical, QScrollBar::handle:horizontal {
        background-color: #1B4F72; /* Handle color */
        min-height: 20px;
        border-radius: 4px;
    }
    QScrollBar::add-line, QScrollBar::sub-line {
        background-color: #212F3C; /* Button background */
        border: 2px solid #1B2631;
        width: 14px;
        subcontrol-position: top left;
        subcontrol-origin: margin;
    }
""",
"Dark - Light Blue & Dark Slate": """
    QMainWindow, QDialog, QWidget {
        background-color: #2b2b2b; /* Dark Slate Gray */
        color: #7ec0ee; /* Light Sky Blue */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #383838;
        color: #7ec0ee;
        border: 1px solid #7ec0ee;
        padding: 2px;
        margin: 2px;
        border-radius: 3px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #404040;
        border-color: #82caff;
    }
    QTabBar::tab {
        background-color: #383838;
        color: #7ec0ee;
        border: 1px solid #7ec0ee;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #404040;
        border-color: #82caff;
    }
""",
"Dark - Dark Purple & Electric Blue": """
    QMainWindow, QDialog, QWidget {
        background-color: #302b63; /* Dark Purple */
        color: #4682b4; /* Steel Blue */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #3a2c5d;
        color: #4682b4;
        border: 1px solid #4682b4;
        padding: 2px;
        margin: 2px;
        border-radius: 3px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #42366f;
        border-color: #5cacee;
    }
    QTabBar::tab {
        background-color: #3a2c5d;
        color: #4682b4;
        border: 1px solid #4682b4;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #42366f;
        border-color: #5cacee;
    }
""",
"Dark - Dark Grey & Cerulean": """
    QMainWindow, QDialog, QWidget {
        background-color: #303030; /* Dark Grey */
        color: #007ba7; /* Cerulean */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #383838;
        color: #007ba7;
        border: 1px solid #007ba7;
        padding: 2px;
        margin: 2px;
        border-radius: 3px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #404040;
        border-color: #009ec3;
    }
    QTabBar::tab {
        background-color: #383838;
        color: #007ba7;
        border: 1px solid #007ba7;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #404040;
        border-color: #009ec3;
    }
""",
"Charcoal & Ice Blue": """
    QMainWindow, QDialog, QWidget {
        background-color: #36454f; /* Charcoal */
        color: #b0e0e6; /* Powder Blue */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #404b54;
        color: #b0e0e6;
        border: 1px solid #b0e0e6;
        padding: 2px;
        margin: 2px;
        border-radius: 3px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #4a535b;
        border-color: #b3ffff;
    }
    QTabBar::tab {
        background-color: #404b54;
        color: #b0e0e6;
        border: 1px solid #b0e0e6;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #4a535b;
        border-color: #b3ffff;
    }
""",
"Dark - Dark Emerald & Obsidian": """
    QMainWindow, QDialog, QWidget {
        background-color: #1a1a1a;
        color: #2ecc71; /* Emerald green */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #34495e; /* Dark blue-gray */
        color: #2ecc71;
        border: 2px solid #27ae60;
        padding: 2px;
        margin: 2px;
        border-radius: 5px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #2c3e50;
    }
    QTabBar::tab {
        background-color: #34495e;
        color: #2ecc71;
        border: 1px solid #27ae60;
        padding: 5px;
        border-radius: 3px;
    }
    QTabBar::tab:selected {
        background-color: #2c3e50;
        border-color: #27ae60;
    }
""",
"Dark - Graphite & Neon Blue": """
    QMainWindow, QDialog, QWidget {
        background-color: #212121; /* Deep Graphite */
        color: #00aced; /* Twitter blue */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #2c3e50; /* Dark Slate */
        color: #00aced;
        border: 2px solid #0078a8; /* Deep blue */
        padding: 2px;
        margin: 2px;
        border-radius: 4px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #34495e;
    }
    QTabBar::tab {
        background-color: #2c3e50;
        color: #00aced;
        border: 1px solid #0078a8;
        padding: 5px;
        border-radius: 3px;
    }
    QTabBar::tab:selected {
        background-color: #34495e;
        border-color: #00aced;
    }
""",
"Onyx & Ruby": """
    QMainWindow, QDialog, QWidget {
        background-color: #111111; /* Almost black */
        color: #e74c3c; /* Ruby red */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #2c3e50; /* Dark Slate */
        color: #e74c3c;
        border: 2px solid #c0392b; /* Dark red */
        padding: 2px;
        margin: 2px;
        border-radius: 5px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #34495e;
    }
    QTabBar::tab {
        background-color: #2c3e50;
        color: #e74c3c;
        border: 1px solid #c0392b;
        padding: 5px;
        border-radius: 3px;
    }
    QTabBar::tab:selected {
        background-color: #34495e;
        border-color: #e74c3c;
    }
""",
"Hyper Spectrum": """
    QMainWindow, QDialog, QWidget {
        background-color: #333344; /* Deep twilight blue */
        color: #F1C40F; /* Vivid yellow */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #8E44AD, stop:1 #3498DB); /* Gradient from purple to blue */
        color: #2ECC71; /* Emerald green */
        border: 2px solid #E74C3C; /* Neon red */
        padding: 2px;
        margin: 2px;
        border-radius: 5px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #3498DB, stop:1 #8E44AD); /* Reverse gradient */
        border-color: #1ABC9C; /* Soft teal */
    }
    QTabBar::tab {
        background-color: #9B59B6; /* Plum */
        color: #ECF0F1; /* Soft light */
        border: 1px solid #16A085; /* Dark sea green */
        padding: 5px;
        border-radius: 3px;
    }
    QTabBar::tab:selected {
        background-color: #3498DB; /* Bright blue */
        border-color: #F39C12; /* Orange */
    }
    /* Styling for the top menu and other UI elements to add depth */
    QMenuBar, QMenu {
        background-color: #34495E; /* Dark slate blue */
        color: #E67E22; /* Pumpkin orange */
    }
    QMenu::item:selected {
        background-color: #2C3E50; /* Dark navy blue */
        color: #D35400; /* Pumpkin orange */
    }
    QStatusBar, QToolBar, QDockWidget {
        background-color: #2C3E50;
        border: 1px solid #1B2631;
    }
""",
"Midnight Obsidian": """
QMainWindow, QDialog, QWidget {
    background-color: #1A1C1E; /* Deep black with blue undertone */
    color: #C8CDD1; /* Soft off-white for text */
}

QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QCheckBox, QGroupBox, QStatusBar, QMenuBar, QMenu, QToolBar, QSpinBox {
    background-color: #2C2E30; /* Charcoal gray */
    color: #A2A9AC; /* Light gray for text */
    border: 1px solid #232527; /* Slightly darker border */
    padding: 4px;
    margin: 4px;
    border-radius: 6px;
}

QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #373A3D; /* Slightly lighter charcoal on hover */
    border-color: #3E4245; /* Slightly lighter border on hover */
}

QHeaderView::section, QTabBar::tab, QTabWidget::pane {
    background-color: #252729; /* Slightly lighter black for headers and tabs */
    color: #C8CDD1; /* Light text color */
    border: 1px solid #1D1F21; /* Darker border for separation */
    padding: 6px;
    border-radius: 4px;
}

QTableWidget, QTableView {
    gridline-color: #232527; /* Grid line color for tables */
    background-color: #2C2E30; /* Background color for tables */
}

QTableWidget::item, QTableView::item {
    color: #C8CDD1; /* Text color for table items */
    border: 1px solid #232527; /* Border color for table items */
}

QTableWidget::item:selected, QTableView::item:selected {
    background-color: #373A3D; /* Background color for selected table items */
    color: #D5D8DC; /* Text color for selected table items */
}

QScrollBar:vertical, QScrollBar:horizontal {
    border: 2px solid #2C2E30;
    background: #2C2E30;
    width: 15px;
    margin: 15px 3px 15px 3px;
    border-radius: 4px;
}

QScrollBar::handle:vertical, QScrollBar::handle:horizontal {
    background-color: #3E4245; /* Handle color */
    min-height: 20px;
    border-radius: 4px;
}

QScrollBar::add-line, QScrollBar::sub-line {
    background-color: #252729; /* Button background */
    border: 2px solid #1D1F21;
    width: 14px;
    subcontrol-position: top left;
    subcontrol-origin: margin;
}
""",
"Soft Elegance": """
QMainWindow, QDialog, QWidget {
    background-color: #F0F0F0; /* Light gray background */
    color: #333333; /* Dark gray for text */
}

QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QCheckBox, QGroupBox, QStatusBar, QMenuBar, QMenu, QToolBar, QSpinBox {
    background-color: #FFFFFF; /* White for most UI elements */
    color: #5C5C5C; /* Medium gray for text */
    border: 1px solid #CCCCCC; /* Light gray border */
    padding: 4px;
    margin: 4px;
    border-radius: 6px;
}

QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #E6E6E6; /* Very light gray for hover */
    border-color: #BFBFBF; /* Lighter border on hover */
}

QHeaderView::section, QTabBar::tab, QTabWidget::pane {
    background-color: #EDEDED; /* Very light gray for headers and tabs */
    color: #333333; /* Dark gray text color */
    border: 1px solid #D6D6D6; /* Light gray border for separation */
    padding: 6px;
    border-radius: 4px;
}

QTabBar::tab:selected, QTabWidget::tab-bar {
    background-color: #DADADA; /* Selected tab color, a muted gray */
    border-color: #C2C2C2; /* Light gray border for selected tab */
}

QTableWidget, QTableView {
    gridline-color: #EAEAEA; /* Very light gray grid lines */
    background-color: #FFFFFF; /* White background for tables */
}

QTableWidget::item, QTableView::item {
    color: #5C5C5C; /* Medium gray text */
    border: 1px solid #EAEAEA; /* Very light gray border */
}

QTableWidget::item:selected, QTableView::item:selected {
    background-color: #E6E6E6; /* Selected item background color */
    color: #333333; /* Dark gray text color for selected items */
}

QScrollBar:vertical, QScrollBar:horizontal {
    border: 2px solid #FFFFFF;
    background: #FFFFFF;
    width: 15px;
    margin: 15px 3px 15px 3px;
    border-radius: 4px;
}

QScrollBar::handle:vertical, QScrollBar::handle:horizontal {
    background-color: #DADADA; /* Handle color, a muted gray */
    min-height: 20px;
    border-radius: 4px;
}

QScrollBar::add-line, QScrollBar::sub-line {
    background-color: #EDEDED; /* Very light gray for scroll buttons */
    border: 2px solid #D6D6D6;
    width: 14px;
    subcontrol-position: top left;
    subcontrol-origin: margin;
}
""",
"Ocean Blue": """
QMainWindow, QDialog, QWidget {
    background-color: #E0F7FA; /* Light cyan background */
    color: #01579B; /* Deep blue for text */
}

QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QCheckBox, QGroupBox, QStatusBar, QMenuBar, QMenu, QToolBar, QSpinBox {
    background-color: #B3E5FC; /* Light blue for UI elements */
    color: #0277BD; /* Blue text */
    border: 1px solid #81D4FA; /* Soft blue border */
    padding: 4px;
    margin: 4px;
    border-radius: 6px;
}

QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #4FC3F7; /* Brighter blue for hover */
    border-color: #29B6F6; /* Slightly lighter blue border on hover */
}

QHeaderView::section, QTabBar::tab, QTabWidget::pane {
    background-color: #81D4FA; /* Soft blue for headers and tabs */
    color: #01579B; /* Deep blue text color */
    border: 1px solid #4DD0E1; /* Cyan border for separation */
    padding: 6px;
    border-radius: 4px;
}

QTabBar::tab:selected, QTabWidget::tab-bar {
    background-color: #29B6F6; /* Selected tab color */
    border-color: #039BE5; /* Blue border */
}

QTableWidget, QTableView {
    gridline-color: #B3E5FC; /* Light blue grid lines */
    background-color: #E1F5FE; /* Very light blue background for tables */
}

QTableWidget::item, QTableView::item {
    color: #0277BD; /* Blue text */
    border: 1px solid #81D4FA; /* Soft blue border */
}

QTableWidget::item:selected, QTableView::item:selected {
    background-color: #4FC3F7; /* Bright blue for selected items */
    color: #01579B; /* Deep blue text color */
}

QScrollBar:vertical, QScrollBar:horizontal {
    border: 2px solid #B3E5FC;
    background: #B3E5FC;
    width: 15px;
    margin: 15px 3px 15px 3px;
    border-radius: 4px;
}

QScrollBar::handle:vertical, QScrollBar::handle:horizontal {
    background-color: #4FC3F7; /* Handle color */
    min-height: 20px;
    border-radius: 4px;
}

QScrollBar::add-line, QScrollBar::sub-line {
    background-color: #81D4FA; /* Soft blue for scroll buttons */
    border: 2px solid #4DD0E1;
    width: 14px;
    subcontrol-position: top left;
    subcontrol-origin: margin;
}
""",
"Sunset Glow": """
QMainWindow, QDialog, QWidget {
    background-color: #FFF3E0; /* Light orange background */
    color: #BF360C; /* Deep red for text */
}

QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QCheckBox, QGroupBox, QStatusBar, QMenuBar, QMenu, QToolBar, QSpinBox {
    background-color: #FFE0B2; /* Soft orange for UI elements */
    color: #D84315; /* Reddish-orange text */
    border: 1px solid #FFCCBC; /* Pale orange border */
    padding: 4px;
    margin: 4px;
    border-radius: 6px;
}

QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #FFAB91; /* Brighter orange for hover */
    border-color: #FF8A65; /* Lighter orange border on hover */
}

QHeaderView::section, QTabBar::tab, QTabWidget::pane {
    background-color: #FFCCBC; /* Pale orange for headers and tabs */
    color: #BF360C; /* Deep red text color */
    border: 1px solid #FFAB91; /* Orange border for separation */
    padding: 6px;
    border-radius: 4px;
}

QTabBar::tab:selected, QTabWidget::tab-bar {
    background-color: #FF8A65; /* Selected tab color */
    border-color: #FF7043; /* Orange border */
}

QTableWidget, QTableView {
    gridline-color: #FFE0B2; /* Soft orange grid lines */
    background-color: #FFF3E0; /* Very light orange background for tables */
}

QTableWidget::item, QTableView::item {
    color: #D84315; /* Reddish-orange text */
    border: 1px solid #FFCCBC; /* Pale orange border */
}

QTableWidget::item:selected, QTableView::item:selected {
    background-color: #FFAB91; /* Bright orange for selected items */
    color: #BF360C; /* Deep red text color */
}

QScrollBar:vertical, QScrollBar:horizontal {
    border: 2px solid #FFE0B2;
    background: #FFE0B2;
    width: 15px;
    margin: 15px 3px 15px 3px;
    border-radius: 4px;
}

QScrollBar::handle:vertical, QScrollBar::handle:horizontal {
    background-color: #FFAB91; /* Handle color */
    min-height: 20px;
    border-radius: 4px;
}

QScrollBar::add-line, QScrollBar::sub-line {
    background-color: #FFCCBC; /* Pale orange for scroll buttons */
    border: 2px solid #FFAB91;
    width: 14px;
    subcontrol-position: top left;
    subcontrol-origin: margin;
}
""",
"Forest Green": """
QMainWindow, QDialog, QWidget {
    background-color: #D0F8CE; /* Light green background */
    color: #1B5E20; /* Dark green for text */
}

QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QCheckBox, QGroupBox, QStatusBar, QMenuBar, QMenu, QToolBar, QSpinBox {
    background-color: #A5D6A7; /* Pastel green for UI elements */
    color: #33691E; /* Green text */
    border: 1px solid #81C784; /* Soft green border */
    padding: 4px;
    margin: 4px;
    border-radius: 6px;
}

QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #388E3C; /* Bright green for hover */
    border-color: #1B5E20; /* Dark green border on hover */
}

QHeaderView::section, QTabBar::tab, QTabWidget::pane {
    background-color: #4CAF50; /* Green for headers and tabs */
    color: #1B5E20; /* Dark green text color */
    border: 1px solid #388E3C; /* Darker green border for separation */
    padding: 6px;
    border-radius: 4px;
}

QTabBar::tab:selected, QTabWidget::tab-bar {
    background-color: #2E7D32; /* Selected tab color */
    border-color: #1B5E20; /* Dark green border */
}

QTableWidget, QTableView {
    gridline-color: #A5D6A7; /* Pastel green grid lines */
    background-color: #C8E6C9; /* Very light green background for tables */
}

QTableWidget::item, QTableView::item {
    color: #33691E; /* Green text */
    border: 1px solid #81C784; /* Soft green border */
}

QTableWidget::item:selected, QTableView::item:selected {
    background-color: #43A047; /* Bright green for selected items */
    color: #1B5E20; /* Dark green text color */
}

QScrollBar:vertical, QScrollBar:horizontal {
    border: 2px solid #A5D6A7;
    background: #A5D6A7;
    width: 15px;
    margin: 15px 3px 15px 3px;
    border-radius: 4px;
}

QScrollBar::handle:vertical, QScrollBar::handle:horizontal {
    background-color: #388E3C; /* Handle color */
    min-height: 20px;
    border-radius: 4px;
}

QScrollBar::add-line, QScrollBar::sub-line {
    background-color: #4CAF50; /* Soft green for scroll buttons */
    border: 2px solid #388E3C;
    width: 14px;
    subcontrol-position: top left;
    subcontrol-origin: margin;
}
""",
"Sunset Orange": """
QMainWindow, QDialog, QWidget {
    background-color: #FFECB3; /* Light orange background */
    color: #E65100; /* Orange for text */
}

QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QCheckBox, QGroupBox, QStatusBar, QMenuBar, QMenu, QToolBar, QSpinBox {
    background-color: #FFD54F; /* Pastel orange for UI elements */
    color: #EF6C00; /* Orange text */
    border: 1px solid #FFB300; /* Soft orange border */
    padding: 4px;
    margin: 4px;
    border-radius: 6px;
}

QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #FFB300; /* Bright orange for hover */
    border-color: #E65100; /* Dark orange border on hover */
}

QHeaderView::section, QTabBar::tab, QTabWidget::pane {
    background-color: #FF9800; /* Orange for headers and tabs */
    color: #E65100; /* Dark orange text color */
    border: 1px solid #FFB300; /* Soft orange border for separation */
    padding: 6px;
    border-radius: 4px;
}

QTabBar::tab:selected, QTabWidget::tab-bar {
    background-color: #F57C00; /* Selected tab color */
    border-color: #E65100; /* Dark orange border */
}

QTableWidget, QTableView {
    gridline-color: #FFD54F; /* Pastel orange grid lines */
    background-color: #FFE0B2; /* Very light orange background for tables */
}

QTableWidget::item, QTableView::item {
    color: #EF6C00; /* Orange text */
    border: 1px solid #FFB300; /* Soft orange border */
}

QTableWidget::item:selected, QTableView::item:selected {
    background-color: #FFA726; /* Bright orange for selected items */
    color: #E65100; /* Dark orange text color */
}

QScrollBar:vertical, QScrollBar:horizontal {
    border: 2px solid #FFD54F;
    background: #FFD54F;
    width: 15px;
    margin: 15px 3px 15px 3px;
    border-radius: 4px;
}

QScrollBar::handle:vertical, QScrollBar::handle:horizontal {
    background-color: #FFB300; /* Handle color */
    min-height: 20px;
    border-radius: 4px;
}

QScrollBar::add-line, QScrollBar::sub-line {
    background-color: #FF9800; /* Soft orange for scroll buttons */
    border: 2px solid #FFB300;
    width: 14px;
    subcontrol-position: top left;
    subcontrol-origin: margin;
}
""",
"Light - Pastel Delight": """
QMainWindow, QDialog, QWidget {
    background-color: #FFF5E1; /* Light Cream */
    color: #4B0082; /* Indigo */
}
QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
    background-color: #EAD1DC; /* Pastel Pink */
    color: #4B0082;
    border: 1px solid #FFB6C1; /* Light Pink */
    padding: 2px;
    margin: 2px;
}
QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #FFC0CB; /* Pink */
}
QTabBar::tab {
    background-color: #EAD1DC;
    color: #4B0082;
    border: 1px solid #FFB6C1;
    padding: 5px;
}
QTabBar::tab:selected {
    background-color: #FFC0CB;
    border-color: #4B0082;
}
""",
"Dark - Galactic": """
QMainWindow, QDialog, QWidget {
    background-color: #1F1B24; /* Dark Purple */
    color: #E5E5E5; /* Light Gray */
}
QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
    background-color: #3D2C8D; /* Medium Purple */
    color: #E5E5E5;
    border: 1px solid #8E44AD; /* Bright Purple */
    padding: 2px;
    margin: 2px;
}
QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #6C3483; /* Darker Purple */
}
QTabBar::tab {
    background-color: #3D2C8D;
    color: #E5E5E5;
    border: 1px solid #8E44AD;
    padding: 5px;
}
QTabBar::tab:selected {
    background-color: #6C3483;
    border-color: #E5E5E5;
}
""",
"Wacky - Rainbow": """
QMainWindow, QDialog, QWidget {
    background-color: #FF6347; /* Tomato */
    color: #000000; /* Black */
}
QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
    background-color: #FFD700; /* Gold */
    color: #0000FF; /* Blue */
    border: 1px solid #ADFF2F; /* Green */
    padding: 2px;
    margin: 2px;
}
QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #7FFF00; /* Chartreuse */
}
QTabBar::tab {
    background-color: #FFD700;
    color: #0000FF;
    border: 1px solid #ADFF2F;
    padding: 5px;
}
QTabBar::tab:selected {
    background-color: #7FFF00;
    border-color: #0000FF;
}
""",
"Elegant - Midnight Gold": """
QMainWindow, QDialog, QWidget {
    background-color: #2C3E50; /* Dark Blue */
    color: #F1C40F; /* Gold */
}
QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
    background-color: #34495E; /* Medium Dark Blue */
    color: #F1C40F;
    border: 1px solid #D4AC0D; /* Darker Gold */
    padding: 2px;
    margin: 2px;
}
QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #1C2833; /* Darker Blue */
}
QTabBar::tab {
    background-color: #34495E;
    color: #F1C40F;
    border: 1px solid #D4AC0D;
    padding: 5px;
}
QTabBar::tab:selected {
    background-color: #1C2833;
    border-color: #F1C40F;
}
""",
"Wacky - Neon Jungle": """
QMainWindow, QDialog, QWidget {
    background-color: #39FF14; /* Neon Green */
    color: #FF00FF; /* Neon Pink */
}
QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
    background-color: #00FFFF; /* Neon Cyan */
    color: #FF00FF;
    border: 1px solid #FFFF00; /* Neon Yellow */
    padding: 2px;
    margin: 2px;
}
QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #FF00FF;
    color: #000000; /* Black */
}
QTabBar::tab {
    background-color: #00FFFF;
    color: #FF00FF;
    border: 1px solid #FFFF00;
    padding: 5px;
}
QTabBar::tab:selected {
    background-color: #FF00FF;
    border-color: #FFFF00;
}
""",
"Elegant - Royal Blue": """
QMainWindow, QDialog, QWidget {
    background-color: #002366; /* Royal Blue */
    color: #F8F8FF; /* Ghost White */
}
QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
    background-color: #1E90FF; /* Dodger Blue */
    color: #F8F8FF;
    border: 1px solid #4682B4; /* Steel Blue */
    padding: 2px;
    margin: 2px;
}
QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #5F9EA0; /* Cadet Blue */
}
QTabBar::tab {
    background-color: #1E90FF;
    color: #F8F8FF;
    border: 1px solid #4682B4;
    padding: 5px;
}
QTabBar::tab:selected {
    background-color: #5F9EA0;
    border-color: #F8F8FF;
}
""",
"Light - Sunny Day": """
QMainWindow, QDialog, QWidget {
    background-color: #FFFACD; /* Lemon Chiffon */
    color: #FF6347; /* Tomato */
}
QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
    background-color: #FFD700; /* Gold */
    color: #FF4500; /* Orange Red */
    border: 1px solid #FFA500; /* Orange */
    padding: 2px;
    margin: 2px;
}
QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #FF4500; /* Orange Red */
    color: #FFFFFF; /* White */
}
QTabBar::tab {
    background-color: #FFD700;
    color: #FF4500;
    border: 1px solid #FFA500;
    padding: 5px;
}
QTabBar::tab:selected {
    background-color: #FF4500;
    border-color: #FFFFFF;
}
""",
"Dark - Forest Night": """
QMainWindow, QDialog, QWidget {
    background-color: #154734; /* Dark Green */
    color: #E4E4E4; /* Light Gray */
}
QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QMenu::item:selected, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
    background-color: #1E5631; /* Medium Dark Green */
    color: #A4C3B2; /* Light Green */
    border: 1px solid #356859; /* Dark Green */
    padding: 2px;
    margin: 2px;
}
QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
    background-color: #2E8B57; /* Sea Green */
}
QTabBar::tab {
    background-color: #1E5631;
    color: #A4C3B2;
    border: 1px solid #356859;
    padding: 5px;
}
QTabBar::tab:selected {
    background-color: #2E8B57;
    border-color: #E4E4E4;
}
""",
"Light - Serene Waves": """
    QMainWindow, QDialog, QWidget {
        background-color: #E0F7FA; /* Light Cyan */
        color: #00796B; /* Dark Teal */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #B2EBF2; /* Cyan */
        color: #004D40; /* Dark Teal */
        border: 1px solid #4DD0E1; /* Light Cyan */
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #4DD0E1; /* Light Cyan */
    }
    QTabBar::tab {
        background-color: #B2EBF2;
        color: #004D40;
        border: 1px solid #4DD0E1;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #4DD0E1;
        border-color: #004D40;
    }
""",
"Dark - Mystic Forest": """
    QMainWindow, QDialog, QWidget {
        background-color: #1B3B2E; /* Very Dark Green */
        color: #E0E0E0; /* Light Gray */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #2E7D32; /* Dark Green */
        color: #C8E6C9; /* Light Green */
        border: 1px solid #1B5E20; /* Dark Green */
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #66BB6A; /* Medium Green */
    }
    QTabBar::tab {
        background-color: #2E7D32;
        color: #C8E6C9;
        border: 1px solid #1B5E20;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #66BB6A;
        border-color: #E0E0E0;
    }
""",
"Wacky - Electric Dreams": """
    QMainWindow, QDialog, QWidget {
        background-color: #FFD700; /* Gold */
        color: #8A2BE2; /* Blue Violet */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #7FFF00; /* Chartreuse */
        color: #FF4500; /* Orange Red */
        border: 2px solid #DA70D6; /* Orchid */
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #FF69B4; /* Hot Pink */
        color: #000000; /* Black */
    }
    QTabBar::tab {
        background-color: #7FFF00;
        color: #FF4500;
        border: 1px solid #DA70D6;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #FF69B4;
        border-color: #000000;
    }
""",
"Wacky - Galactic Neon": """
    QMainWindow, QDialog, QWidget {
        background-color: #00008B; /* Dark Blue */
        color: #FF00FF; /* Neon Pink */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #0000CD; /* Medium Blue */
        color: #00FFFF; /* Neon Cyan */
        border: 1px solid #FF00FF;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #8A2BE2; /* Blue Violet */
    }
    QTabBar::tab {
        background-color: #0000CD;
        color: #00FFFF;
        border: 1px solid #FF00FF;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #8A2BE2;
        border-color: #00FFFF;
    }
""",
"Elegant - Coral Bliss": """
    QMainWindow, QDialog, QWidget {
        background-color: #FFE4E1; /* Misty Rose */
        color: #FF6347; /* Tomato */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #FF7F50; /* Coral */
        color: #8B0000; /* Dark Red */
        border: 1px solid #FF4500; /* Orange Red */
        padding: 2px;
        margin: 2px;
        border-radius: 5px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #FF6347; /* Tomato */
    }
    QTabBar::tab {
        background-color: #FF7F50;
        color: #8B0000;
        border: 1px solid #FF4500;
        padding: 5px;
        border-radius: 5px;
    }
    QTabBar::tab:selected {
        background-color: #FF6347;
        border-color: #8B0000;
    }
""",
"Light - Lemonade Stand": """
    QMainWindow, QDialog, QWidget {
        background-color: #FFFACD; /* Lemon Chiffon */
        color: #FFD700; /* Gold */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #FFF8DC; /* Cornsilk */
        color: #FFA500; /* Orange */
        border: 1px solid #FFD700; /* Gold */
        padding: 2px;
        margin: 2px;
        border-radius: 4px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #FFD700; /* Gold */
        color: #FFFFFF; /* White */
    }
    QTabBar::tab {
        background-color: #FFF8DC;
        color: #FFA500;
        border: 1px solid #FFD700;
        padding: 5px;
        border-radius: 4px;
    }
    QTabBar::tab:selected {
        background-color: #FFD700;
        border-color: #FFA500;
    }
""",
"Dark - Obsidian Blue": """
    QMainWindow, QDialog, QWidget {
        background-color: #0D1B2A; /* Obsidian Blue */
        color: #E0E0E0; /* Light Gray */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #1B263B; /* Very Dark Blue */
        color: #D3D3D3; /* Light Gray */
        border: 1px solid #415A77; /* Dark Grayish Blue */
        padding: 2px;
        margin: 2px;
        border-radius: 5px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #4A6FA5; /* Medium Dark Blue */
    }
    QTabBar::tab {
        background-color: #1B263B;
        color: #D3D3D3;
        border: 1px solid #415A77;
        padding: 5px;
        border-radius: 5px;
    }
    QTabBar::tab:selected {
        background-color: #4A6FA5;
        border-color: #E0E0E0;
    }
""",
"Wacky - Retro 80s": """
    QMainWindow, QDialog, QWidget {
        background-color: #FF00FF; /* Neon Pink */
        color: #00FFFF; /* Neon Cyan */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #800080; /* Purple */
        color: #00FFFF;
        border: 2px solid #FF00FF;
        padding: 2px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #9400D3; /* Dark Violet */
    }
    QTabBar::tab {
        background-color: #800080;
        color: #00FFFF;
        border: 2px solid #FF00FF;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #9400D3;
        border-color: #FF00FF;
    }
""",
"Elegant - Royal Teal": """
    QMainWindow, QDialog, QWidget {
        background-color: #E0F2F1; /* Light Teal */
        color: #004D40; /* Dark Teal */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #00796B; /* Medium Teal */
        color: #E0F7FA; /* Light Teal */
        border: 1px solid #004D40;
        padding: 2px;
        margin: 2px;
        border-radius: 6px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #004D40;
        color: #FFFFFF; /* White */
    }
    QTabBar::tab {
        background-color: #00796B;
        color: #E0F7FA;
        border: 1px solid #004D40;
        padding: 5px;
        border-radius: 6px;
    }
    QTabBar::tab:selected {
        background-color: #004D40;
        border-color: #E0F7FA;
    }
""",
"Dark - Phantom Purple": """
    QMainWindow, QDialog, QWidget {
        background-color: #2C003E; /* Very Dark Purple */
        color: #D8BFD8; /* Thistle */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #4B0082; /* Indigo */
        color: #DDA0DD; /* Plum */
        border: 1px solid #8A2BE2; /* Blue Violet */
        padding: 2px;
        margin: 2px;
        border-radius: 5px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #9932CC; /* Dark Orchid */
    }
    QTabBar::tab {
        background-color: #4B0082;
        color: #DDA0DD;
        border: 1px solid #8A2BE2;
        padding: 5px;
        border-radius: 5px;
    }
    QTabBar::tab:selected {
        background-color: #9932CC;
        border-color: #DDA0DD;
    }
""",
"Game - Cyberpunk 2077": """
    QMainWindow, QDialog, QWidget {
        background-color: #0D0D0D; /* Very Dark Gray */
        color: #76FF03; /* Lime Green */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #212121; /* Dark Gray */
        color: #76FF03; /* Lime Green */
        border: 2px solid #76FF03;
        padding: 4px;
        margin: 2px;
        border-radius: 6px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #424242; /* Lighter Dark Gray */
        color: #FFFF00; /* Yellow */
    }
    QTabBar::tab {
        background-color: #212121;
        color: #76FF03;
        border: 2px solid #76FF03;
        padding: 5px;
        border-radius: 6px;
    }
    QTabBar::tab:selected {
        background-color: #424242;
        border-color: #FFFF00;
    }
""",
"Fun - Candy Crush": """
    QMainWindow, QDialog, QWidget {
        background-color: #FFB6C1; /* Light Pink */
        color: #8B008B; /* Dark Magenta */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #FF69B4; /* Hot Pink */
        color: #4B0082; /* Indigo */
        border: 2px solid #FF1493; /* Deep Pink */
        padding: 4px;
        margin: 2px;
        border-radius: 8px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #FF1493; /* Deep Pink */
        color: #FFFFFF; /* White */
    }
    QTabBar::tab {
        background-color: #FF69B4;
        color: #4B0082;
        border: 2px solid #FF1493;
        padding: 5px;
        border-radius: 8px;
    }
    QTabBar::tab:selected {
        background-color: #FF1493;
        border-color: #FFFFFF;
    }
""",
"Fun - Bubble Gum": """
    QMainWindow, QDialog, QWidget {
        background-color: #E6E6FA; /* Lavender */
        color: #FF69B4; /* Hot Pink */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #FFD700; /* Gold */
        color: #FF4500; /* Orange Red */
        border: 2px solid #FFA500; /* Orange */
        padding: 4px;
        margin: 2px;
        border-radius: 8px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #FF4500; /* Orange Red */
        color: #FFFFFF; /* White */
    }
    QTabBar::tab {
        background-color: #FFD700;
        color: #FF4500;
        border: 2px solid #FFA500;
        padding: 5px;
        border-radius: 8px;
    }
    QTabBar::tab:selected {
        background-color: #FF4500;
        border-color: #FFFFFF;
    }
""",
"Fun - Tropical Paradise": """
    QMainWindow, QDialog, QWidget {
        background-color: #FFDEAD; /* Navajo White */
        color: #FF4500; /* Orange Red */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #FFA07A; /* Light Salmon */
        color: #8B0000; /* Dark Red */
        border: 2px solid #FF6347; /* Tomato */
        padding: 4px;
        margin: 2px;
        border-radius: 8px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #FF6347; /* Tomato */
        color: #FFFFFF; /* White */
    }
    QTabBar::tab {
        background-color: #FFA07A;
        color: #8B0000;
        border: 2px solid #FF6347;
        padding: 5px;
        border-radius: 8px;
    }
    QTabBar::tab:selected {
        background-color: #FF6347;
        border-color: #FFFFFF;
    }
""",
"Fun - Underwater World": """
    QMainWindow, QDialog, QWidget {
        background-color: #00CED1; /* Dark Turquoise */
        color: #2E8B57; /* Sea Green */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #40E0D0; /* Turquoise */
        color: #006400; /* Dark Green */
        border: 2px solid #20B2AA; /* Light Sea Green */
        padding: 4px;
        margin: 2px;
        border-radius: 8px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #20B2AA; /* Light Sea Green */
        color: #FFFFFF; /* White */
    }
    QTabBar::tab {
        background-color: #40E0D0;
        color: #006400;
        border: 2px solid #20B2AA;
        padding: 5px;
        border-radius: 8px;
    }
    QTabBar::tab:selected {
        background-color: #20B2AA;
        border-color: #FFFFFF;
    }
""",
"Dark - Silent Red": """
    QMainWindow, QDialog, QWidget {
        background-color: #000000; /* Black */
        color: #FFFF00; /* Yellow */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #333333; /* Dark Gray */
        color: #FFFF00; /* Yellow */
        border: 2px solid #FF0000; /* Red */
        padding: 4px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #555555; /* Lighter Gray */
        color: #FF0000; /* Red */
    }
    QTabBar::tab {
        background-color: #333333;
        color: #FFFF00;
        border: 2px solid #FF0000;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #555555;
        border-color: #FF0000;
    }
""",
"Dark - Black Window": """
    QMainWindow, QDialog, QWidget {
        background-color: #1B1B1B; /* Very Dark Gray */
        color: #FFFFFF; /* White */
    }
    QPushButton, QComboBox, QLineEdit, QTextEdit, QLabel, QTabWidget::pane, QStatusBar, QToolBar, QDockWidget, QMenuBar, QMenu, QHeaderView::section {
        background-color: #323232; /* Dark Gray */
        color: #FFFFFF;
        border: 2px solid #FF4500; /* Orange Red */
        padding: 4px;
        margin: 2px;
    }
    QPushButton:hover, QMenuBar::item:hover, QMenuBar::item:selected {
        background-color: #FF4500; /* Orange Red */
        color: #000000; /* Black */
    }
    QTabBar::tab {
        background-color: #323232;
        color: #FFFFFF;
        border: 2px solid #FF4500;
        padding: 5px;
    }
    QTabBar::tab:selected {
        background-color: #FF4500;
        border-color: #FFFFFF;
    }
""",
##################################
#                                #
#    DEBUG HELPER STYLESHEETS    #
#                                #
##################################
"DEBUG - Debug Helper 1": """
    /* General Styles for Main Window and Dialogs */
    QMainWindow, QDialog, QWidget {
        background-color: #263238; /* Deep Blue Grey */
        color: #ECEFF1; /* Light Blue Grey */
    }

    /* Widget Styles */
    QWidget {
        background-color: #37474F; /* Blue Grey Dark */
    }

    /* Push Button */
    QPushButton {
        background-color: #FF7043; /* Deep Orange */
        color: #FFFFFF;
    }
    QPushButton:hover {
        background-color: #FFAB91; /* Light Deep Orange */
    }

    /* Check Box */
    QCheckBox {
        background-color: #00796B; /* Teal Dark */
        color: #B2DFDB; /* Teal Light */
    }

    /* Radio Button */
    QRadioButton {
        background-color: #448AFF; /* Blue Accent */
        color: #E3F2FD; /* Light Blue Light */
    }

    /* Combo Box */
    QComboBox {
        background-color: #5D4037; /* Brown Dark */
        color: #D7CCC8; /* Brown Light */
    }
    QComboBox QAbstractItemView {
        background-color: #8D6E63; /* Brown */
        color: #FFFFFF;
    }

    /* Line Edit */
    QLineEdit {
        background-color: #455A64; /* Blue Grey Dark */
        color: #CFD8DC; /* Blue Grey Light */
    }

    /* Text Edit */
    QTextEdit {
        background-color: #616161; /* Grey Dark */
        color: #F5F5F5; /* Grey Light */
    }

    /* Labels */
    QLabel {
        background-color: #78909C; /* Blue Grey */
        color: #263238; /* Blue Grey Dark */
    }

    /* Group Box */
    QGroupBox {
        border: 2px solid #FFCA28; /* Amber */
        border-radius: 5px;
        margin-top: 20px; /* leave space at the top for the title */
    }
    QGroupBox::title {
        subcontrol-origin: margin;
        left: 10px;
        padding: 0 3px 0 3px;
        background-color: #FFD54F; /* Amber Light */
    }

    /* Spin Box */
    QSpinBox {
        background-color: #33691E; /* Light Green Dark */
        color: #CCFF90; /* Light Green Light */
    }

    /* Double Spin Box */
    QDoubleSpinBox {
        background-color: #BF360C; /* Deep Orange Dark */
        color: #FF9E80; /* Deep Orange Light */
    }

    /* Slider */
    QSlider::groove:horizontal {
        background: #BDBDBD; /* Grey */
        height: 8px;
        border-radius: 4px;
    }
    QSlider::handle:horizontal {
        background: #FF3D00; /* Deep Orange A400 */
        border: 1px solid #BDBDBD; /* Grey */
        width: 18px;
        margin: -2px 0;
        border-radius: 9px;
    }

    /* Scroll Bars */
    QScrollBar:vertical {
        background: #1A237E; /* Indigo Dark */
        width: 10px;
        margin: 22px 0 22px 0;
    }
    QScrollBar::handle:vertical {
        background-color: #536DFE; /* Indigo Accent */
        min-height: 20px;
    }
    QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
        background: #303F9F; /* Indigo Dark */
        height: 20px;
        subcontrol-position: top;
    }

    /* Progress Bar */
    QProgressBar {
        background-color: #006064; /* Cyan Dark */
        color: #B2EBF2; /* Cyan Light */
        border-style: none;
        border-radius: 4px;
        text-align: center;
    }
    QProgressBar::chunk {
        background-color: #00BCD4; /* Cyan */
        width: 20px;
    }

    /* Tool Tips */
    QToolTip {
        background-color: #757575; /* Grey Dark */
        color: #E0E0E0; /* Grey Light */
        border: 1px solid #616161; /* Grey */
    }

    /* Tables */
    QTableWidget {
        gridline-color: #B0BEC5; /* Blue Grey Light */
    }
    QHeaderView::section {
        background-color: #CFD8DC; /* Blue Grey Light */
        padding: 4px;
        border: 1px solid #B0BEC5; /* Blue Grey */
    }
    QTableWidget QTableCornerButton::section {
        background: #B0BEC5; /* Blue Grey Light */
    }

    /* Menu Bar */
    QMenuBar {
        background-color: #283593; /* Indigo Dark */
        color: #E8EAF6; /* Indigo Light */
    }
    QMenuBar::item {
        background: transparent;
    }
    QMenuBar::item:selected {
        background: #5C6BC0; /* Indigo Light */
    }
    QMenuBar::item:pressed {
        background: #3F51B5; /* Indigo */
    }

    /* Menu */
    QMenu {
        background-color: #424242; /* Grey Dark */
        color: #ECEFF1; /* Grey Light */
    }
    QMenu::item {
        background: transparent;
    }
    QMenu::item:selected {
        background-color: #616161; /* Grey */
    }
""",
"DEBUG - Debug Helper 2": """
    /* General Styles for Main Window and Dialogs */
    QMainWindow, QDialog, QWidget {
        background-color: #1E1E1E; /* Eerie Black */
        color: #F0F0F0; /* Cultured White */
    }

    /* Widget Styles */
    QWidget {
        background-color: #2B2B2B; /* Charleston Green */
    }

    /* Push Button */
    QPushButton {
        background-color: #6A5ACD; /* Slate Blue */
        color: #FFFFFF; /* White */
    }
    QPushButton:hover {
        background-color: #8A2BE2; /* Blue Violet */
    }

    /* Check Box */
    QCheckBox {
        background-color: #008B8B; /* Dark Cyan */
        color: #E0FFFF; /* Light Cyan */
    }

    /* Radio Button */
    QRadioButton {
        background-color: #FF4500; /* Orange Red */
        color: #FFE4B5; /* Moccasin */
    }

    /* Combo Box */
    QComboBox {
        background-color: #8B0000; /* Dark Red */
        color: #FFC0CB; /* Pink */
    }
    QComboBox QAbstractItemView {
        background-color: #B22222; /* Firebrick */
        color: #FFFFFF; /* White */
    }

    /* Line Edit */
    QLineEdit {
        background-color: #2F4F4F; /* Dark Slate Gray */
        color: #AFEEEE; /* Pale Turquoise */
    }

    /* Text Edit */
    QTextEdit {
        background-color: #4B0082; /* Indigo */
        color: #E6E6FA; /* Lavender */
    }

    /* Labels */
    QLabel {
        background-color: #808000; /* Olive */
        color: #F5F5DC; /* Beige */
    }

    /* Group Box */
    QGroupBox {
        border: 2px solid #FFD700; /* Gold */
        border-radius: 5px;
        margin-top: 20px; /* leave space at the top for the title */
    }
    QGroupBox::title {
        subcontrol-origin: margin;
        left: 10px;
        padding: 0 3px 0 3px;
        background-color: #FFFF00; /* Yellow */
    }

    /* Spin Box */
    QSpinBox {
        background-color: #006400; /* Dark Green */
        color: #90EE90; /* Light Green */
    }

    /* Double Spin Box */
    QDoubleSpinBox {
        background-color: #8B4513; /* Saddle Brown */
        color: #F4A460; /* Sandy Brown */
    }

    /* Slider */
    QSlider::groove:horizontal {
        background: #A9A9A9; /* Dark Gray */
        height: 8px;
        border-radius: 4px;
    }
    QSlider::handle:horizontal {
        background: #FF6347; /* Tomato */
        border: 1px solid #A9A9A9; /* Dark Gray */
        width: 18px;
        margin: -2px 0;
        border-radius: 9px;
    }

    /* Scroll Bars */
    QScrollBar:vertical {
        background: #4682B4; /* Steel Blue */
        width: 10px;
        margin: 22px 0 22px 0;
    }
    QScrollBar::handle:vertical {
        background-color: #00BFFF; /* Deep Sky Blue */
        min-height: 20px;
    }
    QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
        background: #1E90FF; /* Dodger Blue */
        height: 20px;
        subcontrol-position: top;
    }

    /* Progress Bar */
    QProgressBar {
        background-color: #9400D3; /* Dark Violet */
        color: #EE82EE; /* Violet */
        border-style: none;
        border-radius: 4px;
        text-align: center;
    }
    QProgressBar::chunk {
        background-color: #DA70D6; /* Orchid */
        width: 20px;
    }

    /* Tool Tips */
    QToolTip {
        background-color: #2E8B57; /* Sea Green */
        color: #F0FFF0; /* Honeydew */
        border: 1px solid #3CB371; /* Medium Sea Green */
    }

    /* Tables */
    QTableWidget {
        gridline-color: #7B68EE; /* Medium Slate Blue */
    }
    QHeaderView::section {
        background-color: #9370DB; /* Medium Purple */
        padding: 4px;
        border: 1px solid #4B0082; /* Indigo */
    }
    QTableWidget QTableCornerButton::section {
        background: #6A5ACD; /* Slate Blue */
    }

    /* Menu Bar */
    QMenuBar {
        background-color: #00008B; /* Dark Blue */
        color: #E6E6FA; /* Lavender */
    }
    QMenuBar::item {
        background: transparent;
    }
    QMenuBar::item:selected {
        background: #0000CD; /* Medium Blue */
    }
    QMenuBar::item:pressed {
        background: #191970; /* Midnight Blue */
    }

    /* Menu */
    QMenu {
        background-color: #483D8B; /* Dark Slate Blue */
        color: #E0FFFF; /* Light Cyan */
    }
    QMenu::item {
        background: transparent;
    }
    QMenu::item:selected {
        background-color: #6959CD; /* Medium Slate Blue */
    }
""",
"DEBUG - Debug Helper 3": """
    /* QGroupBox Styling */
    QGroupBox {
        background-color: #424242; /* Dark Grey */
        border: 2px solid #757575; /* Grey */
        color: #FFFFFF; /* White text */
    }
    QGroupBox::title {
        background-color: transparent;
        color: #BDBDBD; /* Light Grey */
        subcontrol-origin: margin;
        padding: 2px 5px;
    }

    /* QFrame Styling */
    QFrame {
        background-color: #616161; /* Medium Grey */
        border: 1px solid #9E9E9E; /* Light Grey */
    }

    /* Scroll Area and Scroll Bar Styling */
    QScrollArea {
        background-color: #333333; /* Very Dark Grey */
    }
    QScrollBar:vertical {
        background-color: #424242; /* Dark Grey */
        width: 10px;
    }
    QScrollBar::handle:vertical {
        background-color: #616161; /* Medium Grey */
        min-height: 20px;
    }
    QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
        background: #757575; /* Grey */
        height: 10px;
    }
    QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
        background: none;
    }

    /* Additional Elements for contrast */
    QPushButton {
        background-color: #009688; /* Teal */
        color: #FFFFFF; /* White */
        border-radius: 4px;
    }
    QPushButton:hover {
        background-color: #004D40; /* Dark Green */
    }

    QLabel {
        color: #E0E0E0; /* Light Grey */
    }

    QLineEdit, QTextEdit {
        background-color: #757575; /* Grey */
        color: #E0E0E0; /* Light Grey */
        border: 1px solid #BDBDBD;
    }
""",
"DEBUG - Debug Helper 4": """
    /* Main Window and Dialogs */
    QMainWindow, QDialog, QWidget {
        background-color: #1E1E1E; /* Eerie Black */
        color: #F0F0F0; /* Cultured White */
    }

    /* QGroupBox Styling */
    QGroupBox, QWidget {
        background-color: #87CEEB; /* Sky Blue */
        border: 2px solid #4682B4; /* Steel Blue */
        color: #FFFFFF; /* White text */
    }
    QGroupBox::title {
        background-color: transparent;
        color: #4682B4; /* Steel Blue */
        subcontrol-origin: margin;
        padding: 2px 5px;
    }

    /* QFrame Styling */
    QFrame {
        background-color: #87CEEB; /* Sky Blue */
        border: 1px solid #4682B4; /* Steel Blue */
    }

    /* Scroll Area and Scroll Bar Styling */
    QScrollArea {
        background-color: #333333; /* Very Dark Grey */
    }
    QScrollBar:vertical {
        background-color: #424242; /* Dark Grey */
        width: 10px;
    }
    QScrollBar::handle:vertical {
        background-color: #616161; /* Medium Grey */
        min-height: 20px;
    }
    QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
        background: #757575; /* Grey */
        height: 10px;
    }
    QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
        background: none;
    }

    /* Buttons */
    QPushButton {
        background-color: #FF6347; /* Tomato */
        color: #FFFFFF; /* White */
        border-radius: 4px;
    }
    QPushButton:hover {
        background-color: #FF4500; /* Orange Red */
    }

    /* Labels */
    QLabel {
        color: #FFFFFF; /* White */
    }

    /* Text Inputs */
    QLineEdit, QTextEdit {
        background-color: #4682B4; /* Steel Blue */
        color: #FFFFFF; /* White */
        border: 1px solid #87CEEB; /* Sky Blue */
    }

    /* Additional Controls */
    QComboBox, QSpinBox, QDoubleSpinBox {
        background-color: #6A5ACD; /* Slate Blue */
        color: #FFFFFF; /* White */
    }
    QComboBox QAbstractItemView {
        background-color: #483D8B; /* Dark Slate Blue */
        color: #FFFFFF; /* White */
    }
"""
        }
            
if __name__ == '__main__':
    QApplication.setQuitOnLastWindowClosed(False)
    app = QApplication(sys.argv)
    app.setApplicationDisplayName("TSTP:Omni Omega")
    app.setApplicationName("TSTP:Omni Omega")
    app.setOrganizationName("The Solutions To Problems, LLC")
    app.setWindowIcon(QIcon(resource_path('app_icon.ico')))
    ex = OmniOmega(None)
    setup_notes_environment()
    init_config_db(db_path, default_config)
    ex.show()  # Ensure that the main window shows up
    sys.exit(app.exec_())


